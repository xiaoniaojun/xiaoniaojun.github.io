<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[解耦Retrofit+Rxjava+Gson请求处理Json对象]]></title>
      <url>%2F2017%2F04%2F19%2F%E8%A7%A3%E8%80%A6Retrofit-Rxjava-Gson%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86Json%E5%AF%B9%E8%B1%A1.html</url>
      <content type="text"><![CDATA[废话最近在做一个面试项目，需求很简单，就是网络请求Json，然后显示在ListView中。正好，简单的需求可以让我自由自在地玩弄一下代码，正好学了这么久的设计模式，我的解耦大刀早已饥渴难耐。 一般做法网络请求一个Json并处理的一般步骤，在这里简单的说一下。首先构造Retrofit需要的API接口，然后使用Retrofit.create()给这个接口加上动态代理来，最后利用这个接口的方法，获取到需要的Observable对象。接下来利用Observable对象对得到的返回结果进行处理。 解耦效果最终，我写了一个高度聚合的模块，看看要完成上面这些步奏，我们的代码已经简化到这种程度： 1new FactsHandler&lt;Facts&gt;(new TestFactsHandler(),baseUrl,jsonFile).exec(); 其中Facts泛型类型是Json对应的JavaBean类型，这个TestFactsHandler是接口ICustomerFactsHandler的实现类，这个接口的定义如下： 123public interface ICustomerFactsHandler&lt;J&gt; &#123; public void handle(J jsonObject);&#125; 这个接口就是用来处理网络请求的返回结果的，这个结果就是经过Gson解析过后的Facts对象。所以，当我们需要自定义处理逻辑的时候，直接实现ICustomerFactsHandler就行啦~ 源代码具体解耦套路使用了静态工厂+ 策略模式，代码其实很简单，就是在泛型转换的时候多挣扎了一下（不扎实唉···） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class FactsHandler&lt;J&gt; &#123; public static final String TAG = "FactHandler"; // 默认构造参数，用于测试 public static final String DEFAULT_JSON = "facts.json"; private static final String BASE_URL = "https://raw.githubusercontent.com/goeasyway/SimpleListDemo/master/"; private ICustomerFactsHandler mHandler; private String mBaseUrl; private String mJsonFile; public FactsHandler(ICustomerFactsHandler handler) &#123; this(handler, BASE_URL, DEFAULT_JSON); &#125; public FactsHandler(ICustomerFactsHandler handler, String baseUrl, String jsonFile) &#123; mHandler = handler; mBaseUrl = baseUrl; mJsonFile = jsonFile; &#125; /** * 在主线程中执行处理函数 */ @SuppressWarnings("unchecked") public void exec() &#123; Observable&lt;J&gt; observable = (Observable&lt;J&gt;) ObserverFactory .create(mBaseUrl, mJsonFile); observable.subscribeOn(AndroidSchedulers.mainThread()) .subscribe(facts -&gt; &#123; mHandler.handle(facts); &#125;); &#125; /** * 更改处理方法 * * @param handler 实现&#123;@link ICustomerFactsHandler&#125;接口。 */ public void setHandler(ICustomerFactsHandler handler) &#123; mHandler = handler; &#125; /** * Observer工厂类 * 用于生产一个用网络io请求json的Observable对象 */ @SuppressWarnings(&#123;"unchecked", "UnnecessaryLocalVariable"&#125;) private static class ObserverFactory &#123; /** * @param baseUrl 基Url * @param json json对象名 * @param &lt;T&gt; Retrofit的API接口类型 * @return 装配好的Observable，可直接调用。 */ static &lt;T extends JsonService&gt; Observable&lt;?&gt; create(String baseUrl, String json) &#123; Retrofit retrofit = new Retrofit.Builder() .baseUrl(baseUrl) .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(Schedulers.io())) .addConverterFactory(GsonConverterFactory.create()) .build(); T jsonService = retrofit.create((Class&lt;T&gt;) JsonService.class); Observable&lt;?&gt; observable = jsonService.fetchJsonFeed(json); return observable; &#125; &#125;&#125; 最后自从学了设计模式，看见什么都tm是耦合的，看见什么都tm想解耦！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用transition框架]]></title>
      <url>%2F2017%2F03%2F26%2F%E4%BD%BF%E7%94%A8transition%E6%A1%86%E6%9E%B6.html</url>
      <content type="text"><![CDATA[使用Scenes和Transitions构建动画ViewsUI经常会由于响应用户输入或其他事件而产生变化。例如，一个activity中包含了一个表单供用户进行搜索。当用户提交搜索后这个表单会被隐藏，然后在这个表单的位置处显示一个列表来呈现搜索结果。 为了提供视觉上的连贯性，你可以使用动画来在不同的视图结构中进行变换。 Android有一个transitions framework，用来轻松地实现两种视图结构之间的动画变换。这个框架的动画机制是在运行时随时间改变视图的属性值来产生动画效果。框架中还内建了一些常用的动画效果，您也可以自定义动画和变换生命周期回调。 下面会介绍如何使用内建动画来在不同视图层次中执行变换，也会介绍如何自定义动画。 The Transitions Framework让您的ui具有丰富多彩的动画效果，不仅会提供视觉吸引力，还会因动画突显出的变化，为用户提供视觉线索，帮助用户了解您的app的工作过程。 为了帮助您在一个view层次结构之间进行动画，Android提供了Transition框架。此框架为view层次结构中的变化应用一个或多个动画。 这个框架具有以下特性： Group-level动画 为view层次中的view应用一个或多个动画效果。 基于变换的动画 基于从开始到结束不断改变view的属性值来实现动画。（值动画） 内建动画 提供预定义动画来满足一般的动画效果需求，例如渐变或者移动。 资源文件支持 可以从布局资源文件中加载view和内建动画。 生命周期回调 提供回调以更好地控制整个动画和view层次变化过程。 概览图1中的示例展示了如何利用动画来提供可视化提示从而帮助用户提升体验。随着app从搜索条视图变为搜索结果视图，不再使用的视图将会淡出，而新的视图将会淡入。 这个动画效果就使用了Transition框架。这个框架动态地变换两个视图层次结构中的所有View。View层次结构可以是简单地单个View组成，也可以是包含复杂ViewGroup的View树。框架通过在起始View层次到最终View层次中，改变其中View的一个或多个属性来实现动画。 transition框架在view层级与动画之间做了一个中间层。它的目的在于保存view层次结构的状态，在不同层次结构之间变换来改变屏幕显示，并且通过保存和执行动画定义来实现动画。 下图展示了View层次结构，框架对象以及动画三者之间的关系： 框架为场景、变换和变换管理器提供了抽象。之后会详细介绍它们。要使用这个框架，你需要为执行变换的视图层次创建scenes。接下来，您需要为用到的每个动画创建transition。要执行动画，你需要使用transition manager来指定transtion和ending scene。这个过程会在接下来详细说明。 Scenesscenes用于保存view层次结构的状态，包括它的所有View和View的属性值。View层次结构可以是一个单一View，也可以是由多个View和子layout构成的复杂View树。保存View层次结构到scene中后，你就可以将这个状态变换成另一个scene。框架提供了Scene类来表示一个scene。 transition框架允许你从布局资源文件或者ViewGroup对象中创建scenes。 如果你动态地生成一个视图层次结构或者在运行时修改它，那在代码中创建scenes是很有用的。 多数情况下，你不需要明确地创建初始scene。如果你已经应用了一个transition，framework就会在随后的transition中，使用之前的ending scene当做现在的start scene。如果你没有应用任何transition，framework就会收集当前屏幕状态当作view们的信息。 在你执行scene变换时，可以为scene定义actions。比如，在变换执行完之后用于清理view的设置。 除了视图层次结构以及它的属性值之外，scene还储存了对视图层次结构的父级的引用。此根视图称为scene root。scene的改变及影响scene的动画发生在scene root内部。 Transitions在transition framework中，动画创建了一系列的帧，描绘了starting和ending scenes中view hierarchies之间的变化。动画的先关信息储存在Transition对象中。使用TransitionManager实例应用transition，就可以开始执行动画。framework可以在两个不同的scene之间执行换换，也可以在当前scene的不同状态变换。 该框架包括一组内置的转换，用于常用的动画效果，如渐变和调整视图大小。您还可以使用animation framework中的API来自定义transitions以创建自己的动画效果。这个framework还允许您组合多重不同的内置或自定义transition到一个transition集合中。 Transition的生命周期与Activity的生命周期类似，它代表框架所监视的在动画开始和结束之间的transition状态。在重要的生命周期状态下，framework将会调用callback，您可以实现这些回调，以便在transition的不同阶段对用户界面进行调整。 局限 对SurfaceView应用的动画效果可能不会正常显示，因为它的实例会在非UI线程中更新，所以这个更新会导致其与其他动画不同步。 对TextureView执行某些transition可能不会产生期望的动画。 AdapterView的子类如（ListView）管理子视图的方式与Transition framework不兼容。如果您试图为它们设置动画，显示设备可能会挂起。 如果您视图使用动画调整TextView的大小，则文本会在TextView完全重新调整大小之前弹到新的位置上去。为了避免此问题，请勿为包含文本的view执行resizing动画。 创建SceneScene保存view hierarchy状态，包括它里面的所有view和它们的属性值。transition framework可以在起始scene和结束scene之间执行动画。起始scene通常都是由当前UI的状态来确定，而对于结束scene，您可以从布局资源文件或一组view中创建。 注意：其实如果只是在单个view中执行动画，可以不用scene。 从布局资源中创建Scene您可以从布局资源文件中创建一个scene实例。当资源文件中的view hierarchy大部分都是静态时推荐使用此方法。以此生成的scene表示创建Scene实例时view hierarchy的状态。如果你更改了view hierarchy，则需要重新创建scene。framework会将整个布局文件中的view hierarchy都创建出来，无法只创建文件中的一部分。 用这种方法创建scene，需要提供一个ViewGroup类型的scene root，调用Scene.getSceneForLayout())方法，还需要提供该布局文件的资源id。 为Scenes定义布局本节剩余部分将介绍如何使用相同的scene root来创建两个不同的scene。您可以看到这些代码还表明您可以加载多个不相关的Scene对象。 实例代码中的布局组成如下： 一个main layout，包含一个text label和一个子layout。 一个relative layout，作为第一个scene，有两个text field。 一个relative layout，作为第二个scene，有两个相同的text field，不过顺序不同。 这个例子中，动画发生在main layout的child layout中，main layout的text label始终是静态的。 main layout的定义如下： 1234567891011&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/master_layout"&gt; &lt;TextView android:id="@+id/title" ... android:text="Title"/&gt; &lt;FrameLayout android:id="@+id/scene_root"&gt; &lt;include layout="@layout/a_scene" /&gt; &lt;/FrameLayout&gt;&lt;/LinearLayout&gt; 这个布局定义了一个text field和一个子layout作为scene root。此时main layout中包含了第一个scene的布局。这样做使得app既可以将它作为起始ui的一部分显示，又能将它加载为scene。 第一个scene的布局如下： res/layout/a_scene.xml 1234567891011&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/scene_container" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;TextView android:id="@+id/text_view1 android:text="Text Line 1" /&gt; &lt;TextView android:id="@+id/text_view2 android:text="Text Line 2" /&gt;&lt;/RelativeLayout&gt; 下面这个布局用于第二个scene，它具有相同的text fields（相同的IDs），但是顺序不同。 res/layout/another_scene.xml1234567891011&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/scene_container" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;TextView android:id="@+id/text_view2 android:text="Text Line 2" /&gt; &lt;TextView android:id="@+id/text_view1 android:text="Text Line 1" /&gt;&lt;/RelativeLayout&gt; 从Layouts生成Scenes创建好这两个relative layout后，你就可以获取它们的scene了。之后你就可以在这两个UI之间配置Transition。要获取scene，您需要scene root的引用以及布局资源的ID。 下面的代码片段展示了如何获取scene root的引用以及如何从布局文件中创建Scene。 123456789Scene mAScene;Scene mAnotherScene;// Create the scene root for the scenes in this appmSceneRoot = (ViewGroup) findViewById(R.id.scene_root);// Create the scenesmAScene = Scene.getSceneForLayout(mSceneRoot, R.layout.a_scene, this);mAnotherScene = Scene.getSceneForLayout(mSceneRoot, R.layout.another_scene, this); 在这个app里，现在有两个Scene了。它们都使用res/layout/activity_main.xml内定义的FrameLayout作为scene root。 利用代码创建Scene您也可以使用代码从ViewGroup中创建一个Scene实例。这个方法适用于当你直接修改view hierarchy，或者动态地生成了它们。 要从代码中的view hierarchy创建Scene，使用Scene(sceneRoot, viewHierarchy)构造函数。此构造函数等同于在以及inflate过的布局文件中调用Scene.getSceneForLayout()方法。 1234567891011Scene mScene;// Obtain the scene root elementmSceneRoot = (ViewGroup) someOtherLayoutElement;// Obtain the view hierarchy to add as a child of the scene root// when this scene is enteredmViewHierarchy = (ViewGroup) someOtherLayoutElement;// Create a scenemScene = new Scene(mSceneRoot, mViewHierarchy); 创建Scene Actionsframework允许您定义系统在进入或退出场景时运行的自定义action。在多数情况下，自定义动作不是必要的，因为framework会自动让场景执行动画。 Scene Actions用于处理以下情况： 为不再同一view hierarchy下的view执行动画。您可以使用exit和entry scene action为起始场景和结束场景执行view动画。 为framework无法自动执行动画的view设置动画。例如ListView对象。 要提供自定义scene actions，您需要定义一个Runnable对象作为action，并且通过Scene.setExitAction()或Scene.setEnterAction()方法。framework会在执行变换动画之前为starting scene调用setExitAction()方法，在执行变换动画之后为ending scene调用setEnterAction()方法。 注意：不要使用scene actions在starting 和 ending scenes中的view之间传递数据。 执行Transition在Transition Framework中，动画会在starting和 ending scene中的view hierarchy创建一系列帧以描绘改变。framework中使用transition来表示动画，它包含了动画的信息。要执行动画，你需要为transition manager提供需要使用的transition对象和ending scene。 接下来介绍如何使用内置transitions来实现移动、改变尺寸和淡入淡出效果。之后会讲解如何自定义transitions。 创建Transition之前我们讲解了如何创建scene，用以表示不同view hierarchy的状态。当你已经定义好了starting scene和ending scene后，就需要创建一个Transition对象来定义动画。这个framework能让你利用资源文件生成内置transition并inflate它，或者你还可以直接通过代码创建内置transition。 Class Tag Attributes Effect AutoTransition - 默认的transition，淡出，移动和resize，淡出 Fade android:fadingMode=”[fade_in fade_out fade_in_out]” 略 ChangeBounds - 移动并resize views 从资源文件创建transition这种方法能使你不必改变activity中的代码就能修改transition定义。通过这种方法也能让你将复杂的变换定义从代码中分离出去。 要在资源文件中指定内置transition，执行以下步骤： 在project中添加res/transition/目录。 在这个目录内新建一个XML资源文件。 为XML添加内建transition节点。 例如，下面这个资源文件指定了Fade transition。 res/transition/fade_transition/xml 1&lt;fade xmlns:android="http://schemas.android.com/apk/res/android" /&gt; 下面的代码片段展示了在activity中如何从资源文件中inflate一个transition实例： 1Transition mFadeTransition = TransitionInflater.from(this).inflateTransition(R.transition.fade_transition); 利用代码创建transition实例这种方法用于动态创建transition对象，例如你在代码中修改了ui，并且可以创建不带参数的简单transition。 使用Transition内部定义的类的构造方法来创建内建transition。例如， 1Transition mFadeTransition = new Fade(); 执行Transition通常，变换用于对用户事件的相应。例如，考虑如下app：用户输入一个搜索条目并点击搜索按钮，app将搜索框淡出，并将结果列表淡入显示。 为了响应事件而执行scene变换，您需要调用TransitionManager.go()静态方法，传入ending scene和transition实例来执行动画： 1TransitionManager.go(mEndingScene, mFadeTransition); framework会根据transition指定的动画效果，将当前ui变换为ending scene内的scene root代表的view hierarchy。这里的starting scene是上次transition的ending scene。如果没有执行过transition，则会根据当前屏幕状态确定starting scene。 如果你没有指定transition，transition manager就会应用一个automatic transition，它会自动地完成一些适当的动画。更多详细信息请查阅TransitionManager API参考。 选择指定的目标View默认情况下，framework会为starting scene中的所有view应用transition。在某些情况下，你可能只需要对scene的某个子集执行动画。例如，framework并不支持为ListView执行动画，所以你不应该在transition中包含它们。这个framework允许你选择指定的view来执行动画。 每个执行动画的view称为target。你只能指定scene关联的view hierarchy中的部分作为target。 在开始执行transition之前，调用removeTarget())方法来将view从target中移除。使用addTarget())方法来添加target。 指定多个Transitions最佳的动画效果在于让动画类型与响应行为相匹配，例如淡出效果适用于那些不再使用的view。如果您希望移动view的位置，那么使用移动动画可以帮助用户确定view的新位置。 framework提供了多transition支持，让您可以在一个transition集内定义多个独立的transition效果。 下面的例子展示了如何在xml中定义transition集合： 123456&lt;transition xmlns:android="http://schemas.android.com/apk/res/android" android:tarnsitionOrdering="sequential"&gt; &lt;fade android:fadingMode="fade_out" /&gt; &lt;changeBounds /&gt; &lt;fade android:fadingMode="fade_in" /&gt;&lt;/transtion&gt; 需要调用TransitionInflater.from())方法来inflate Transition集合到一个TransitionSet对象中。这个TransitionSet类继承自Transition，所以你可以直接用transition manager来使用它。 Apply a Transition Without Scenes改变view hierarchy并不是修改ui的唯一方法。你也可以通过在当前view hierarchy中添加、修改、移除子view来更改ui。例如，你可以只用一个layout来完成搜索功能：一开始在layout中显示一个搜索条目和搜索图标。当用户点击搜索按钮后，使用ViewGroup.removeView()移除搜索条并用ViewGroup.addView()来添加搜索结果。 如果另一个方案需要两个几乎相同的view hierarchy，就可以考虑使用这种方式替代。 如果采用这种方式，你就不必创建scene了。你可以使用delayed transition来在view hierarchy的不同状态下变换。这种机制的工作原理是，在你开始更改View hierarchy之前，开始记录更改，最后在系统重绘ui时执行动画。 在单个view hierarchy中创建delayed transition，需要执行如下步骤： 当事件触发，需要执行变换时，调用TransitionManager.beginDelayedTransition()方法并提供需要执行动画的所有view的parent view和需要使用的transition。framework会自动将这些状态保存起来。 根据需要修改这些view，framework会记录你对这些view以及它们的属性的修改。 当系统开始重绘ui时，会根据您做出的更改，执行动画。 下面是代码示例： res/layout/activity_main.xml 123456789101112&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/mainLayout" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;EditText android:id="@+id/inputText" android:layout_alignParentLeft="true" android:layout_alignParentTop="true" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; ...&lt;/RelativeLayout&gt; 下面的代码展示了添加一个text view的动画：MainActivity.java 12345678910111213141516171819202122232425private TextView mLabelText;private Fade mFade;private ViewGroup mRootView;...// 加载layoutthis.setContentView(R.layout.activity_main);...// 创建并设置TextViewmLabelText = new TextView();mLabelText.setText("Label").setId("1");// 获取root View并创建一个transitionmRootView = (ViewGroup) findViewById(R.id.mainLayout);mFade = new Fade(IN);// 开始记录对view hierarchy的更改TransitionManager.beginDelayedTransition(mRootView, mFade);// 在view hierarchy中添加TextViewmRootView.addView(mLabelText);// 当系统重绘界面显示这个改变时，// framework会自动添加fade in动画 定义transition生命周期回调这个transition生命周期和Activity的生命周期差球不多。它代表从调用TransitionManager.go()方法到动画结束这期间的transition状态。在重要的阶段，framework会调用TransitionListener接口定义的回调。 比如说，在scene改变的时候，拷贝从starting view hierarchy到ending view hierarchy之中的view的属性值。你不能简单地就从starting view拷贝属性值到ending view，因为ending view在动画结束之前还不会被inflate。所以，你必须在framework完成动画之后，将实现拷贝在变量内的值赋给新的视图。通过在Activity实现TransitionListener.onTransitionEnd())方法，来在Transition完成时得到通知。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android中是如何绘制View的]]></title>
      <url>%2F2017%2F03%2F25%2FAndroid%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%98%E5%88%B6View%E7%9A%84.html</url>
      <content type="text"><![CDATA[Android中是如何绘制View的当一个Activity获得焦点时，会被请求绘制它的布局。Android framework会处理这个绘制过程，但是Activity必须提供它的布局层次中的根节点。 绘制从布局的根节点开始。它被要求measure并且draw布局树。绘制的过程是遍历整个布局树，并且渲染每个相交于无效区域的View。每个ViewGroup的职责是请求它的所有孩子进行draw()，每个View的职责是绘制自身。因为布局树的是顺序遍历的，这就意味着双亲会在孩子之后绘制，而兄弟们则是按照在布局树中的顺序被绘制的。 绘制布局的过程是两个过程：一个measure过程和一个layout过程。测量传递是自上而下对整棵树调用其measure(int,int)方法。遍历时每个View沿着布局树推送它的尺寸规格。在测量过程的最后，每个View都保存了自己的测量数据。第二个过程产生于layout(int,int,int,int)中，也是自上而下的。在这个传递过程中，每个双亲负责使用测量过程中得到的数据来定位其孩子。 当View对象的measure()方法返回时，它的getMeasuredWidth()和getMeasuredHeight()值必须被设置，并且它的后代View对象的这些值也必须被设置。View对象的measured width和measured height值必须遵循View双亲施加的约束。这确保了在测量过程的末期，所有双亲能接受到它们的所有孩子的测量值。双亲View可能为其孩子调用多次measure()方法。例如，如果孩子们的无约束尺寸过大或过小，双亲也许会测量每个没有指定尺寸的孩子们，它们需要多大的空间，然后再次测量它们的实际大小值。（也就是说，如果孩子们认为它们获得的空间不合适，那么双亲会根据规则来进行第二次测量）。 测量过程通过使用两个类来传递维度。ViewGroup.LayoutParams类用来让View对象告诉它的双亲，它们希望如何被测量和定位。基础ViewGroup.LayoutParams类只是描述View想要多大的空间，包括width和height。对于每个维度，它可以被设置为以下值： 一个实际的数值 MATCH_PARENT，意味着View希望占其双亲空间越大越好（除去padding）WRAP_CONTENT，意味着View仅仅希望大小能包裹其内容就好（加上padding）。 对于不同的ViewGroup子类，还有其他与其对应的ViewGroup.LayoutParams子类。例如，RelativeLayout拥有其独有的ViewGroup.LayoutParams子类。使用这个子类可以让其子View在水平或竖直方向居中。 MeasureSpec对象用于在树中将父对象的测量值推送给子对象。MeasureSpec可以是一下三个模式： UNSPECIFIED：用于双亲，用来确定子View的尺寸。例如，一个LinearLayout可能在其孩子上调用measure()方法，将其Height设置为UNSPECIFIED，width设置为EXACTLY 240来寻找子View（宽度为240）需要的高度。 EXACTLY：用来让双亲给子View一个确定的尺寸值。子View必须使用该值作为其大小，并确保其所有后代适应这个值。 AT_MOST：用来让双亲设置一个最大尺寸值给其孩子。其孩子必须确保后代能满足这个尺寸。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据绑定库【译】]]></title>
      <url>%2F2017%2F03%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%BA%93%E3%80%90%E8%AF%91%E3%80%91.html</url>
      <content type="text"><![CDATA[Data Binding Library这篇文档介绍了如何使用数据绑定库来编写声明性布局，以及如何利用它来最大限度地减少绑定app逻辑和布局所需的粘合二者的代码。 数据绑定库提供了灵活性和极强的兼容性 —— 它是一个支持库，因此您可以在Android 2.1（API级别为7+）以上的平台上兼容它。 需要在Gradle 1.5.0-alpha1或者更高版本下才能使用数据绑定。 Build Environment使用以下代码片段来配置数据绑定： 123456android &#123; .... dataBinding &#123; enabled = true &#125;&#125; 如果您有一个依赖数据绑定库的app module，则应app Module必须在其build.gradle文件中配置。并且，需要在Android Studio 1.3以上才能兼容。 Data Binding Layout Files编写第一组数据绑定表达式数据绑定布局文件略有不同，从布局的根标记开始，后跟数据元素和视图根元素。这个视图元素是无数据绑定的布局文件中的根。示例文件如下所示： 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;variable name="user" type="com.example.User"&gt; &lt;/data&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.firstName&#125;"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.lastName&#125;"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; data标签内的user变量描述了可在此布局文件中使用的属性(property)。 1&lt;variable name="user" type="com.example.User"/&gt; 布局中的表达式使用&quot;@{}&quot;语法写入变量属性。此处TextView文本被设置为userName的firstName属性。 123&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.firstName&#125;"/&gt; Data Object首先假设我们有一个POJO User类： 12345678public class User &#123; public final String firstName; public final String lastName; public User(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125; 这种类型的对象的数据不会被更改。app中会经常见到这种只读而不会被更改的数据。也可以使用JavaBean对象： 1234567891011121314public class User &#123; private final String firstName; private final String lastName; public User(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125; public String getFirstName() &#123; return this.firstName; &#125; public String getLastName() &#123; return this.lastName; &#125;&#125; 从数据绑定的角度来看，这两个类是等价的。TextView中的android:text属性将会被设置为@{user.firstName}，这个值在第一种User类中会访问firstName字段，后一种类中会调用getFirstName()方法。或者，如果存在firstName()方法，也会被正确解析。 绑定数据默认情况下，系统会根据布局文件的名称来生成一个Binding类，将其转换为驼峰式命名并以”Binding”为后缀。上面的布局文件是main_activity.xml，所以生成类的名字为MainActivityBinding。该类会持有从布局属性（例如user变量）到布局view的所有binding，并知道如何为binding表达式赋值。创建binding最简单的方法是在inflating时进行： 1234567@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); MainActivityBinding binding = DataBindingUtil.setContentView(this, R.layout.main_activity); User user = new User("Test","User"); binding.setUser(user);&#125; 完成啦！运行app，你会看到Test User。你也可以通过如下方式获取view： 1MainActivityBinding binding = MainActivityBinding.inflate(getLayoutInflater()); 如果您在ListView或RecyclerView Adapter中使用数据绑定项目，则推荐使用： 123ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup, false);// orListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false); Event Handing数据绑定允许您编写表达式处理从view分派的事件（如onClick）。事件属性名称由Listener方法演化而来，但有一些例外。例如，View.OnLongClickListener有一个onLongClick()方法，所以这个事件的属性是android:onLongClick。有两种处理事件的方法。 方法引用(Method Reference)：在表达式中，可以引用符合Listener方法签名的方法。当表达式的值为方法引用时，数据绑定将方法引用和所有者对象包装在Listener中，并在目标view上设置Listener，如果表达式值为null，则数据绑定不会创建Listener，而是设置一个null Listener。 Listener绑定（Listener Bindings）：它们是lambda表达式，会在事件发生时进行求值。数据绑定总是会创建一个Listener设置在view中。当事件调度时，Listener会计算Lambda表达式。 方法引用事件可以被直接绑定到处理方法中，类似于android:onClick可以分配给Activity中的一个方法。与View#onClick属性相比，它的一个主要优点是表达式在编译时被处理，因此如果该方法不存在或者签名不正确，则会收到编辑时错误。 方法应用和Listener绑定之间最主要的区别在于，前者当数据绑定时才创建实际的Listener实现，而不是触发事件时。如果您希望在事件发生时对表达式求值，则应该使用Listener绑定。 使用绑定表达式为一个事件指派处理程序，其值为要调用的方法名称。例如，如果您的数据对象有两个方法： 123public class MyHandlers &#123; public void onClickFriend(View view) &#123; ... &#125;&#125; 绑定表达式可以为view分配click listener： 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;variable name="handlers" type="com.example.Handlers" /&gt; &lt;variable name="user" type="com.example.User" /&gt; &lt;/data&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.firstName&#125;" android:onClick="@&#123;handlers::onClickFriend&#125;" /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 请注意，表达式中方法的签名必须与listener对象中的方法签名完全匹配。 Listener绑定Listener绑定是当事件发生时运行的绑定表达式。它们与方法引用类似，但是它们允许您运行任意数据绑定表达式。这个特性适用于Gradle版本2.0及更高版本的Android Gradle插件。 在方法引用中，方法的参数必须与Listener的参数相匹配。在Listener绑定中，只需要您的返回值必须与listener期望的返回值相匹配（除非期望的是void）。例如，一个演示类有以下方法： 123public class Presenter &#123; public void onSaveClick(Task task) &#123;&#125;&#125; 你可以通过如下方式绑定点击事件： 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;variable name="task" type="com.android.example.Task" /&gt; &lt;variable name="presenter" type="com.android.example.Presenter" /&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:onClick="@&#123;() -&gt; presenter.onSaveClick(task)&#125;"/&gt; &lt;/LinearLayout&gt; &lt;/data&gt;&lt;/layout&gt; Listener只能作为表达式的root元素允许的lambda表达式表示。当表达式中使用回调时，数据绑定会自动为事件创建必要的Listener和注册。当view触发事件时，数据绑定会计算给定的表达式。与常规的绑定表达式一样，在listener对表达式求值时，你仍然能获得null安全性和线程安全性。 注意，在上面的实例中，我们还没有定义传入onClick(android.view.View)的view参数。Listener绑定为listener参数提供了两个选择：您可以忽略该方法的所有参数或者全部名称。如果你喜欢为参数命名，你可以在表达式中使用它们，例如，上例可以写成： 1android:onClick="@&#123;(view) -&gt; presenter.onSaveClick(task)&#125;" 或者如果您希望在表达式中使用参数，也可以用以下方式： 123public class Presenter &#123; public void onSaveClick(View view, Task task) &#123;&#125;&#125; 1android:onClick="@&#123;(theView) -&gt; presenter.onSaveClick(theView, task)&#125;" 你也可以使用多个参数的lambda表达式： 123public class Presenter &#123; public void onCompletedChanged(Task task, boolean completed) &#123;&#125;&#125; 12&lt;CheckBox android:layout_width="wrap_content" android:layout_height="wrap_content" android:onCheckedChanged="@&#123;(cb, isChecked) -&gt; presenter.completeChanged(task, isChecked)&#125;" /&gt; 如果正在监听的事件返回了一个不为void的值，则表达式也必须返回相同类型的值。例如，如果要监听long click event，则表达式应该返回boolean值。 123public class Presenter &#123; public boolean onLongClick(View view, Task task) &#123;&#125;&#125; 1android:onLongClick="@&#123;(theView) -&gt; presenter.onLongClick(theView, task)&#125;" 如果表达式由于null对象而无法估值，则Data Binding返回该类型的默认Java值。例如，引用类型为null，int为0，布尔值为false等。 如果您需要使用带有谓词（例如三元）的表达式，则可以使用void作为符号。 1android:onClick="@&#123;(v) -&gt; v.isVisible() ? doSomething() : void&#125;" 避免复杂的ListenersListener表达式非常强大，可以使得您的代码非常易读。另一方面，包含复杂表达式的Listener将会使得您的布局难以阅读和维护。这些表达式应该像将UI中的可用数据传递给您的回调方法一样简单。您应该在从监听器表达式调用的回调方法中实现业务逻辑。这里有一些专门的点击事件handlers，它们需要android:onClick之外的其他属性来避免冲突。目前已经创建了一下属性来避免冲突： Class Listener Setter Attribute SearchView setOnSearchClickListener(View.OnClickListener) android:onSearchClick ZoomControls setOnZoomInClickListener(View.OnClickListener) android:onZoomIn ZoomControls setOnZoomOutClickListener(View.OnClickListener) android:onZoomIn Layout Detailsimports可以在数据元素内部使用0个或多个导入元素。它们可以轻松地引用布局文件中的类，就像Java一样。 123&lt;data&gt; &lt;import type="android.view.View" /&gt;&lt;/data&gt; 现在，View可以在您的binding表达式中使用了： 12345&lt;TextView android:text="@&#123;user.lastName&#125;" android:layout_width="wrap_content" android:layout_height="wrap_content" android:visibility="@&#123;user.isAdult ? View.VISIBILE : View.GONE&#125;"/&gt; 如果有类的名称发生了冲突，其中一个类可以使用”alias：“重命名 123&lt;import type="android.view.View"/&gt;&lt;import type="com.example.real.estate.View" alias="Vista" /&gt; 现在，Vista可以用来引用com.example.real.estate.View，而View则是引用android.view.View。引用类型可以当做类型引用在变量或表达式中使用： 123456&lt;data&gt; &lt;import type="com.example.User"/&gt; &lt;import type="java.util.List"/&gt; &lt;variable name="User" type="User"/&gt; &lt;variable name="userList" type="List&lt;User&gt;"/&gt;&lt;/data&gt; 注意：Android Studio尚未处理import，因此导入的变量的autocomplete功能可以无法再AS中使用。您的app仍然可以通过编译。可以通过在变量中使用完全限定名称来决绝这个问题。 1234&lt;TextView android:text="@&#123;((User)(user.connection)).lastName&#125;" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; 引用类型也可以使用在引用静态域或静态方法的表达式中： 123456789&lt;data&gt; &lt;import type="com.example.MyStringUtils"/&gt; &lt;variable name="user" type="com.example.User"/&gt;&lt;/data&gt;...&lt;TextView android:text="@&#123;MyStringUtils.capitalize(user.lastName)&#125;" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; 相当于在Java中，java.lang.*被自动引用一样。 Variablesdata元素内可以使用任意数量的变量。每个变量元素描述在布局中设置的属性，以便在布局文件的binding表达式中使用。 123456&lt;data&gt; &lt;import type="android.graphics.drawable.Drawable"/&gt; &lt;variable name="user" type="com.example.User"/&gt; &lt;variable name="image" type="Drawable" /&gt; &lt;variable name="note" type="String" /&gt;&lt;/data&gt; 变量的类型会在编译期间进行检查，因此如果一个变量实现了Observable或者是一个observable集合，就应该反映在类型中。如果变量不是实现Observable*的接口或者基类，这个变量就不会被观察到！ 当有多个不同的布局文件对应不同的配置（例如横向或纵向）时，这些变量将会被组合。所以这些布局文件之间不能有冲突的变量定义。 生成的binding类将会为每个被描述的变量设置setter/getter。在setter被调用前，这些变量将会采用默认的Java值。 binding类中会自动生成一个context变量，用于在binding表达式中按需使用。这个context的值为根view的getContext()值。context变量会被具有相同名称的显式变量声明所覆盖。 Custom Binding Class Names默认情况下，Binding类的名字是根据布局文件生成的。该类会被放在module包下的databinding包中。例如，布局文件contact_item.xml将生成ContactItemBinding类。如果module包为com.example.my.app，那么它会被放在com.example.my.app.databinding中。 可以自己调整data元素的属性，来改变Binding类的名称，或者放置在不同的包中。例如： 123&lt;data class="ContactItem"&gt; ...&lt;/data&gt; 这将在Module包中的databinding包中生成ContactItem类。如果该类应该在模块包中的不同包中生成，可以使用”.”作为前缀。 123&lt;data class="com.example.ContactItem"&gt; ...&lt;/data&gt; Includes变量可以通过使用application namespace和属性中的变量名称传递到包含布局绑定中： 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:bind="http://schemas.android.com/apk/res-auto"&gt; &lt;data&gt; &lt;variable name="user" type="com.example.User"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;include layout="@layout/name" bind:user="@&#123;user&#125;"/&gt; &lt;include layout="@layout/contact" bind:user="@&#123;user&#125;"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 这里，name.xml和contact.xml布局文件中都必须有一个用户变量。数据绑定不支持include作为合并元素的直接子元素。例如，下面的布局是不被允许的： 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:bind="http://schemas.android.com/apk/res-auto"&gt; &lt;data&gt; &lt;variable name="user" type="com.example.User"/&gt; &lt;/data&gt; &lt;merge&gt; &lt;include layout="@layout/name" bind:user="@&#123;user&#125;" /&gt; &lt;include layout="@layout/contact" bind:user="@&#123;user&#125;" /&gt; &lt;/merge&gt;&lt;/layout&gt; 表达式语言普通特性表达式语言和java表达式很像: Mathematical + - / * % String concatenation + Logical &amp;&amp; || Binary &amp; | ^ Unary + - ! ~ Shift &gt;&gt; &gt;&gt;&gt; &lt;&lt; Comparison == &gt; &lt; &gt;= &lt;= instanceof Grouping () Literals - character, String, numeric, null Cast Method calls Field access Array access [] Ternary operator ?: 例子： 123android:text="@&#123;String.valueOf(index +1)&#125;"android:visibility="@&#123;age &lt; 13 ? View.GONE : View.VISIBLE&#125;"android:transitionName='@&#123;"image_" + id&#125;' 缺失的操作符一些Java中有的操作符在表达式语法中缺失了： this super new Explicit generic invocation Null Coalescing Operator这个操作符(??)在左边不为null时选择左边的值作为表达式值，否则选右边。 1android:text="@&#123;user.displayName ?? user.lastName&#125;" 在功能上等价于： 1android:text="@&#123;user.displayName != null ? user.displayName: user.lastName&#125;" 属性引用（Property Reference）第一个已经在上面的”Writing your first data binding expressions”中说过了：简单地JavaBean引用。当表达式引用了；类中的属性时，它对于域、getter和Observable域使用相同的格式。 1android:text="@&#123;user.lastName&#125;" 避免空指针异常自动生成的数据绑定代码会检查null并避免空指针异常。例如，在表达式@{user.name}中，如果user为null，那么user.name将被分配其默认值(null)。如果你引用user.age，其中age是一个int，那么它默认为0。 容器常见的集合：数组、列表、稀疏列表和映射，可以使用[]操作符快捷地访问。 1234567891011121314&lt;data&gt; &lt;import type="android.util.SparseArray"/&gt; &lt;import type="java.util.Map"/&gt; &lt;variable name="list" type="List&lt;String&gt;"/&gt; &lt;variable name="sparse" type="SparseArray&lt;String&gt;"/&gt; &lt;variable name="index" type="int"/&gt; &lt;variable name="key" type="String"/&gt;&lt;/data&gt;...android:text="@&#123;list[index]&#125;"...android:text="@&#123;sparse[index]&#125;"...android:text="@&#123;map[key]&#125;" 字符串字面量当使用单引号包裹属性值时，通过双引号可以轻松地表示字符串字面量。 1android:text='@&#123;map&#123;"firstName"&#125;&#125;' 也可以使用双引号包裹属性值。这种情况下，字符串字面量需要用单引号或者``包裹。 资源可以通过使用一般的表达式来访问资源： 1android:padding="@&#123;large? @dimen/largePadding: @dimen/smallPadding&#125;" 格式化字符串和复数（plurals）可以通过提供参数进行求值： 12android:text="@&#123;@string/nameFormat(firstName, lastName)&#125;"android:text="@&#123;@plurals/banana(bananaCount)&#125;" 当复数需要多个参数时，应该传递所有的参数进去： 1234Have an orangeHave %d orangesandroid:text="@&#123;@plurals/orange(orangeCount, orangeCount)&#125;" 一些资源要求明确的类型估值： Type Normal Reference Expression Reference String[] @array @stringArray int[] @array @intArray TypedArray @array @typedArray Animator @animator @animator StateListAnimator @animator @stateListAnimator color int @color @color ColorStateList @color @colorStateList Data Objects任何普通的POJO可能用于数据绑定，当修改POJO不会导致UI更新。数据绑定的真正强大之处在于它可以使数据对象能够在数据更改时发出通知。有三种不同的数据更改通知机制，Observable对象，Observable域和Observable容器。 当这些Observable数据对象被绑定到UI并且数据对象的属性改变时，UI将会被自动更新。 Observable Objects实现Observable接口的类将允许绑定将单个listener附加到绑定对象以监听该对象上所有属性的更改。 Observable接口具有添加和移除listener的机制，但通知功能由开发人员决定。为了简化开发，可以使用BaseObservable来实现监听器机制。数据类实现者仍然负责在属性改变时通知。这是通过将Bindable注释分配给getter并在setter中通知来实现的。 1234567891011121314151617181920private static class User extends BaseObservable &#123; private String firstName; private String lastName; @Bindable public String getFirstName() &#123; return this.firstName; &#125; @Bindable public String getLastName() &#123; return this.lastName; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; notifyPropertyChanged(BR.firstName); &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; notifyPropertyChanged(BR.lastName); &#125;&#125; Bindable注解在编译期间在BR类文件中生成一个条目。BR类文件将在Module包中生成。如果数据类的基类不能更改，则可以使用PropertyChangeRegistry来方便地实现Observable接口，以有效地储存和通知listener。 ObservableFields创建Observable类涉及到一些繁杂的工作，所以想要节省时间或者如果只有少量的属性，可以使用ObservableField及其兄弟ObservableBoolean，ObservableByte，ObservableChar，ObservableShort，ObservableInt，ObservableLong，ObservableFloat，ObservableDouble和ObservableParcelable。 ObservableFields是具有单个字段的自包含可观察对象。 原始版本在访问操作期间避免了装箱和拆箱。 要使用它，在数据类中创建一个公共final字段： 12345private static class User &#123; public final ObservableField&lt;String&gt; firstName = new ObservableField&lt;&gt;(); public final ObservableField&lt;String&gt; lastName = new ObservableField&lt;&gt;(); public final ObservableInt age = new ObservableInt();&#125; 好了，现在可以使用set或get方法来访问这个值了： 12user.firstName.set("Google");int age = user.age.get(); Observable容器一些应用程序会使用其他动态数据结构来储存数据。Observable容器用于使用键来访问这些数据对象。当键为引用类型如String时，ObservableArrayMap非常有效。 1234ObservableArrayMap&lt;String, Object&gt; user = new ObservableArrayMap&lt;&gt;();user.put("firstName", "Google");user.put("lastName", "Inc.");user.put("age", 17); 在布局中，使用String键来访问映射： 12345678910111213&lt;data&gt; &lt;import type="android.databinding.ObservableMap" /&gt; &lt;variable name="user" type="ObservableMap&lt;String, Object&gt;" /&gt;&lt;/data&gt;...&lt;TextView android:text='@&#123;user["lastName"]&#125;' ... /&gt;&lt;TextView android:text='@&#123;String.valueOf(1 + (Integer)user["age"])&#125;' ... /&gt; 当键为Integer时，ObservableArrayList会更加适用： 1234ObservableArrayList&lt;Object&gt; user = new ObservableArrayList&lt;&gt;();user.add("Google");user.add("Inc.");user.add(17); 在布局文件中，可以通过索引来访问list： 1234567891011121314&lt;data&gt; &lt;import type="android.databinding.ObservableList"/&gt; &lt;import type="com.example.my.app.Fields"/&gt; &lt;variable name="user" type="ObservableList&lt;Object&gt;"/&gt;&lt;/data&gt;...&lt;TextView android:text='@&#123;user[Fields.LAST_NAME]&#125;' ... /&gt;&lt;TextView android:text='@&#123;String.valueOf(1 + (Integer)user[Fields.AGE])&#125;' ... /&gt; Generated Binding生成的binding类将布局变量与布局中的view链接。如前所述，可以定制Binding名称和包。生成的绑定类继承于ViewDataBinding。 Creating在inflation之后需要尽快创建binding，以确保在布局中使用表达式绑定到试图之前，不会扰乱view层次结构。有几种方法绑定到布局。最常见的是在Binding类上使用静态方法。inflate方法会使View层次结构inflate，并且将其全部绑定到一个步骤。有一个更简单的版本，只需要一个LayoutInflater，和一个ViewGroup： 12MyLayoutBinding binding = MyLayoutBinding.inflate(layoutInflater);MyLayoutBinding binding = MyLayoutBinding.inflate(layoutInflater, viewGroup, false); 如果布局使用其他机制来inflate，它可以被独立地绑定： 1MyLayoutBinding binding = MyLayoutBinding.bind(viewRoot); 有时我们无法提前知道会使用绑定。在这种情况下，可以使用DataBindingUtil类创建binding： 12ViewDataBinding binding = DataBindingUtil.inflate(LayoutInflater, layoutId, parent, attachToParent);ViewDataBinding binding = DataBindingUtil.bindTo(viewRoot, layoutId); Views With IDs在布局中会为每个拥有ID的view生成一个public final字段。绑定会在View层次结构上执行一次传递，使用Id提取视图。在某些view中这种机制比起调用findViewById更加有效率。例如： 123456789101112131415161718&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;variable name="user" type="com.example.User"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.firstName&#125;" android:id="@+id/firstName"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.lastName&#125;" android:id="@+id/lastName"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 在binding类中会生成： 12public final TextView firstName;public final TextView lastName; ID一般不需要使用数据绑定，但仍然有一些情况，需要通过代码来访问视图。 Variables每个变量都会被创建getter/setter。 123456&lt;data&gt; &lt;import type="android.graphics.drawable.Drawable"/&gt; &lt;variable name="user" type="com.example.Uesr"/&gt; &lt;variable name="image" type="Drawable"/&gt; &lt;variable name="note" type="String" /&gt;&lt;/data&gt; 123456public abstract com.example.User getUser();public abstract void setUser(com.example.User user);public abstract Drawable getImage();public abstract void setImage(Drawable image);public abstract String getNote();public abstract void setNote(String note); ViewStubsViewStubs与普通的视图略有不同。它们最开始是不可见的，当可见时或者被明确告知需要inflate时，它们会inflate另一个布局来替换自己的布局。 因为ViewStub基本上会从view层次结构中消失，所以binding对象也会消失以允许collection。因为view是final的，最终ViewStub会被一个ViewStubProxy对象取代，让开发人员可以在ViewStub存在时访问它，并且当ViewStub已经被inflate后访问inflate之后的view层次结构。 当inflating另一个布局时，必须为新的布局确定binding。因此，ViewStubProxy必须监听ViewStub.OnInflateListener并及时建立binding。由于ViewStubProxy只能有一个，所以它允许开发人员为它设置一个OnInflateListener并且在建立binding之后监听器会被调用。 Advanced Binding动态变量有时，我们不知道具体要绑定的类。例如，对于RecyclerView.Adapter基于的任意布局的操作，将不会知道特定的Binding类。所以它仍然必须在onBindViewHolder(VH, int))期间分配绑定值。 在这个例子中，所有RecyclerView绑定的布局会有一个“item”变量。BindingHolder有一个getBinding方法用于返回ViewDateBinding base。 12345public void onBindViewHolder(BindingHolder holder, int position) &#123; final T item = mItems.get(position); holder.getBinding().setVariable(BR.item, item); holder.getBinding().executePendingBindings();&#125; 立即绑定当变量或Observable发生变化时，绑定更改会被安排在下一帧前进行。有时候，绑定必须立即执行。需要强制执行绑定，请使用executePendingBindings()方法。 后台线程只要数据模型不是一个集合，你就可以在后台线程中更改它。数据绑定会本地化每个字段/变量同时进行估值以避免任何并发问题。 Attribute Setters每当绑定值发生变化时，生成的binding类必须在view上调用setter方法。数据绑定框架有自己的方法来自定义调用哪个方法来设置值。 Automatic Setters对于一个属性，数据绑定会试图寻找对应的set方法。该属性的命名空间不重要，只要属性名本身。例如，与TextView的属性android:text绑定的表达式将会寻找一个setText(String)方法。如果表达式返回一个int，数据绑定会搜索一个setText(int)方法。要注意让表达式返回正确的类型，如果需要的话要进行类型转换。注意即使不存在给定名称的这个属性，数据绑定也会工作。你可以通过使用数据绑定轻松地为任何setter“创建”属性。例如，支持库DrawerLayout没有任何属性，但是有大量的setter。您可以使用自动setter来使用它们。 12345&lt;android.support.v4.widget.DrawerLayout android:layout_width="wrap_content" android:layout_height="wrap_content" app:scrimColor="@&#123;@color/scrim&#125;" app:drawerListener="@&#123;fragment.drawerLayout&#125;"/&gt; 重命名Setters某些属性的setter与其名称不匹配。对于这些方法，可以通过BindingMethods注解将属性与setter相互关联。必须与一个类相关联，并且每个方法都要包含BindingMethod注解。例如，android:tint属性实际上是与setImageTintList(ColorStateList)相关联的，而不是setTint。 12345@BindingMethods(&#123; @BindingMethod(type="android.widget.ImageView", attribute="android:tint", method="setImageTintList"),&#125;) 其实开发人员一般无需重命名setters；Android框架中这些属性的重命名已经被实现了。 Custom Setters某些属性需要自定义binding逻辑。例如，android:paddingLeft属性就没有与其关联的setter。相反，存在方法setPadding(left,top,right,bottom)。通过BindingAdapter注解声明的静态绑定适配器方法允许开发人员自定义如何调用属性的setter。 Android属性已经创建了相应的BindingAdapters，例如，对于paddingLeft： 1234567@BindingAdapter("android:paddingLeft")public static void setPaddingLeft(View view, int padding) &#123; view.setPadding(padding, view.getPaddingTop(), view.getPaddingRight(), view.getPaddingBottom());&#125; 绑定适配器可以用于其他类型的自定义。例如，一个自定义加载器可以用于离线加载图片。 当发生冲突时，自定义Adapter会取代默认的绑定适配器。 你也可以定义具有多个参数的适配器。 1234@BindingAdapter(&#123;"bind:imageUrl", "bind:error"&#125;)public static void loadImage(ImageView view, String url, Drawable error) &#123; Picasso.with(view.getContext()).load(url).error(error).into(view);&#125; 12&lt;ImageView app:imageUrl="@&#123;venue.imageUrl&#125; app:error="@&#123;@drawable/venueError&#125;"/&gt; 当ImageView的imageUrl和error属性都存在且imageUrl是一个String而error是一个Drawable时，这个适配器就会被调用。 自定义命名空间会在匹配期会被忽略。 你也可以为Android命名空间编写适配器。 绑定适配器方法可以选择在其处理程序中使用旧值。使用旧值和新值并存的方法一个具有属性的所有旧值，然后跟上新值。 123456789@BindingAdapter("android:paddingLeft")public static void setPaddingLeft(View view, int oldPadding, int newPadding) &#123; if (oldPadding != newPadding) &#123; view.setPadding(newPadding, view.getPaddingTop(), view.getPaddingRight(), view.getPaddingBottom()); &#125;&#125; 事件处理程序只能用于只有一个抽象方法的接口或抽象类。例如： 1234567891011@BindingAdapter("android:onLayoutChange")public static void setOnLayoutChangeListener(View view, View.OnLayoutChangListener oldValue, View.OnLayoutChangeListener newValue) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123; if (oldValue != null) &#123; view.removeOnLayoutChangeListener(oldValue); &#125; if (newValue != null) &#123; view.addOnLayoutChangeListener(newValue); &#125; &#125;&#125; 当一个listener具有多个方法，它就必须被分割成多个Listener。例如，View.OnAttachStateChangeListener有两个方法：onViewAttachedToWindow()和onViewDetachedFromWindow()。我们必须创建两个接口来区分属性和处理程序： 123456789@TargetApi(VERSION_CODES.HONEYCOMB_MR1)public interface OnViewDetachedFromWindow &#123; void onViewDetachedFromWindow(View v);&#125;@TargetApi(VERSION_CODES.HONEYCOMB_MR1)public interface OnViewAttachedToWindow &#123; void onViewAttachedToWindow(View v);&#125; 因为改变一个Listener也会影响另一个，我们必须要有三个不同的绑定适配器，其中两个针对每一个属性，剩下的针对两者。 1234567891011121314151617181920212223242526272829303132333435363738394041424344@BindingAdapter("android:onViewAttachedToWindow")public static void setListener(View view, OnViewAttachedToWindow attached) &#123; setListener(view, null, attached);&#125;@BindingAdapter("android:onViewDetachedFromWindow")public static void setListener(View view, OnViewDetachedFromWindow detached) &#123; setListener(view, detached, null);&#125;@BindingAdapter(&#123;"android:onViewDetachedFromWindow", "android:onViewAttachedToWindow"&#125;)public static void setListener(View view, final OnViewDetachedFromWindow detach, final OnViewAttachedToWindow attach) &#123; if (VERSION.SDK_INT &gt;= VERSION_CODES.HONEYCOMB_MR1) &#123; final OnAttachStateChangeListener newListener; if (detach == null &amp;&amp; attach == null) &#123; newListener = null; &#125; else &#123; newListener = new OnAttachStateChangeListener() &#123; @Override public void onViewAttachedToWindow(View v) &#123; if (attach != null) &#123; attach.onViewAttachedToWindow(v); &#125; &#125; @Override public void onViewDetachedFromWindow(View v) &#123; if (detach != null) &#123; detach.onViewDetachedFromWindow(v); &#125; &#125; &#125;; &#125; final OnAttachStateChangeListener oldListener = ListenerUtil.trackListener(view, newListener, R.id.onAttachStateChangeListener); if (oldListener != null) &#123; view.removeOnAttachStateChangeListener(oldListener); &#125; if (newListener != null) &#123; view.addOnAttachStateChangeListener(newListener); &#125; &#125;&#125; ConvertersOject Conversions当从绑定表达式返回对象时，将从自动、重命名和自定义setter中选择一个setter，对象会被转换成所选setter的参数类型。 这是使用ObservableMaps来储存数据的方便之处，例如： 1234&lt;TextView android:text=`@&#123;userMap["lastName"]&#125;` android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; userMap返回一个Object，该对象会被自动转换为在setter setText(CharSequence)中找到的参数类型。当参数类型有可能产生混淆时，开发人员需要在表达式中转换。 自定义Conversions一些特定类型之间的转换应该是自动地，例如，设置背景时： 1234&lt;View android:background="@&#123;isError ? @color/red : @color/white&#125;" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; 这里，背景采用一个drawable，但颜色是一个Integer。期望的是Drawable，但返回的是Integer，这个int应该被转换成一个ColorDrawable。使用带有BindingCoversion注解的静态方法来完成此转换过程： 1234@BindingConversionpublic static ColorDrawable convertColorToDrawable(int color) &#123; return new ColorDrawable(color);&#125; 注意，转换仅仅发生在setter级别，因此不允许这样的混合类型： 1234&lt;View android:background="@&#123;isError ? @drawable/error : @color/white&#125;" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; Android Studio Support for Data BindingAndroid Studio 支持许多用于数据绑定代码的代码编辑功能。例如，它支持数据绑定表达式的以下功能： 语法高亮 标记表达式的语法错误 XML代码自动完成 参考，包含navigation和quick documentation。注意：数组和泛型（如Observable类）可能会在没有错误时提示错误。 “预览”窗格显式数据绑定表达式的默认值（如果提供）。在一下实例中，从布局xml文件中选择一个元素，“预览”窗格将在TextView中显示PLACEHOLDER默认文本值。 123&lt;TextView ... android:text="@&#123;user.firstName, defalut=PLACEHOLDER&#125;" /&gt; 如果您需要在项目的设计阶段显示默认值，还可以使用工具属性而不是默认表达式值。在文档Desgintime Layout Attributes中有具体叙述。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Scroller]]></title>
      <url>%2F2017%2F03%2F24%2FScoller.html</url>
      <content type="text"><![CDATA[Q:mScrollX和mScrollY是什么东西？A:它们是在scrollTo方法中定义的变量，表示View在X、Y方向的滚动距离。其中，ScrollBy会调用ScrollTo，相当于在mScrollX和mScrollY上加上其参数所指定的偏移量。 Q:传入一个正数会向负轴移动？A:利用这两个方法发生移动的是View的内容。在Invalidate方法中，重新计算绘制大小时是减去mScrollX/Y的，所以是负方向移动。 Q:Scroll是怎么让view滚动起来的？A: Q:实现View的滑动？A：(1)使用layout方法;(2)修改View的LayoutParams;(3)采用动画向View施加移动效果;(4)使用Scroll。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[线程协作机制]]></title>
      <url>%2F2017%2F03%2F23%2F%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C%E6%9C%BA%E5%88%B6.html</url>
      <content type="text"><![CDATA[摘要了解了wait/notify基本协作方法的使用及其原理，并且利用它们来演示了如何实现各种常见线程间协作情景的基本原理线程之间协作的关键是要弄清共享变量和条件是什么。提到了java中专门为处理这些场景开发的阻塞队列、同步工具类以及Executors框架，在实际开发中，应该尽可能使用这些现成的类，而非重新发明轮子。后续再详细解析这些工具。 之前分析了多线程之间竞争访问同一个资源的问题以及一个解决方案synchronized。但是，多线程除了竞争外，还经常需要协作，下面先来提一些问题。 都有哪些场景需要协作？wait/notify是什么？如何使用？实现原理是什么？协作的核心是什么？如何实现各种典型的协作场景？ 协作的场景生产者/消费者协作模式：这是一种比较常见的协作模式，生产者与消费者线程通过共享队列进行协作，由生产者将数据或任务放到队列上，消费者从队列中取出项目进行处理。如果队列有限，那么在队列满了的时候，生产者需要等待；而在队列为空的时候，消费者也需要等待。同时开始：要求多个线程能同时开始任务。等待结束：主线程将任务分解为多个子任务，为每个子任务创建一个线程，主线程在继续执行其他任务之前需要等待每个子任务执行完毕。这也是一种非常常见的主从协作模式。异步结果：在主从协作模式中，主线程手工创建子线程的写法往往比较麻烦，另一种常见的做法是将子线程的管理封装为异步调用，异步调用会马上返回，但返回的不是最终的结果，而是一个一般称为Promise或Future的对象，通过它可以在随后获取到最终的结果。集合点：所有从不同的出发点出发的线程，在完成各自的任务之后到达一个集合点，所有线程到齐之后进行下一项活动。在探讨这些常见情景的实现之前，先了解一下协作的基本方法wait/notify。 wait/notify我们知道，Java中所有类的根类是Object，Java在Object类中(而非Thread类中)，定义了一些线程协作的基本方法，使得每一个对象都可以调用这些方法，这些方法有两类，一类是wait，一类是notify。主要有两个wait方法： 12public final void wait() throws InternalExceptionpublic final native void wait(long timeout) throws InternalException 下面的方法带一个时间参数，单位毫秒，表示最多等待这么长的时间，参数为0表示无限期等待。上面那个不带时间参数的wait其实就是调用了wait(0)。在等待期间都可以被中断，如果中断就会抛出InterruptedException，之后会介绍中断和中断处理。 wait实际上做了什么？它在等待什么？之前说过每个对象都有一个锁和一个等待队列，一个线程在进入synchronized代码块后，会尝试获取锁，如果获取不到的话就会把当前线程加入等待队列之中，不过，其实每个对象还有另一个等待队列，表示条件队列，该队列用于线程间的协作。当一个线程t调用wait方法时，就会把该线程t放到条件队列中并阻塞，表示当前线程t不能继续执行了，它需要等待一个条件，这个条件它自己无法改变，必须要其他线程来改变。要改变这个条件，需要其他线程来调用这个对象的notify方法。12public final native void notify()public final native void notifyAll() notify做的事情就是从条件队列中选择一个线程，将其从队列中移除并唤醒，让它继续执行。notify和notifyAll的区别就是，后者会将条件队列中所有的线程全部唤醒。 来看一个简单的例子，一个线程启动后，在执行一项操作前，需要等待主线程的指令，收到指令后才能执行： 1234567891011121314151617181920212223242526272829public class WaitThread extends Thread &#123; private volatile boolean fire = false; @Override public void run() &#123; try &#123; synchronized (this) &#123; while (!fire) &#123; wait(); &#125; &#125; System.out.println("fired"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public synchronized void fire() &#123; this.fire = true; notify(); &#125; public static void main(String[] args) throws InterruptedException &#123; WaitThread waitThread = new WaitThread(); waitThread.start(); Thread.sleep(1000); System.out.println("main fire"); waitThread.fire(); &#125;&#125; 代码中有两条线程，一个是主线程，一个是WaitThread，协作的条件变量是fire，waitThread等待该变量变成true，在该变量不为ture时调用wait阻塞，主线程设置该变量并调用nofity唤醒waitThread。由于两个线程都要访问修改协作变量fire，容易出现竞态条件，所以相关代码都需要用synchronized保护。实际上，wait/notify方法只能在synchronized代码块内被调用，如果调用wait/notify方法时，当前线程没有持有对象锁，会抛出java.lang.IllegalMonitorStateException异常。 细心的人会发现，如果wait被synchronized保护，那么另一个线程怎么可能调用同样被synchronized保护的notify方法呢？这里我们需要进一步理解wait的内部过程，虽然是在synchronized方法内，但是调用wait时，线程会释放对象锁，wait的具体过程是：1.把当前线程放入条件等待队列，释放对象锁，阻塞等待，线程状态变为WAITING或TIMED_WAITING；2.在被其他线程调用notify系列方法或超过设置的等待时间时，要重新竞争对象锁如果能获得锁，线程状态会变为RUNNABLE，并从wait调用中返回；否则，该线程加入对象锁的等待队列，线程状态变为BLOCKED，只有在获得锁后才从wait调用中返回。 线程从wait返回后，不代表其他等待条件一定成立，它需要重新检查其他等待条件，一般的调用模式是： 1234synchronized (obj) &#123; while (条件不成立) obj.wait(); // 条件满足后执行的操作&#125; 调用notify会把在条件队列中等待的线程唤醒并从队列中移除，但它不会释放对象锁，也就是说，只有在包含notify的synchronized代码块执行完后，等待的线程才会从wait调用中返回。 下面来总结一下wait/notify方法，一个线程调用对象的wait方法，会将该线程加入该对象的条件队列中并阻塞线程，而其他线程调用该对象的notify方法才能将该线程从对象的条件队列中移除并唤醒，所以要搞清楚wait等待的究竟是什么，notify唤醒的究竟是什么。使用wait/notify进行线程协作实际上是围绕共享变量进行协作的，这个共享条件变量是要求具体代码自己来维护的，上面的一般调用模式显示了这种机制的模式，当条件不成立时进入wait，另一个线程修改了条件后调用notify，唤醒调用wait的线程重新检查条件变量。我们在设计多线程协作时，需要想清楚协作的共享变量和条件是什么，这是协作的核心。接下来就来通过wait/notify解决最开始提到的那几种协作场景。 生产者/消费者模式根据上面提到的原则，在生产者/消费者模式种，协作共享变量是队列，条件是生产者在队列满了时wait，而消费者在队列空了的时候wait。下面是一个简单地生产/消费者模式的演示代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.Queue;import java.util.ArrayDeque;public class ProducerConsumerDemo &#123; static class MyBlockingQueue&lt;E&gt; &#123; private Queue&lt;E&gt; queue = null; private int limit; public MyBlockingQueue(int limit) &#123; this.limit = limit; queue = new ArrayDeque&lt;&gt;(limit); &#125; public synchronized void put(E e) throws InterruptedException &#123; while (queue.size() == limit) &#123; wait(); &#125; queue.add(e); notifyAll(); &#125; public synchronized E take() throws InterruptedException &#123; while (queue.isEmpty()) &#123; wait(); &#125; E e = queue.poll(); notifyAll(); return e; &#125; &#125; static class Producer extends Thread &#123; MyBlockingQueue&lt;String&gt; queue; public Producer(MyBlockingQueue&lt;String&gt; queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; int num = 0; try &#123; while (true) &#123; String task = String.valueOf(num); queue.put(task); System.out.println("生产任务 "+task); num++; Thread.sleep((long) (Math.random()*100)); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; static class Consumer extends Thread &#123; MyBlockingQueue&lt;String&gt; queue; public Consumer(MyBlockingQueue&lt;String&gt; queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; try&#123; while (true) &#123; String task = queue.take(); System.out.println("处理任务 "+ task); Thread.sleep((long) (Math.random()*100)); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; MyBlockingQueue&lt;String&gt; queue = new MyBlockingQueue&lt;&gt;(10); new Producer(queue).start(); new Consumer(queue).start(); &#125;&#125; 运行该程序会看到生产者和消费者线程的输出交替出现。其中，MyBlockingQueue是一个长度有限的队列，长度通过构造方法的参数进行传递，有两个方法put和take。生产者调用put往队列中添加数据，满了就wait，并且只要放上一个数据就调用notifyAll通知潜在的消费者。tak是给消费者用的，道理是一样的。我们看到，put和wait都调用了wait，但调用它们的线程是不一样的，等待的条件也是不一样的，put等待的是队列不满，take等待的是队列不空，但是它们都会加入相同的条件队列，也就是MyBlockingQueue对象内部维护的那个条件队列。由于条件不同，但又使用的是相同的等待队列，所以要调用notifyAll而不是notify，因为notify只能唤醒一个线程，而如果唤醒的是同类线程就起不到协调的作用。 只能有一个条件队列，这是wait/notify机制的局限性，这使得对于等待条件的分析变得复杂，后续会学习显式的锁和条件，它可以解决该问题。 我们实现的这个MyBlockingQueue主要是用于演示，Java提供了专门的阻塞队列实现，包括：接口BlockingQueue和BlockingDeque基于数组的实现类ArrayBlockingQueue基于链表的实现类LinkedBlockingQueue和LinkedBlockingDeque基于堆的实现类PriorityBlockingQueue在实际的工程中，应该考虑使用这些成熟的类，后续会详细学习它们。同时开始这个场景类似于运动员比赛，在听到比赛枪响后同时开始，下面我们来模拟这个过程，场景中有一个主线程和N个子线程，每个子线程模拟一个运动员，主线程模拟裁判，它们协作的共享变量是一个开始信号。我们用一个FireFlag类来表示这个协作对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class synchronizedStart &#123; static class FireFlag &#123; private volatile boolean fired = false; public synchronized void waitForFire() throws InterruptedException &#123; while (!fired) &#123; wait(); &#125; &#125; public synchronized void fire() &#123; this.fired = true; notifyAll(); &#125; &#125; static class Racer extends Thread &#123; FireFlag fireFlag; public Racer(FireFlag fireFlag) &#123; this.fireFlag = fireFlag; &#125; @Override public void run() &#123; try &#123; this.fireFlag.waitForFire(); System.out.println(Thread.currentThread().getName() + "开始跑步"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; int num = 10; FireFlag fireFlag = new FireFlag(); Thread[] racers = new Thread[num]; for (int i = 0; i &lt; num; i++) &#123; racers[i] = new Racer(fireFlag); racers[i].start(); &#125; Thread.sleep(1000); fireFlag.fire(); &#125;&#125; 可以看到我们用10个Racer线程模拟了10个运动员，每个Racer线程都持有一个fireFlag，它是一个共享变量，当主线程调用fire方法后，这个阻滞条件被打破，FireFlag调用notifyAll唤醒所有等待的线程，线程检查共享变量发现满足条件，于是所有线程开始同时执行，注意这里的同时也是相对而言的。 等待结束先来回头看看join是怎么回事，实际上join就是调用了wait。其主要代码为： 123while(isAlive()) &#123;wait(0);&#125; 只要线程存活，join就会一直等待，当线程结束运行时，Java系统会调用notifyAll来通知。使用协作对象 使用join有时比较麻烦，需要主线程逐一等待每个子线程。这里有一种新的写法，主线程与各个子线程协作的共享变量是一个数，这个数表示未完成的线程个数，初始值为子线程个数，主线程等待该变量为0，而每个子线程结束后就将这个协作值减一，当减到0时调用notifyAll，我们用MyLatch来表示这个协作对象，示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class WaitingForComplete &#123; public static class MyLatch &#123; private int count; public MyLatch(int count) &#123; this.count = count; &#125; public synchronized void await() throws InterruptedException &#123; while (count &gt; 0) &#123; wait(); &#125; &#125; public synchronized void countDown() &#123; count--; if (count&lt;=0) &#123; notifyAll(); &#125; &#125; &#125; static class Worker extends Thread &#123; MyLatch latch; public Worker(MyLatch latch) &#123; this.latch = latch; &#125; @Override public void run() &#123; try &#123; Thread.sleep((long) (Math.random()*1000)); System.out.println(this.getName()+"完成工作。"); this.latch.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; int workerNum = 100; MyLatch latch = new MyLatch(workerNum); Worker[] workers = new Worker[workerNum]; for (int i = 0; i &lt; workerNum; i++) &#123; workers[i] = new Worker(latch); workers[i].start(); &#125; latch.await(); System.out.println("所有worker均已经执行完毕"); &#125;&#125; 这里，MyLatch的构造方法参数应该为子线程个数，主线程应该调用MyLatch的await()方法，而子线程应该在执行完后调用countDown()方法。MyLatch是一个用于同步协作的工具类，我们的代码演示了其基本原理，Java中有一个专门的同步类CountDownLatch，在实际开发中应该使用它，后续还会有介绍。MyLatch的功能也是比较通用的，在上面的”同时开始“场景中，如果将它的初始值设为1，子线程调用await()，主线程调用countDown()，也可以实现同样的效果。 异步结果在主从模式种，手工创建线程往往比较麻烦，一种常见的模式是异步调用，异步调用返回一个一般称为Promise或Future的对象，通过它可以获得最终的结果。在Java中，表示子任务的接口是Callable，声明为： 123public interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; 位于java.util.concurrent.Callable包中。为了表示异步调用的结果，我们定义一个接口MyFuture，如下所示： 123public interface MyFuture&lt;V&gt; &#123; V get() throws Exception;&#125; 该方法返回最终的执行结果，如果计算还没完成就会阻塞直到完成，如果调用过程中发生异常，则get方法会抛出过程中遇到的异常。 为了方便主线程调用子任务，我们定义一个类MyExecutor，其中定义一个public方法execute，表示执行子任务并返回异步结果，利用这个方法，主线程就不需要创建并管理子线程了，而且可以很方便地获取异步调用的结果。 下面是一个实例： 123456789101112131415161718public static void main(String[] args) &#123; MyExecutor executor = new MyExecutor(); Callable&lt;Integer&gt; subTask = new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; int millis = (int) (Math.random() * 1000); Thread.sleep(millis); return millis; &#125; &#125;; MyExecutor.MyFuture&lt;Integer&gt; future = executor.execute(subTask); try &#123; Integer result = future.get(); System.out.println(result); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 要执行异步任务，只需构造一个Callable实例，并且调用MyExecutor对象的execute方法将它传入就行了。execute会返回一个Future对象，用于稍后获取结果。下面我们来看一下MyExecutor的execute方法是如何实现的： 123456789101112131415161718192021222324public &lt;V&gt; MyFuture&lt;V&gt; execute(final Callable&lt;V&gt; task) &#123; final Object lock = new Object(); final ExecuteThread&lt;V&gt; thread = new ExecuteThread&lt;&gt;(task,lock); thread.start(); MyFuture&lt;V&gt; future = new MyFuture&lt;V&gt;() &#123; @Override public V get() throws Exception &#123; synchronized (lock) &#123; while (!thread.isDone()) &#123; try&#123; lock.wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; if (thread.getException() != null) &#123; throw thread.getException(); &#125; return thread.getResult(); &#125; &#125; &#125;; return future;&#125; 首先是创建一个Object实例用于使用条件队列，然后创建了一个ExecuteThread对象： 123456789101112131415161718192021222324252627282930313233343536373839public class ExecuteThread&lt;V&gt; extends Thread &#123; private V result = null; private Exception exception = null; private boolean isDone = false; private Callable&lt;V&gt; task; private Object lock; public ExecuteThread(Callable&lt;V&gt; task, Object lock) &#123; this.task = task; this.lock = lock; &#125; @Override public void run() &#123; try&#123; result = task.call(); &#125; catch (Exception e) &#123; exception = e; &#125; finally &#123; synchronized (lock) &#123; isDone = true; lock.notifyAll(); &#125; &#125; &#125; public V getResult() &#123; return this.result; &#125; public boolean isDone() &#123; return this.isDone; &#125; public Exception getException() &#123; return this.exception; &#125; &#125;&#125; ExecuteThread用于实际执行Callable。在它的内部封装了Callable执行的相关结构，如Callable本身，结果result，结束标志isDone同时也是协作变量，执行过程中可能产生的Exception，同时还会持有一个用于协作的Obj对象。run方法中具体执行Callable。值得注意的是执行最后会notifyAll唤醒外部等待结果的线程。我们再回到execute方法，在开启ExecuteThread.start()后，这个方法将会wait来等待返回结果。其实这就是一个典型的wait/notify协作情景。以上的MyExecutor和MyFuture主要用于演示基本原理，实际上Java包中已经包含了一套完整的Executors框架，相关的部分接口有：表示异步结果的接口Future和实现类FutureTask用于执行异步任务的接口Executor、以及有更多功能的子接口ExecutorService用于创建Executor和ExecutorService的工厂方法类Executors后续还会详细介绍这套框架。 集合点这个场景中所有的线程先是分头行动，然后各自到达一个集合点，在集合点需要集齐所有的线程，交换数据，然后再进行下一步行动。我们可以考虑协作变量是一个数，这个数表示未到集合点的线程个数，初始值为子线程个数，每个到达集合点的线程都将这个值减一。如果这个值不为0，说明还有线程未到达，继续等待；如果为0，则表示当前线程自己是最后一个到达的，调用notifyAll唤醒所有线程。我们利用AssemblePoint类表示这个协作对象，示例代码如下： 1234567891011121314151617181920public class AssemblePoint &#123; private int n; public AssemblePoint(int n) &#123; this.n = n; &#125; public synchronized void await() throws InterruptedException &#123; if (n &gt; 0) &#123; n--; if (n == 0) &#123; notifyAll(); &#125; else &#123; while ( n != 0) &#123; wait(); &#125; &#125; &#125; &#125;&#125; 有多个子线程，先各自独立运行，然后使用该协作对象到达集合点进行同步，示例代码如下： 12345678910111213141516171819202122232425262728293031public class AssemblePointDemo &#123; static class Tourist extends Thread &#123; AssemblePoint ap; public Tourist(AssemblePoint ap) &#123; this.ap = ap; &#125; @Override public void run() &#123; try &#123; Thread.sleep((long) (Math.random() * 1000)); ap.await(); System.out.println("子线程到达"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; int num = 10; Tourist[] tourists = new Tourist[num]; AssemblePoint ap = new AssemblePoint(num); for (int i = 0; i &lt; num; i++) &#123; tourists[i] = new Tourist(ap); tourists[i].start(); &#125; &#125;&#125; 代码很清楚就不详细分析了。这里实现的AssemblePoint主要是用于演示基本原理，Java中有一个专门的同步工具类CyclicBarrier可以代替它，关于该类，后续在介绍。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[synchronized锁]]></title>
      <url>%2F2017%2F03%2F23%2Fsychronized%E9%94%81.html</url>
      <content type="text"><![CDATA[之前提到了多线程共享内存的两个问题，一个是竞态条件，一个是内存可见性，解决这两个问题的方案之一是使用synchronized关键字，接下来就来详细讨论它。synchronized关键字可以用于修饰类的实例方法、静态方法和代码块。 实例方法在之前的那个1000个线程并发对静态变量+1操作的例子中，最后得到的结果和期望结果不符合(这里去掉下面代码中的synchronized就可以看到)。当时提到了可以用synchronized关键字解决这个问题，下面就来看看如何解决： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class CounterThreadEx extends Thread &#123; private Counter counter; public CounterThreadEx(Counter counter) &#123; this.counter = counter; &#125; @Override public void run() &#123; try &#123; Thread.sleep((long) (Math.random()*10)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; counter.incr(); &#125; public static void main(String[] args) throws InterruptedException &#123; int num = 1000; Counter counter = new Counter(); Thread[] threads = new Thread[num]; for (int i = 0; i &lt; num; i++) &#123; threads[i] = new CounterThreadEx(counter); threads[i].start(); &#125; for (int i = 0; i &lt; num; i++) &#123; threads[i].join(); &#125; System.out.println(counter.getCount()); &#125; public static class Counter&#123; private int count; public synchronized void incr() &#123; count++; &#125; public synchronized int getCount()&#123; return count; &#125; &#125;&#125; 与上个例子类似，创建了1000个线程，传递了相同的counter对象，每个线程的主要操作就是调用Counter的incr方法，main线程等待子线程全部退出后输出counter的值，这次的结果就完全符合期望结果。这里的synchronized看上去使得同一时间只能有一个线程执行实例方法，但这个理解是不准确的。多个线程可以同时执行同一个synchronized方法，只要它们访问的对象是不同的。比如： 123456Counter counter1 = new Counter();Counter counter2 = new Counter();Thread t1 = new CounterThread(counter1);Thread t2 = new CounterThread(counter2);t1.start();t2.start(); 这里，t1和t2两个线程是可以同时执行Counter的incr方法的，因为它们访问的是不同的Counter对象。所以，synchronized实例方法实际保护的是同一个对象的方法调用，确保同一时间只能有一个线程执行。具体说来就是synchronized实例方法保护的是当前实例对象，即this，this对象有一个锁和一个等待队列，锁只能被一个线程持有，其他试图获取同一锁的线程需要等待，执行synchronized实例方法的过程大致如下：1.线程尝试获取对象锁，如果能够获取锁，则开始执行下一步代码，否则加入等待队列，阻塞并等待唤醒；2.执行实例方法体的代码3.释放锁，如果等待队列上有等待的线程，从中取一个并唤醒，如果有多个等待的线程，唤醒哪一个是不一定的！不保证公平性。实际上sychronized的执行过程远比这个步骤要复杂得多，而且java虚拟机采用了多种优化方式以提高性能，但从概念上我们可以这样简单地理解。当线程无法获取锁时，它会加入等待队列，线程的状态会变为BLOCKED。 所以，synchronized保护的是对象而非代码，只要访问的是同一个对象的synchronized方法，即使是不同的代码，也会被同步的顺序访问，比如对于Counter中的两个方法incr()和getCounter()，对于同一个对象，一个线程执行incr，一个执行getCounter，它们也是不能同时执行的，会被synchronized以同步的顺序执行。此外需要说明的是，synchronized方法不防止非synchronized方法被同时执行。所以一般在保护变量时，需要在所有访问该变量的方法上加上synchronized。 静态方法synchronized同样可以用在静态方法中，比如：1234567891011public class StaticCounter &#123; private static int count = 0; public static synchronized void incr() &#123; count++; &#125; public static synchronized int getCount() &#123; return count; &#125;&#125; 对于实例方法，synchronized保护的是当前实例对象this，对静态方法，保护的是类对象。这里是StaticCounter.class。实际上，每个对象队友一个锁和一个等待队列，类对象也不例外。synchronized静态方法和synchronized实例方法保护的是不同的对象，不同的两个线程，可以同时地一个执行synchronized静态方法，另一个执行synchronized实例方法。代码块 除了用于修饰方法外，synchronized还可以用于包装代码块，比如对于前面的Counter类，等价的代码可以为： 12345678910111213public class Counter &#123; private int count; public void incr() &#123; synchronized (this) &#123; count++; &#125; &#125; public int getCount() &#123; synchronized (this) &#123; return count; &#125; &#125;&#125; 而对于StaticCounter类，等价代码为： 12345678910111213public class StaticCounter&#123; private static int count = 0; public static void incr() &#123; synchronized (StaticCounter.class) &#123; count++; &#125; &#125; public static int getCount() &#123; synchronized (StaticCounter.class) &#123; return count; &#125; &#125;&#125; synchronized同步的对象可以是任意对象，任何一个对象都具有锁和等待队列，或者说，任何对象都可以作为锁对象。比如说，Counter的等价代码还可以为: 123456789101112131415public class Counter&#123; private int count; private Object lock = new Object(); public void incr() &#123; synchronized (lock) &#123; count++; &#125; &#125; public int getCount() &#123; synchronized (lock) &#123; return count; &#125; &#125;&#125; 理解Synchronized接下来我们再从下面几个角度进一步理解一下synchronized:可重入性内存可见性死锁 可重入性synchronized有一个重要的特征，它是可重入的，也就是说，对于同一个执行线程，它在获得了锁之后，调用其他需要同样锁的代码时，可以直接调用。这是一个非常自然的特性，之所以强调，是因为并不是所有的锁都是可重入的。可重入是通过记录锁的持有线程和持有数量来实现的，当调用被synchronized保护的代码时，检查对象是否已被锁，如果是，在检查是否被当前线程锁定，如果是，增加持有数量，如果不是被当前线程锁定，才加入等待对象，当释放锁时，减少持有数量，当数量变为0时才释放整个锁。 内存可见性对于复杂一些的操作，synchronized可以实现原子操作，避免出现竞态条件，但对于明显的本来就是原子操作的方法，也需要加synchronized吗？比如说，对于开关类Switcher，它只有一个boolean变量on和对应的setter/getter方法。此时，当多个线程访问同一个Switcher对象时，的确不存在竞态条件的问题，但是仍然存在内存可见性的问题，加上synchronized就可以解决。所以synchronized除了保证原子操作之外，还有一个作用，就是保证内存可见性，在释放锁时，所有写入都会写回内存，而获得锁后，都会从内存中读数据。不过如果只是为了保证内存可见性，synchronized的成本有点高，有个更轻量级的方法就是给变量加修饰符volatile。加了volatile之后，Java会在操作对应变量时加入特殊的指令，保证读写到内存的最新值而非缓存。 死锁使用synchronized或其他锁的时候，要注意死锁。所谓死锁，比如，有a、b两个线程，a持有A锁，在等待B锁，b持有B锁，在等待A锁，a、b陷入了相互等待，最后一等就是一辈子。 要避免死锁，首先应该尽量避免在持有一个锁的同时去申请另一个锁，如果确实需要多个锁，所有代码都应该按照相同的顺序去申请。借助一些工具也可以发现运行中的死锁，比如，java自带的jstack命令会报告发现的死锁。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Retrofit源码分析]]></title>
      <url>%2F2017%2F03%2F23%2FRetrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
      <content type="text"><![CDATA[Retrofit源码分析 Retrofit的亮点 先来看一个最基本的Retrofit+Gson的用法： 1234567891011121314151617// https://raw.githubusercontent.com/xiaoniaojun/xiaoniaojun.github.io/master/test.json Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://raw.githubusercontent.com/") .addConverterFactory(GsonConverterFactory.create()) .build(); GitHub gitHub = retrofit.create(GitHub.class); Call&lt;User&gt; xiaoniaojun = gitHub.results("xiaoniaojun", "test.json"); xiaoniaojun.enqueue(new Callback&lt;User&gt;() &#123; @Override public void onResponse(Call&lt;User&gt; call, Response&lt;User&gt; response) &#123; User responseUser = response.body(); &#125; @Override public void onFailure(Call&lt;User&gt; call, Throwable t) &#123; t.printStackTrace(); &#125; Retrofit让我们可以使用注解接口方法的方式来实现解析Url，构造一个可执行对象，这个可执行对象可以直接调用网络请求的操作并对返回结果进行同步/异步处理。其中最亮的地方是，这个可执行对象既可以是一个在java8或者Android平台可以直接调用的Call对象，也可以是一个Observer对象。并且，对于返回的response，可以加入Converter来将其内容以特定的方式解析，比如请求json对象，可以使用GsonConverter来将response body直接解析为具体的对象，又或者是可以自定义如何包装request。 public Retrofit build()方法： 12345678910111213141516171819202122232425262728293031323334353637/** * 根据设置的配置值来创建&#123;@link Retrofit&#125;实例 * &lt;p&gt; * 注意: 如果&#123;@link #client&#125;和&#123;@link #callFactory&#125; 都没有被调用，就默认生成和使用&#123;@link * OkHttpClient&#125;。 */ public Retrofit build() &#123; // 如果不提供baseUrl，就会抛出异常。 if (baseUrl == null) &#123; throw new IllegalStateException("Base URL required."); &#125; // 这个callFactroy是一个空的值，所以这句代码没有任何作用，估计是遗留代码。 okhttp3.Call.Factory callFactory = this.callFactory; // 默认使用OkHttpClient来创建CallFactory // Factory是一个接口，内部只有一个newCall(Request r)方法。 if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; // 这里的CallbackExecutor，是封装了主线程Looper的Handler， // 所以这个默认的CallbackExecutor会将回调在主线程中执行。 Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; // 防御性拷贝adapters，并添加默认Call adapter。 // 1.解析defaultCallAdapterFactory List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); // Make a defensive copy of the converters. List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories); return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor, validateEagerly); &#125; 这个装配的过程其实就是在为Retrofit配置几个关键组件：我们先列出它们，再来一个一个分析。baseUrl: 基url地址，在它上面构建完整的url请求，这个没什么好解释的。callFactory:call工厂，call是干嘛的？是我们最终用来执行http请求和接受的。下面我们再来剖析这个东西。callbackExecutor：回调执行者，这个是用来执行回调的。为什么要封装它？因为它是用来控制执行线程的。adapterFactories：适配器工厂，适配的什么？converterFactories转换器工厂，转换的什么？ CallFactory首先，这个callFactory是由以下代码生成的： 1callFactory = new OkHttpClient(); 这条语句创建的。我们知道，Retrofit的网络请求是基于OkHttp实现的，那这里很明显是实际执行网络操作的请求的方法。我们跟进去OkHttpClient类， 1public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory 由于这里OkHttpClient行使的是Factory的职责，我们主要看OkHttpClient实现的这个接口的方法。Call.Factory只有一个方法： 123@Override public Call newCall(Request request) &#123; return new RealCall(this, request, false /* for web socket */); &#125; 传递进一个request对象，把它转换成可执行的Call对象。 到这里，callFactory就具备了它的职责，根据request来构建Call。 现在我们来审查一下这个OkHttpClient对象。它具备的能力有：执行各种网络操作、将这些操作构建成Call对象。 这里我们再谈谈Call接口。 request返回初始化这个call的原生request对象，其余都是控制请求执行的指令。 然后，这个RealCall是Call接口的实现类，它实际处理对OkHttp的调用。由于我们这里只分析Retrofit，所以这个部分我们就省略了。现在只需要知道，通过CallFactory，我们可以构建Call对象，而这个Call就是在执行网络请求。 CallbackExecutor同样来看一下生成CallbackExecutor实例的方法， 1callbackExecutor = platform.defaultCallbackExecutor(); 首先这个CallbackExecutor是一个Executor类型对象。Executor是java并发包中的接口，只有一个execute方法，就是用来执行Runnable的。这个是用来解耦的。 Platform工具类提供了多平台支持。它在初始化的时候调用其findPlatform方法查看调用环境。在Andoird平台上，提供了MainThreadExecutor用来在主线程中执行代码。那么这个CallbackExecutor是干什么的呢？看名字就知道，是用于执行回调的。网络请求返回response，接收处理的结果很多时候是需要在主线程中更新ui的。 123@Override public Executor defaultCallbackExecutor() &#123; return new MainThreadExecutor(); &#125; 所以最终在Andoird平台上，默认的CallbackExecutor是这个MainThreadExecutor，也就是说，回调默认是在主线程中执行的。 adapterFactory12List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); 接下来又是一个平台相关的CallAdapterFactory。在Android平台中，默认的defaultCallAdapterFactory是ExecutorCallAdapterFactory。 123@Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123; return new ExecutorCallAdapterFactory(callbackExecutor); &#125; 这个CallAdapter到底适配的是什么？答案就是，我们在定义那个创建链接的接口时，不是声明了一个Call吗，这个Adapter就是将我们的CallFactory产生的Call与CallbackExecutor融合起来，创建一个生产Call对象的工厂。注意CallAdapter接口里面的那个adapter方法，就是做这件事的。 1. CallAdapterFactory12345678CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123; // 如果callbackExecutor不为空，则调用ExecutorCallAdapterFactory(callbackExecutor) if (callbackExecutor != null) &#123; return new ExecutorCallAdapterFactory(callbackExecutor); &#125; // 否则返回默认的CallAdapterFactory return DefaultCallAdapterFactory.INSTANCE;&#125; 123456789101112131415161718192021222324252627final class ExecutorCallAdapterFactory extends CallAdapter.Factory &#123; final Executor callbackExecutor;# ExecutorCallAdapterFactory(Executor callbackExecutor) &#123; this.callbackExecutor = callbackExecutor; &#125; // 这个方法传入的参数有 // returnType，返回类型 // annotations，注解 // retrofit // 从这些参数我们可以推断，这个CallAdapter是将之前所有的请求设置封装到Call中的关键 @Override public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; if (getRawType(returnType) != Call.class) &#123; return null; &#125; final Type responseType = Utils.getCallResponseType(returnType); return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); &#125; &#125;; &#125; ##Retrofit构造函数 12345678910Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl, List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; adapterFactories, Executor callbackExecutor, boolean validateEagerly) &#123; this.callFactory = callFactory; this.baseUrl = baseUrl; this.converterFactories = unmodifiableList(converterFactories); // Defensive copy at call site. this.adapterFactories = unmodifiableList(adapterFactories); // Defensive copy at call site. this.callbackExecutor = callbackExecutor; this.validateEagerly = validateEagerly; &#125; 在构造方法中，将工厂中设置的所有配置变量进行初始化赋值。 1234567891011121314151617181920212223242526public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; // 首先检查传入的类是否为一个接口，以及，是否包含了其他接口(不合格) Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; 123456789101112class Plathform &#123;private static final Platform PLATFORM = findPlatform();// getterstatic Platform get();// 这个方法查看当前代码运行平台（java8 Android 等等）private static Platform findPlatform();&#125;// 默认回调Executor为nullExecutor defaultCallbackExecutor() &#123;return null&#125;;CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123; &#125; 动态代理的代码 12345678910111213141516171819202122return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 如果是Object声明的方法就直接调用。 if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; // 垃圾代码，已经弃用 if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; // 这里是在处理Retrofit注解 ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Retrofit2+Gson的基本用法]]></title>
      <url>%2F2017%2F03%2F13%2FRetrofit2-Gson%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.html</url>
      <content type="text"><![CDATA[Retrofit基本使用基本用法我们来实现一个最基本的请求Json结果的文件的Demo。 引入依赖首先新建一个工程，在app的build.gradle中加入以下依赖： 123compile 'com.squareup.retrofit2:retrofit:2.2.0'compile 'com.google.code.gson:gson:2.7'compile 'com.squareup.retrofit2:converter-gson:2.0.2' 第一行自然是引入retrofit2啦，由于我们需要解析Json文本，Retrofit为我们提供了一个很方便的工具Converter。我们在获取网络资源后，通常需要对其内容进行解析，这个步骤可以利用线程的解析库来实现，并且Retrofit为几个常见的解析库提供了相应了Converter类。Gson是一个常见的Json解析库，Retrofit为它提供了Converter。第二行和第三行就是分别引入Gson和GsonConverterFactory的，稍后用到这个Converter的时候会再提一下的。 然后，我们随便上传一个Json文件在GitHub上，这里大家就自己弄啦。 我传了一个Json文件上去，地址为：https://raw.githubusercontent.com/xiaoniaojun/xiaoniaojun.github.io/master/test.json 12345&#123;age: 22,name: "Bird",phoneNumber: "13550626331"&#125; 记下这个地址，后面的构建会用到。注意：这个地址可能随时失效，请大家自己动手上传。 构建请求接口12345// https://raw.githubusercontent.com/xiaoniaojun/xiaoniaojun.github.io/master/test.jsonpublic interface GitHub &#123; @GET("&#123;userId&#125;/&#123;userId&#125;.github.io/master/&#123;fileName&#125;") Call&lt;User&gt; results(@Path("userId") String userId, @Path("fileName") String fileName);&#125; 大家可以把目标链接用注释写在上面，方便写代码的时候对照。 @Get注解中编写请求链接的基本结构，其中用{}括起来的，表示替换块(replacation block)，可以在注解的方法中，通过@Path标注的参数，进行替换。这里有两点需要注意，替换块中的字符串需要和@Path参数的字符串相同才能被识别。其次，Call，这个T表示response返回的类型。 这个接口实现的请求方法，会在之后被用来构造Call对象，而这个Call对象就是封装好的可调用对象，它是后面实际执行请求所需要的关键对象。我们可以使用call进行异步或同步调用。最后，我们会将这一系列步骤串起来总结。 为json定义BeanCall中的泛型类型为User，它是我们自定义的Bean。所谓Bean，我的理解就是一个包含Json对象所有字段的数据模型类，是一个纯java类。这里，我们简单地定义一下这个User Bean。 1234567891011public class User &#123; private String name; private int age; private String phoneNumber; public User(String name, int age, String phoneNumber) &#123; this.name = name; this.age = age; this.phoneNumber = phoneNumber; &#125;&#125; 代码很简单，就是包含了Json中出现的所有字段。 构建GitHub实例我们的目的是，最终实现网络请求，刚刚说到，请求的必须品是Call实例，而Call实例是我们定义的接口方法results()返回的。所以，我们需要来构建接口类型GitHub的实例。 我们需要利用retrofit提供的建造者方法一步一步地来构建出刚刚定义的接口类型的实例。 123456Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://raw.githubusercontent.com/") .addConverterFactory(GsonConverterFactory.create()) .build(); GitHub gitHub = retrofit.create(GitHub.class); 首先，我们通过建造者模式的方法Retrofit.Builder()，一步一步构造retrofit对象。 baseUrl()方法用于指定基地址； addConverterFactroy()方法用于设置Converter。刚刚我们已经谈过它了，它的作用就是，在response返回对象的时候，将response的body体利用Gson来解析； 最后以build()方法结束建造。 这样retrofit就配置完成了，接下来调用retrofit的create方法，传入GitHub.class对象，来生成GitHub的实例。 最后一步得到了GitHub实例，我们就可以调用在GitHub接口中定义的results方法来获取Call了。在results方法中，我们定义了构造请求链接的参数userId，以及FileName，这里我们传入”xiaoniaojun”和”test.json”，就可以得到构造好的Call对象。 此时，Call的大刀早已饥渴难耐，就等着执行网络请求了！ Retrofit为我们提供了两个方法，execute和enqueue，分别是同步/异步调用。同步调用就是直接调用，阻塞到返回，没什么好说的；异步调用需要传入一个Callback对象，用来获取返回值。 123456789101112Call&lt;User&gt; xiaoniaojun = gitHub.results("xiaoniaojun", "test.json"); xiaoniaojun.enqueue(new Callback&lt;User&gt;() &#123; @Override public void onResponse(Call&lt;User&gt; call, Response&lt;User&gt; response) &#123; User responseUser = response.body(); &#125; @Override public void onFailure(Call&lt;User&gt; call, Throwable t) &#123; t.printStackTrace(); &#125; &#125;); Callback接口实现了两个方法，onFailure表示请求失败，返回call对象和Throwable；onResponse表示请求成功，返回call对象和response，这个response就是返回结果啦。 这里要说一下这个call对象有什么用。在Retrofit中，Call只能被执行一次，所以想要再次执行，就必须重新建立一个Call，或者，使用从回调中获取的这个call，它是可以被调用的。 基本使用步骤总结这里我们来简单总结一下，使用Retrofit来进行一个完整网络请求的步骤： 建立构造请求对象的接口； 使用Retrofit.Builder()来build Retrofit实例。 利用这个Retrofit实例的create方法，传入接口.class，创建出接口的实例。 利用这个实例中，我们在接口内实现的那个方法，传入构造请求链接的相关变量，创建出Call对象。 利用这个Call对象进行同步或异步调用，异步调用最后都需要构造一个匿名内部类Callback，实现onResponse回调和onFailure对返回结果进行处理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Retrofit文档翻译]]></title>
      <url>%2F2017%2F03%2F13%2FRetrofit%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91.html</url>
      <content type="text"><![CDATA[引入Retrofit1compile 'com.squareup.retrofit2:retrofit:2.2.0' 设置Retrofit通过Retrofit类可以让你的API接口转换成callable对象。默认情况下，Retrofit的默认设置已经足够应对大多数情况，不过你也可以进行自定义。 CONVERTERS默认情况下，Retrofit只能将HTTP体反序列化成OkHttp的ResponseBody类型，并且，默认只能接受RequestBody类型的@Body。 Converters可以帮我们获得对其他类型的支持。一共有六个converter可以使用，它们可以帮你适配六大常见的库。 Gson: com.squareup.retrofit2:converter-gson Jackson: com.squareup.retrofit2:converter-jackson Moshi: com.squareup.retrofit2:converter-moshi Protobuf: com.squareup.retrofit2:converter-protobuf Wire: com.squareup.retrofit2:converter-wire Simple XML: com.squareup.retrofit2:converter-simplexml 下面是一个使用GsonConverterFactory类来生成GitHubService的实现接口的例子，使用Gson库来反实例化。 123456Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.github.com") .addConverterFactory(GsonConverterFactory.create()) .build(); GitHubService service = retrofit.create(GitHubService.class); 自定义Coverters建立自己的adapter时，扩展Converter.Factory类并且传递一个它的实例进去。 Retrofit Api接口方法上的注解以及注解参数表明如何处理一个request。 REQUEST方法每个方法必须有一个HTTP注解用以提供请求方法和相对URL。一共有五个内建注解：GET、POST、PUT、DELETE和HEAD。资源的相对URL在注解中被指定。 1@GET("users/list") 你也可以在URL中指定请求参数。 12345@GET("user/list?sort=desc")``` ##URL MANIPULATION可以在方法中，动态地使用替换块(replacement block)和关联参数来替换URL中的参数。一个替换块是一个由字母和数字组成的用&#123;&#125;围起来的字符串，与其相关联的参数必须使用`@Path`注解来声明，并且注解参数要和替换块字符串相同。 @GET(“group/{id}/users”)Call]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[怒怼Rxjava2(RxAndroid)(1)]]></title>
      <url>%2F2017%2F03%2F12%2F%E6%80%92%E6%80%BCRxjava2-RxAndroid-1.html</url>
      <content type="text"><![CDATA[怒怼RxJava 2(RxAndroid) - （1）ReactiveX是一个异步编程库，它的风格是使用函数式观察者模式流来构建异步代码。这里主要讨论的是RxJava 2和RxAndroid。 ##基本工作模式 Rx的核心思想是观察者模式模型，当然观察者和被观察就是最核心的两个对象。 Rxjava2中，为了解决背压(BackPressure)问题，引入了两种观察者模式。 背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略《关于 RxJava 最友好的文章—— RxJava 2.0 全新来袭》 其中Observable和Flowable是观察者，而Observer和Subscribe是其各自对应的被观察者。 Rx的基本工作流程是，建立Observable，在里面提供数据、对象、事件等等，之后订阅被观察者，向被观察者传递这些东西，由被观察者进行处理。 创建ObservablesRx中，对象构建基于Build模式，所有的工作会在build链结束后才会被执行。Rx提供了许多创建Observables的方法： Create 最常规的创建方法，在RxAndroid中，参数需要传递一个ObservableOnSubscribe&lt;T&gt;对象。ObservableOnSubscribe&lt;T&gt;是一个接口，需要实现public void subscribe(final ObservableEmitter&lt;String&gt; e) throws Exception方法，它会提供一个Emitter对象。这个方法用来订阅被观察者，被观察者通过Emitter将数据传递给被观察者。 Q:怎么回事被观察者去订阅观察者呢？A:因为依靠这个逻辑，可以让被观察者实现一个完整的流式编程。 Defer会将创建Observable延迟被订阅时，传递一个Callable&lt;? extends ObservableOnSubscribe&lt;?&gt;&gt;。这个意思应该很明确。 Empty/Never/Throw字面意义。 From将其他对象或者数据容器转换成Observable。在RxJava中，from方法是一系列方法集。比如fromArray,fromCallable,fromInterable等。 Interval周期性地产生一系列依次递增的&lt;? extends Long&gt;类型的值emit。 Just发送一个/一系列对象emit给被观察者。最简单的方法。 Range产生一个范围的整形值emit给观察者。 Repeat 周期性重复产生一个或一组对象emit。 Timer在一定延迟之后emit单个对象。 A Demo Using Rx我们用一个实际例子来体验Rxjava的基本使用方法。在这个实例中，我们要做一个奶酪搜索app，在输入框中输入关键字，然后在准备好的数据集中搜索包含这些关键字的奶酪品牌。 准备工作首先，在主界面Layout设计UI，如图：然后，我们先封装一个BaseSearchActivity。在这个BaseSearchActivity中做以下封装： 持有各个控件的引用； 初始化RecyclerView，和设置它的内容的方法； 获取CheeseSearchEngine，搜索工具类的实例； 显示/隐藏ProgressBar； 获取数据集 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class CheeseActivity extends BaseSearchActivity &#123; private Disposable mDisposable; @Override protected void onStart() &#123; super.onStart(); Observable&lt;String&gt; textChangeStream = createTextChangeObservable(); Observable&lt;String&gt; buttonClickStream = createButtonClickObservable(); Observable&lt;String&gt; searchTextObservable = Observable.merge(textChangeStream, buttonClickStream); mDisposable = searchTextObservable .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; showProgressBar(); &#125; &#125;) .observeOn(Schedulers.io()) .map(new Function&lt;String, List&lt;String&gt;&gt;() &#123; @Override public List&lt;String&gt; apply(String query) throws Exception &#123; return mCheeseSearchEngine.search(query); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;List&lt;String&gt;&gt;() &#123; @Override public void accept(List&lt;String&gt; result) throws Exception &#123; hideProgressBar(); showResult(result); &#125; &#125;); &#125; private Observable&lt;String&gt; createButtonClickObservable()&#123; return Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(final ObservableEmitter&lt;String&gt; e) throws Exception &#123; mSearchButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; e.onNext(mQueryEditText.getText().toString()); &#125; &#125;); e.setCancellable(new Cancellable() &#123; @Override public void cancel() throws Exception &#123; mSearchButton.setOnClickListener(null); &#125; &#125;); &#125; &#125;); &#125; private Observable&lt;String&gt; createTextChangeObservable() &#123; Observable&lt;String&gt; textChangeObservable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(final ObservableEmitter&lt;String&gt; e) throws Exception &#123; final TextWatcher watcher = new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123;&#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123;&#125; @Override public void afterTextChanged(Editable s) &#123; e.onNext(s.toString()); &#125; &#125;; mQueryEditText.addTextChangedListener(watcher); e.setCancellable(new Cancellable() &#123; @Override public void cancel() throws Exception &#123; mQueryEditText.removeTextChangedListener(watcher); &#125; &#125;); &#125; &#125;); return textChangeObservable.filter(new Predicate&lt;String&gt;() &#123; @Override public boolean test(String query) throws Exception &#123; return query.length() &gt;= 2; &#125; // 防抖动 &#125;).debounce(1000, TimeUnit.MILLISECONDS); &#125; @Override protected void onStop() &#123; super.onStop(); if (!mDisposable.isDisposed()) &#123; mDisposable.dispose(); &#125; &#125;&#125; 其中，工具类CheeseSearchEngine的实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class CheeseActivity extends BaseSearchActivity &#123; private Disposable mDisposable; @Override protected void onStart() &#123; super.onStart(); Observable&lt;String&gt; textChangeStream = createTextChangeObservable(); Observable&lt;String&gt; buttonClickStream = createButtonClickObservable(); Observable&lt;String&gt; searchTextObservable = Observable.merge(textChangeStream, buttonClickStream); mDisposable = searchTextObservable .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; showProgressBar(); &#125; &#125;) .observeOn(Schedulers.io()) .map(new Function&lt;String, List&lt;String&gt;&gt;() &#123; @Override public List&lt;String&gt; apply(String query) throws Exception &#123; return mCheeseSearchEngine.search(query); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;List&lt;String&gt;&gt;() &#123; @Override public void accept(List&lt;String&gt; result) throws Exception &#123; hideProgressBar(); showResult(result); &#125; &#125;); &#125; private Observable&lt;String&gt; createButtonClickObservable()&#123; return Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(final ObservableEmitter&lt;String&gt; e) throws Exception &#123; mSearchButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; e.onNext(mQueryEditText.getText().toString()); &#125; &#125;); e.setCancellable(new Cancellable() &#123; @Override public void cancel() throws Exception &#123; mSearchButton.setOnClickListener(null); &#125; &#125;); &#125; &#125;); &#125; private Observable&lt;String&gt; createTextChangeObservable() &#123; Observable&lt;String&gt; textChangeObservable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(final ObservableEmitter&lt;String&gt; e) throws Exception &#123; final TextWatcher watcher = new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123;&#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123;&#125; @Override public void afterTextChanged(Editable s) &#123; e.onNext(s.toString()); &#125; &#125;; mQueryEditText.addTextChangedListener(watcher); e.setCancellable(new Cancellable() &#123; @Override public void cancel() throws Exception &#123; mQueryEditText.removeTextChangedListener(watcher); &#125; &#125;); &#125; &#125;); return textChangeObservable.filter(new Predicate&lt;String&gt;() &#123; @Override public boolean test(String query) throws Exception &#123; return query.length() &gt;= 2; &#125; // 防抖动 &#125;).debounce(1000, TimeUnit.MILLISECONDS); &#125; @Override protected void onStop() &#123; super.onStop(); if (!mDisposable.isDisposed()) &#123; mDisposable.dispose(); &#125; &#125;&#125; 这里顺便再给出Adapter的实现代码： 1234567891011121314151617181920212223242526272829303132333435public class CheeseAdapter extends RecyclerView.Adapter&lt;CheeseAdapter.CheeseViewHolder&gt; &#123; private List&lt;String&gt; mCheeses; @Override public CheeseViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; LayoutInflater layoutInflater = LayoutInflater.from(parent.getContext()); View view = layoutInflater.inflate(android.R.layout.simple_list_item_1, parent, false); return new CheeseViewHolder(view); &#125; @Override public void onBindViewHolder(CheeseViewHolder holder, int position) &#123; holder.title.setText(mCheeses.get(position)); &#125; @Override public int getItemCount() &#123; return mCheeses == null ? 0 : mCheeses.size(); &#125; public void setCheeses(List&lt;String&gt; cheeses) &#123; mCheeses = cheeses; notifyDataSetChanged(); &#125; public static class CheeseViewHolder extends RecyclerView.ViewHolder &#123; public final TextView title; public CheeseViewHolder(View itemView) &#123; super(itemView); title = (TextView) itemView.findViewById(android.R.id.text1); &#125; &#125;&#125; 准备工作就做完了，然后，我们再新建一个CheeseActivity类，并将其设置为启动Activity。我们的代码实现将在这个Activity中进行。 为按钮绑定搜索事件我们首先来实现，如何来实现点击按钮进行搜索。 基于观察者模式的思维，我们可以这样想：在被观察者中注册按钮事件，当点击按钮时，将输入框中的内容emit给被观察者。在被观察者中，我们接受到这个emit内容，并进行搜索任务。 按照这个逻辑，我们首先来建立被观察者。 12345678910111213141516171819private Observable&lt;String&gt; createOnClickObservable() &#123; return Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(final ObservableEmitter&lt;String&gt; e) throws Exception &#123; mSearchButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; e.onNext(String.valueOf(mQueryEditText.getText())); &#125; &#125;); e.setCancellable(new Cancellable() &#123; @Override public void cancel() throws Exception &#123; mSearchButton.setOnClickListener(null); &#125; &#125;); &#125; &#125;); &#125; 在CheeseActivity中添加一个私有方法来构建Observable。其中，T代表我们要emit的内容的类型。我们使用create方法来创建，这里要实现ObservableOnSubscribe接口中的subscribe方法。该方法是订阅观察者的方法，在其中我们需要手动实现emit。 需要注意的是，需要在e.setCancellable中将Listener清除。当我们手动取消订阅时，如果没有将Listener清除，这个Listener就会导致整个引用链无法被GC。 接下来，我们要设置观察者接受到emit内容后的逻辑了。我们重写onStart()方法，在其中做完整的初始化工作： 123456789101112@Overrideprotected void onStart() &#123; super.onStart(); Observable&lt;String&gt; onClickObservable = createOnClickObservable(); onClickObservable.subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String query) throws Exception &#123; List&lt;String&gt; result = mCheeseSearchEngine.search(query); showResult(result); &#125; &#125;);&#125; 首先我们调用createOnClickObservable()方法创建Observable对象，然后开始链式build整个观察者模式。这里我们使用subscribe订阅观察者，注意，是订阅观察者！subscribe的标准参数是一个Observer类型接口，它的实现如下： 12345678910public interface Observer&lt;T&gt; &#123; //在订阅后发送数据之前会先回调整个方法，使用d可以取消订阅 void onSubscribe(Disposable d); // 用来接收emit过来的数值 void onNext(T value); // 出错会回调这个方法 void onError(Throwable e); // 取消订阅会回调这个方法 void onComplete();&#125; 不过，我们这里使用的Consumer接口是一个简化的观察者，它的实现： 1234public interface Consumer&lt;T&gt; &#123; // 接收emit参数，可以抛出异常 void accept(T t) throws Exception;&#125; 大多数情况下都可以使用这个简化版本来处理emit过来的值。 不过，我们这里偷了个懒。如果按照正宗的函数式编程思想，emit传递过来的值是String类型，而我们交给界面显示的值是一个List，这两个不是相同的类型。这种情况，我们应该使用Map操作符来执行类型转换。 操作符来执行类型转换。 上面的代码实现可以这样， 123456789101112131415161718@Override protected void onStart() &#123; super.onStart(); Observable&lt;String&gt; onClickObservable = createOnClickObservable(); onClickObservable .map(new Function&lt;String, List&lt;String&gt;&gt;() &#123; @Override public List&lt;String&gt; apply(String query) throws Exception &#123; return mCheeseSearchEngine.search(query); &#125; &#125;) .subscribe(new Consumer&lt;List&lt;String&gt;&gt;() &#123; @Override public void accept(List&lt;String&gt; cheese) throws Exception &#123; showResult(cheese); &#125; &#125;); &#125; 关于函数式编程的思想不是本文的重点，这里就不多说了，有兴趣可以自行查阅相关资料。 我们的代码是运行成功了，结果也没有问题。可是，因为查询操作通常都是很耗时的，按下按钮后，我们也会卡在主界面无法操作。并且，Android Monitor也给出了类似下面这样的提示，通常，这种提示会在主线程长期无法响应时出现。所以我们要避免这种情况，就要使用多线程。 Rxjava一个最牛逼的地方就在于，可以极其方便地将代码执行在不同线程中。我们再来重构一下我们的代码。 1234567891011121314151617181920@Override protected void onStart() &#123; super.onStart(); Observable&lt;String&gt; onClickObservable = createOnClickObservable(); onClickObservable .observeOn(Schedulers.io()) .map(new Function&lt;String, List&lt;String&gt;&gt;() &#123; @Override public List&lt;String&gt; apply(String query) throws Exception &#123; return mCheeseSearchEngine.search(query); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;List&lt;String&gt;&gt;() &#123; @Override public void accept(List&lt;String&gt; cheese) throws Exception &#123; showResult(cheese); &#125; &#125;); &#125; 可以看到，我们在build链中添加了两个observeOn()方法。这个方法用于指定接下来的操作所在的线程。Rx为我们预先定义了很多Scheduler，代表执行的线程环境，我们可以很方便地使用它们。比如Scheduler.io()就代表在io线程中执行，AndroidScheduler.mainThread()表示主线程。 顿时异步编程如同儿戏一般简单，这就是Rx的一个亮点之一。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Dagger2使用手册]]></title>
      <url>%2F2017%2F03%2F11%2FDagger2%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.html</url>
      <content type="text"><![CDATA[参考文章：Dagger2入门，以初学者的角度 在项目中引入Dagger2step 1. 在项目build.gradle文件中添加apt插件： 1234567891011121314buildscript &#123; ... dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files // 添加apt插件 classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8' &#125;&#125;... step2. 在app目录下的build.gradle文件中添加： 123456789101112//应用apt插件apply plugin: 'com.neenbedankt.android-apt'...dependencies &#123; ... // 引入dagger2 compile 'com.google.dagger:dagger:2.4' apt 'com.google.dagger:dagger-compiler:2.4' //java注解 provided 'org.glassfish:javax.annotation:10.0-b28'&#125; 入门篇Dagger2基本用法 —— 使用Moudle类现在我们有个需求，要在MainActivity中使用Car对象。那么用依赖注入的方法要怎么实现呢？首先我们来看看其中较复杂但功能也较强大的方式是如何实现的： 1. 首先编写一个依赖对象类Car1234567891011121314151617181920public class Car &#123; private String car; public Car(String brand) &#123; this.car = brand; &#125; public String getCar() &#123; return this.car; &#125; public void setColor(String color) &#123; this.car = color; &#125; @Override public String toString() &#123; return "一辆" + this.car; &#125;&#125; 该类包含一个属性car。 2. 编写Moudle类Moudle类被用于向对象需求方MainActivity提供依赖对象。 12345678@Modulepublic class MainModule &#123; @Provides public Car getCar() &#123; Car car = new Car("BWM"); return car; &#125;&#125; 这就是一个简单的Module实现。注意到代码中有两个注解：@Module和@Provides。其中@Module用来向Dagger2标明这是一个Module类，@Provides是用来标记Module类中，哪些方法是用来提供依赖对象的。后面我们还会编写一个Component接口，需求对象需要实现这个Component接口才可以被注入对象。而当Component实现类需要依赖对象时，它会根据Moudle类中@Provides方法的返回值类型来选择应该调用哪个方法获取对象。 3. 编写Component接口1234@Component(modules=MainMoudle.class)public interface MainComponent &#123; void inject(MainActivity mainActivity);&#125; 同样，Component接口需要用@Component注解标注，但是@Component的注解具备更强大的功能，它有modules和dependencies两个属性，这两个属性的类型都是Class数组。modules是用来申明该Component含有几个Moudle，当Component需要某个依赖对象时，就会去这些Moudle类中寻找相应的@Provides方法。dependency属性，则是生命Component类的依赖关系，稍后再详细解释。 接口中的inject方法是干嘛的呢？inject方法被用来将需求对象MainActivity送入Component类，Component类会根据需求对象中声明的依赖关系来注入需求对象所需要的依赖对象。需求对象MainActivity中需要依赖对象Car，所以我们通过inject方法将MainActivity的实例传入到MainComponent中，MainComponent就会从MainModule中的getCar方法中获取实例，并将该实例赋值给MainActivity中声明的依赖对象字段。 需要注意的是，inject方法的参数不能用父类来接收。 4. 在需求对象中声明依赖关系12345678910111213141516public class MainActivity extends AppCompatActivity &#123; private TextView tvHello; @Inject Car car; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tvHello = (TextView) findViewById(R.id.tv_hello); MainComponent build = DaggerMainComponent.builder().mainMoudle(new MainModule()).build(); build.inject(this); tvHello.setText("我买了" + car); &#125;&#125; 上面代码中，@Inject注解用来声明依赖，Dagger2中所有的依赖对象都是通过@Inject注解声明的。但是，@Inject注解的字段不能是private和protected。 其次，Dagger2会帮我们自动生成Component的实现类。创建这个类时，需要提供Moudle类的实例。要强调的是，我们需要在编写完Component接口之后，使用rebuild重新生成项目，Dagger2才会帮我们创建好对应的类。 之后，将需求对象，此处为this，传递给inject方法。之后，你就会发现，@Inject注解的字段已经被赋值，而该对象就是我们在Moudle的getCar方法中创建的那个对象。 最简单的用法怎么tm这么麻烦？就tm赋个值就写这么多代码？怕是还不如不用依赖注入方便呢。别急，对于这种简单地依赖情形，我们还有更简单的方法。 创建依赖类12345678910public class Insurance &#123; @Inject public Insurance() &#123; &#125; @Override public String toString() &#123; return "一份保险"; &#125;&#125; 这次，我们直接在依赖类的构造函数上面添加了@Inject注解。当Component在所拥有的Moudle类中找不到需求方需要的类型时，Dagger2就会检查需要的类型有没有被@Inject声明的构造方法，有则用该构造方法去创建一个。 同样，要将这个对象注入到需求方中，也需要在需求方实现代码中添加字段声明并用@Inject注解。 123456789101112public class MainActivity extends AppCompatActivity &#123; ... @Inject Insurance insurance; ... @Override protect void onCreate(Bundle savedInstanceState) &#123; ... tvHello.setText("我买了" + car + "和" + insurance); &#125;&#125; 是不是很简单？那为什么不都用这种方法呢？不过，如果我们使用别人的jar包，是不能修改别人的代码去添加注解的，所以不得不通过Module类来提供对象。 应对依赖的依赖上面的例子中，我们创建的这些依赖类都不用依赖于其他的类。但是，如果需要依赖于其他依赖类，又要怎么使用呢？ 首先我们来创建一个类Driver： 123456789101112131415161718public class Driver &#123; private Car car; private String driver; public Driver(Car car,String name) &#123; this.car = car; driver = name; &#125; public Car getCar() &#123; return car; &#125; @Override public String toString() &#123; return "老司机" + driver + "有一辆" + car; &#125;&#125; 这个Driver类依赖于Car对象，如果我们要在MainActivity中需要注入Driver对象，又该怎么办呢？ 在Module类中增加Provide方法：首先我们会自然地想到在Moudle类中添加如下的方法： 12345@Providespublic Driver getDriver() &#123; Car car = new Car("BWM"); return new Driver("BWM","小明");&#125; 这样的确是可以的，不过我们之前就已经创建了一个提供Car对象的方法，能不能直接利用起来呢？Dagger2提供了这种功能，我们只需要在getDriver的方法中，添加Car参数，Dagger2会自动地像帮助需求对象查找依赖对象那样，找到该方法依赖的Car实例。所以我们的代码可以写成这样： 1234@Providespublic Driver getDriver(Car car) &#123; return new Driver(car,"小明");&#125; 这样，我们就可以在MainActivity注入依赖啦。 12345678910111213141516public class MainActivity extends AppCompatActivity &#123; private TextView mTVHello; @Inject Driver driver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTVHello = (TextView) findViewById(R.id.tv_Hello); MainComponent build = DaggerMainComponent.builder().mainModule(new MainModule()).build(); build.inject(this); mTVHello.setText(driver.toString()); &#125;&#125; 不光如此，带有@Inject注解的构造函数，若是需要依赖于其他对象，Dagger2也会根据这个规则为你自动注入。 Dagger2依赖提供规则总结123456789101112131415161718192021222324//伪代码function(依赖对象) &#123; if (查找Moudle类中是否存在创建依赖对象的方法)&#123; //如果存在 if (检查该方法是否存在参数) &#123; //如果有参数，则递归调用寻找注入方法 function(参数中的依赖对象) &#125; else &#123; //如果没有参数，就直接初始化该实例 return 成功注入一次 &#125; &#125; else &#123; // 如果不存在创建依赖的方法，就查找带Inject注解的构造函数，看是构造函数是否存在参数 if (存在参数) &#123; // 存在参数就去找能否注入 function(参数中的对象) &#125; else &#123; // 不存参数，直接初始化 return 成功注入一次 &#125; &#125;&#125; 可以看到，Dagger2会递归地提供依赖。 进阶篇@Name和@Qulifier@Named最近小明发了大财，于是买了一辆梦寐以求的限量版法拉利。 12345678910//在Module类中修改@Providespublic Car getBWMCar() &#123; return new Car("BWM");&#125;@Providespublic Car getFerrariCar() &#123; return new Car("限量版法拉利");&#125; 我们将小明的法拉利添加到了Moudle中。不过，我们之前提到过，Dagger2是依靠返回值来确定注入对象的。现在我们有两台Car，小明要怎么开上自己最新买的法拉利呢？ Dagger2为我们提供了@Name注解。它有一个参数value，用来区别相同类型的依赖对象。下面的代码展示了如何使用@Name注解： 123456789101112//在Module中@Provides@Named("BWM")public Car getBWMCar() &#123; return new Car("BWM");&#125;@Provides@Named("Ferrari")public Car getFerrariCar() &#123; return new Car("限量版法拉利");&#125; 可以看到，通过@Named注解，我们为相同返回类型的Provides方法，命名加以区分。 在Module类中，也通过@Named注解来标注该调用哪个提供方法： 12345678910111213141516public class MainActivity extends AppCompatActivity &#123; private TextView mTVHello; @Inject @Named("BWM") Car bwmCar; @Inject @Named("Ferrari") Car ferrariCar; @Override protected void onCreate(Bundle savedInstanceState) &#123; ... mTVHello.setText("小明现在有" + bwmCar + "和" + ferrariCar); &#125;&#125; @Qulifier@Qulifier的功能和@Name一样，并且，@Name继承于@Qulifier。那么如何使用@Qulifier呢？需要自定义注解： 1234@Qualifier@Retention(RetentionPolicy.RUNTIME)public @interface BWM() &#123;&#125; 效果和@Named(value)是一样的。在Module中的Provide方法中标注@BWM注解就可以了。 另外，这个两个注解可以用在依赖参数上，比如 1234@Providespublic Driver getDriver(@Named("Ferrari") car) &#123; return new Driver(car, "小明");&#125; @Singleton和@Scope@Singleton小明出车祸了，法拉利撞得面目全非，不过幸好人没出事，没几天就出院了。出院的小明回到家中，看到家门口有一辆和自己一模一样的法拉利，竟然完好无损！这是怎么回事呢？ Module类中的小明和法拉利： 123456789101112@Modulepublic class MainModule &#123; @Provides public Car getFerrariCar() &#123; return new Car("限量版法拉利"); &#125; @Provides public Driver getDriver(Car car) &#123; return new Driver(car, "小明"); &#125;&#125; 接着在MainActivity中声明： 123456789101112131415161718public class MainActivity extends AppCompatActivity &#123; private TextView mTVHello; @Inject Car car; @Inject Driver driver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTVHello = (TextView) findViewById(R.id.tv_Hello); MainComponent build = DaggerMainComponent.builder().mainModule(new MainModule()).build(); build.inject(this); mTVHello.setText("这个car是小明的法拉利吗？"+(car == driver.getCar())); &#125;&#125; 原来这辆车是隔壁老王的。 通过这个例子可以发现，我们在MainActivity中注入的Car和Driver中注入的Car并不是同一个对象。在注入过程中，调用了两次创建依赖对象的方法。 那么，如果需要MainActivity中的Car对象和Driver中的Car对象是同一个对象，又要怎么办呢？Dagger2中，使用@Singleton注解可以实现这个需求: 12345@Singleton@Providespublic Car getFerrariCar() &#123; return new Car("限量版法拉利");&#125; 同时，需要在MainComponent接口中添加该注解： 12345@Singleton@Component(modules=MainModule.class)public interface MainComponent&#123; void inject(MainActivity mainActivity);&#125; @Scope@Scope用来申明作用范围，其实@Singleton就是基于它来实现的。使用它的时候，也需要自定义注解： 1234@Scope@Retention(RetentionPolicy.RUNTIME)public @interface PerActivity &#123;&#125; 之后将Module中的Provide方法打上@PerActivity，就可以将该方法包含在PerActivity作用范围之内。别忘了在Component接口上也要使用这个注解 这个作用范围有什么用呢？在Dagger2里面，同一作用范围内的Provide方法，在需要生成多个依赖对象时，都只会被调用一次，因此，需求方得到的以来对象实例就会是同一个实例。(只有在Moudle类中声明了作用范围的Provide方法才会有这样的行为) Dagger2提供这个注解的目的在于可以让我们自定义作用范围名，提高代码的可读性。 **Note： 在通过构造函数提供依赖的方式中，需要将作用范围在类名上注解，而不是在构造方法上。 只有在同一个Component实例下提供依赖才能实现Singleton。** 组件依赖Dependencies开发中，如果遇到工具类这种，在整个APP生命周期中都是单例的情形该怎么处理呢？ 首先添加一个工具类： 12345public class CarMarket &#123; public Driver deal(Car car, String buyer) &#123; return new Driver(car, buyer); &#125;&#125; 接着建立一个BaseModule来提供工具类： 12345678@Modulepublic class BaseModule &#123; @Singleton @Provides public CarMarket getCarMarket() &#123; return new CarMarket(); &#125;&#125; 再创建一个接口： 12345@Singleton@Component(modules = BaseModule.class)public interface BaseComponent &#123; ClothHandler getClothHandler();&#125; Q:这个Component为什么没有inject方法呢？A:因为BaseComponent这个接口是给其他Component提供依赖的，具体注入由子Component类提供。这里仅仅是告诉其子类BaseComponent能提供这个ClothHandler对象，因此，它不需要inject方法。 接下来，在MainComponent和SecondComponent两个子类中声明依赖。 1234567891011@PerActivity@Component(modules=MainModule.class,dependencies=BaseComponent.class)public interface MainComponent &#123; void inject(MainActivity mainActivity);&#125;@PerActivity@Component(modules=SecondModule.class,dependencies=BaseComponent.class)public interface SecondComponent &#123; void inject(SecondActivity secondActivity);&#125; 此时，rebuild工程就可以看到，创建MainComponent和SecondComponent实例的时候，多了一个baseComponent方法。 我们需要为这个BaseComponent传递一个实例。如果要保证两个子Component能获取同一个BaseComponent实例，有一种方法是：自定义一个Application类。 Q:如何保证某个对象在App生命周期中只有一个实例？A:使用静态工厂，或者自定义一个Application类。 12345678910111213141516// 在Application中持有baseComponent，// 从而获得一个在整个App生命周期内仅有的baseComponent实例，// 这样做还有个隐含好处：// BaseModule中需要Context对象的时候，可以直接传入this。public class MyApplication extends Application &#123; private BaseComponent baseComponent; @Override public void onCreate() &#123; super.onCreate(); baseComponent = DaggerBaseComponent.builder().baseModule(new BaseModule()).build(); &#125; public BaseComponent getBaseComponent() &#123; return baseComponent; &#125; &#125; 创建完自定义类后，还需要在AndroidManifest.xml中声明新建的MyApplication: 12345...&lt;application android:name = ".MyApplication"... 接下来，在MainActivity和SecondActivity中，只需要在构建子Component实例中这样调用就行了: 1MainComponent build = DaggerMainComponent.builder().baseComponent((MyApplication)getApplication()).getBaseComponent()) @Subcomponent注解@Subcomponent注解和dependencies类似，但是@Subcomponent使用起来有点不同，需要在父组件(BaseComponent)中声明一个返回值为子组件（SubComponent）的方法。当子组件需要什么Moudle时，就在该方法中添加该类型的参数： 子组件接口应该改为使用@Subcomponent 12345@PerActivity@Subcomponent(modules=MainModule.class)public interface SubComponent &#123; void inject(MainActivity activity);&#125; 在父组件中需要声明一个提供子组件的方法： 1234567@Singleton@Component(modules=BaseModule.class)public interface BaseComponent &#123; CarMarket getCarMarket(); // @Subcomponent关键点 SubComponent getSubComponent(MainModule module);&#125; 之后调用注入的时候，指定要使用的Module就行了。 12MyApplication application = (MyApplication) getApplication(); application.getBaseComponent().getSubComponent(new MainModule()).inject(this); 使用这个方法同样可以实现单例，因为BaseComponent是同一个实例。 ##Lazy和Provider包装容器这两个容器是用来包装依赖对象的。注入时，如果用这两个容器包装依赖对象，Lazy容器懒加载方式就会只在你需要用到该依赖对象的时候才会去获取一个；而Provider容器的对象不光具有Lazy特性，而且每次要用到的时候，都会重新调用生成依赖对象的方法注入。 12345//在需求类中@InjectLazy&lt;Car&gt; car;@InjectProvider&lt;Driver&gt; driver; 不过，如果声明了单例，Provider也就失去了意义。 ##Component生命周期一般情况下，都是在Activity中的onCreate方法中创建Component实例，再调用inject完成依赖注入。 在onCreate()方法调用完成之后，Component实例就会因为没有被引用而被GC，其中Module实例也会被一并回收。不过，使用Lazy和Provider时，与该依赖对象有关的Module实例会被引用，这个Moudle实例将不会被回收。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android内存泄漏分析]]></title>
      <url>%2F2017%2F03%2F10%2FAndroid%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90.html</url>
      <content type="text"><![CDATA[具体的垃圾回收机制四种引用类型的介绍 强引用（Strong Reference）：JVM宁可抛出OOM，也不会让GC回收具有强引用的对象； 软引用（Soft Reference）：只有在内存空间不足时，才被回收的对象； 软引用（Weak Reference）：在GC时，一旦发现了只具有若引用的对象，不管当前内存空间是否充足，都会回收它的内存； 虚引用（Phantom Reference）：任何时候都可以被GC回收。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否需要回收。 我们常说的内存泄漏是指new出来的Object无法被GC回收，即为强引用。 常见内存泄漏案例case1.单例造成的内存泄漏单利的特性导致其生命周期同应用一样长。解决方案： 1.将该属性的引用方式改为弱引用；2.如果传入Context，使用ApplicationContext。 例子： 泄漏代码片段 1234567891011121314151617181920private static ScrollHelper mInstance;private ScrollHelper() &#123;&#125;public static ScrollHelper getInstance()&#123; if (mInstance == null) &#123; synchronized (ScrollHelper.class) &#123; if (mInstance == null) &#123; mInstance = new ScrollHelper(); &#125; &#125; &#125; return mInstance;&#125;/*** 被单击的View*/private View mScrolledView = null;public void setScrolledView(View scrolledView) &#123; mScrolledView = scrolledView;&#125; 使用弱引用WeakReference之后： 1234567891011121314151617181920private static ScrollHelper mInstance;private ScrollHelper() &#123;&#125;public static ScrollHelper getInstance()&#123; if (mInstance == null) &#123; synchronized (ScrollHelper.class) &#123; if (mInstance == null) &#123; mInstance = new ScrollHelper(); &#125; &#125; &#125; return mInstance;&#125;/*** 被单击的View*/private WeakReference&lt;View&gt; mScrolledViewWeakRef = null;public void setScrolledView(View scrolledView) &#123; mScrolledViewWeakRef = new WeakReference&lt;View&gt;(scrolledView);&#125; case 2. InnerClass匿名内部类在Java中，非静态内部类和匿名类都会潜在地引用它们所属的外部类。如果它们内部做了一些耗时操作，就会造成外围对象不会被回收，从而导致内存泄漏。但是静态内部类却不会。 解决方案： 1.将内部类改为静态内部类；2.如果有强引用Activity中的属性，则将该属性改为弱引用；3.如果允许，尽可能在Activity执行onDestory时，结束掉这些耗时任务。 例子： 1234567891011121314151617181920212223public class LeakAct extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.aty_leak); test(); &#125; //这儿发生泄漏 public void test() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125;&#125; 改为静态匿名内部类： 1234567891011121314151617181920212223public class LeakAct extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.aty_leak); test(); &#125; //加上static，变成静态匿名内部类 public static void test() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125;&#125; Case 3. Activity Context 使用不正确在Android中应用程序通常可以使用两种Context对象：Activity和Application。当类或方法需要Context对象的时候常见的做法就是使用第一个作为Context参数。这就意味着View对象对整个Activity保持引用，因此也就保持对Activity的所有的引用。 假设一个场景，当应用程序有个比较大的Bitmap类型的图片，每次旋转都重新加载图片，所用时间较多。为了提高屏幕旋转时Activity的创建速度，最简单的方法就是将这个Bitmap对象用Static修饰。当一个Drawable绑定在View上，实际上这个View对象就会成为这份Drawable的一个Callback成员变量。而静态变量的生命周期要长于Activity。导致了屏幕旋转时，Activity无法被回收，而造成内存泄漏。解决方案：1.使用ApplicationContext代替ActivityContext，因为ApplicationContext会随着应用程序的存在而存在，而不依赖于Activity的生命周期；2.对Context的引用不要超过它本身的生命周期，慎重地对Context使用“static”关键字。Context里如果有线程，一定要在onDestroy（）里及时停掉。例子： 123456789101112private static Drawable sBackground;@Overrideprotected void onCreate(Bundle state) &#123; super.onCreate(state); TextView label = new TextView(this); label.setText("Leaks are bad"); if (sBackground == null) &#123; sBackground = getDrawable(R.drawable.large_bitmap); &#125; label.setBackgroundDrawable(sBackgroud); setContextView(label);&#125; 解决方案： 123456789101112private static Drawable sBackground;@Overrideprotect void onCreate(Bundle state) &#123; super.onCreate(state); TextView label = new TextView(this); label.setText("Leaks are bad"); if (sBackground == null) &#123; sBackground = getApplicationContext().getDrawable(R.drawable.large_bitmap); &#125; label.setBackgroundDrawable(sBackground); setContextView(label);&#125; case 4. Handler引起的内存泄漏当Handler中有延迟的任务或是等待执行的任务队列过长，由于消息持有对Handler的引用，而Handler又持有对其外部类的引用。这条引用关系会一直保持到消息得到处理，而导致了Activity无法被垃圾回收器回收，而导致了内存泄漏。解决方案：1.可以把Handler类放在单独的类文件中，或者使用静态内部类便可以避免泄漏；2.如果想在Handler内部去调用所在的Activity，那么可以在handler内部使用弱引用的方式去指向所在Activity。使用static+WeakReference的方式来达到断开Handler与Activity之间存在引用关系的目的。解决方案： 123456789@Overrideprotected void doOnDestroy() &#123; super.doOnDestory(); if (mHandler != null) &#123; mHandler.removeCallbackAndMessages(null); &#125; mHandler = null; mRenderCallback = null;&#125; case 5.注册监听器的泄漏系统服务可以通过Context.getSystemService获取，它们负责执行某些后台任务，或者为硬件提供访问接口。如果Context对象想要在服务内部的事件发生时被通知，那就需要把自己注册到服务的监听器中。然而，这会让服务持有Activity的引用，如果在Activity的onDestroy时没有释放掉引用就会内存泄漏。 解决方案： 1.使用ApplicationContext代替ActivityContext；2.在Activity执行onDestroy时，调用反注册； mSensorManager = (SensorManager) this.getSystemService(Context.SENSOR_SERVICE);解决方案：mSensorManager = (SensorManager) getApplicationContext().getSystemService(Context.SENSOR_SERVICE);下面是容易造成内存泄漏的系统服务：InputMethodManager imm = (InputMethod) context.getApplicationContext().getSystemService(Context.INPUT_METHOD_SERVICE);解决方案： 12345678910111213protected void onDetachedFromWindow() &#123; if (this.mActionShell != null) &#123; this.mActionShell.setOnClickListener((OnAreaClickListener)null); &#125; if (this.mButtonShell != null) &#123; this.mButtonShell.setOnClickListener((OnAreaClickListener)null); &#125; if (this.mCountShell != this.mCountShell) &#123; this.mCountShell.setOnClickListener((OnAreaClickListener)null); &#125; super.onDetachedFromWindow();&#125;&#125; case 6. Cursor，Stream没有close，View没有recyle资源性对象比如Cursor、File等往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于JVM中，还存在于JVM之外。如果我们仅仅是把它的引用设置为null，而不是调用其提供的接口关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如SQLiteCursor，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样效率太低了。因此，在使用完资源性对象后，应该调用对应的close()方法，将其关闭后，再设为null。在我们的程序退出时一定要确保我们的资源性对象已经关闭。 case 7. 集合中的对象没有清理造成的泄漏容器中的对象在不需要时，如果没有及时把对象的引用清理掉，这个集合就会越来越大。如果这个集合是static的话情况就更严重。所以在退出程序之前，要将集合里面的东西clear，然后设置为null，在退出程序。解决方案： 在Activity退出之前，将集合中的所有东西clear，然后置null，再退出程序。解决方法： 1234567private List&lt;EmotionPanelInfo&gt; data;public void onDestroy() &#123; if (data != null) &#123; data.clear(); data = null; &#125;&#125; case 8. WebView造成的泄漏当我们不再使用WebView对象时，应该调用它的destroy()函数来销毁它，并释放其内存，否则其占用的内存长期也不能被回收，从而造成内存泄漏。解决方案： 为webView开启另外一个进程，通过AIDL与主线程进行通信，WebView所在的进程可以根据业务需要选择合适的时机进行销毁，从而达到完整的内存释放。 case 9. 构造Adapter时，没有使用缓存的ConvertView初始时ListView会从Adapter中根据当前的屏幕布局实例化一定数量的View对象，同时ListView会将这些View对象缓存起来。当向上滚动ListView时，原先位于最上面的List Item的View对象会被回收，然后被用来构造新出现的最下面的List Item。这个构造过程就是由getView()方法完成的，getView()的第二个形参View ConvertView就是被缓存起来的List Item的View对象（初始化时缓存中没有View对象则ConvertView是null）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[走近科学：揭秘Context]]></title>
      <url>%2F2017%2F03%2F09%2F%E8%B5%B0%E8%BF%91%E7%A7%91%E5%AD%A6%EF%BC%9A%E6%8F%AD%E7%A7%98Context.html</url>
      <content type="text"><![CDATA[Activity可以new吗？Activity mActivity = new Activity();可能很多人没有想过这个问题：Activity可以new吗？本质上，Activity也是一个类，照理来说它应该符合Java的语法，可是上面那种用法到底有什么问题呢？ Android程序不像Java程序，随便写一个类，添加一个main()方法就能运行。Android是基于组件的应用设计模式，组件的运行需要有一个完整的Android工程环境。只有在这个环境下，Activity、Service等系统组件才能正常工作。不过这些组件并不能采取普通的Java对象创建的方式，new一下就能创建实例了。它们的建立需要有各自的上下文环境，而这就是我们要讨论的Context。 Context是维持Andoird程序各组件能正常工作的一个核心功能类。 Context到底是什么？Context的字面意思是“语境”、“上下文”，可以理解为当前对象在程序中的一个环境，一个与系统交互的过程。比如微信聊天，此时的context是指聊天界面以及相关的数据请求与传输。Context在加载资源、启动Activity、获取系统服务、创建View等操作都要参与。 那Android中的Context到底是什么呢？一个Activity就是一个Context，一个Service也是一个Context。Android设计者把“应用场景”抽象为了Context类，认为用户和操作系统的每一种交互都是一个场景。比如打电话、发短信、这些都是一个有界面的场景。还有一些没有界面的场景，比如后台运行的服务（Service）。一个应用程序可以认为是一个工作环境，用户在这个工作环境中会切换到不同的场景。它就像一个公司的前台秘书，可能需要接待客人，可能要打印文件，还可能要接听客户电话。而这些任务就可以称之为不同的场景，这个前台秘书可以称之为一个应用程序。 其实，Context也可以看做是一个应用与系统交互的中间层。在Android的源码中，对Context的注释文档说明： 它是一个抽象类，它的执行被Android系统所提供。它允许获取以应用为特征的资源和类型，是一个统领一些资源（应用程序环境变量等）的上下文。就是说，它描述一个应用程序环境的信息（即上下文）；是一个抽象类，Android提供了该抽象类的具体实现类；通过它我们可以获取应用程序的资源和类（包括应用级别操作，如启动Activity，发广播，接受Intent等）。 Context的实现类既然源码中说明了它是一个抽象类，那么肯定就有它的实现类咯。Context的实现类可以形成如下的关系图：Context类本身是一个纯抽象类，它有两个具体的实现子类：ContextImpl和ContextWrapper。熟悉设计模式的应该可以反应过来，其实就是个装饰者模式的类图。 其中ContextWrapper只是一个包装类。它的构造函数中必须包含一个真正的Context引用，同时ContextWrapper提供了attachBaseContext()用于给ContextWrapper对象中执行真正的Context对象。ContextWrapper中的方法都会被转向其所包含的真正的Context对象。 ContextThemeWrapper类的内部包含了与主题（Theme）相关的接口。这里说的主题就是指在AndroidManifest.xml中，通过android:theme为Application元素或者Activity元素指定的主题。当然，因为只有Activity有可视化界面，Service没有，所以只有Activity才需要主题，因此Service是直接继承与ContextWrapper的，Application同理。 而ContextImpl类才真正实现了Context中的所有方法。应用程序中调用的各种Context类的方法，其实现均来自于该类。 总结一下，ContextImpl是Context的具体实现类，ContextWrapper是Context的包装类。Activity，Application，Service虽然都继承自ContextWrapper，但它们在初始化时都会创建ContextImpl对象，由ContextImpl实现Context中的方法。 一个应用有几个Context？其实我们从关系图中就可以知道，在一个应用程序中，Context的具体实现类就是Activity、Service和Application。 于是，Context的数量 = Activity数量 + Service数量 + 1。 有人会问，Boradcast Receiver，Content Provider呢？它们并不是Context的子类，其所持有的Context都是其他地方传递过去的，所以并不增加Context总数。 Context到底能干什么？Context能实现的功能就太多了，弹出Toast、启动和操作四大组件、获取资源等等都需要Context。 Context作用域虽然Context地位崇高、能力强大，但是并不是随便拿一个Context就能为所欲为的。Context的具体是由ContextImpl实现的，因此绝大多数的场景中，Activity、Service、Application这三种Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity和弹出Dialog。因为一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成返回栈。而Dialog则必须在一个Activity上面弹出（除了System Alert类型的Dialog），因此，Activity类型的Context的用途是最广的。 这里说一下上图中Application和Service所不推荐的两种使用情况。 1.如果我们用ApplicationContext去启动一个LaunchMode为standard的Activity的时候会报错android.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?这是因为非Activity类型的Context并没有所谓的任务栈，所以待启动的Activity就找不到栈了。解决这个问题的方法就是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就为它创建一个新的任务栈，而此时Activity是以singleTask模式启动的。所有这种用Application启动Activity的方式不推荐使用，Service同Application。 2.在Application和Service中去layout inflate也是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。所以这种方式也不推荐使用。 一句话总结：凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。 如何获取Context主要有以下4种方法： View.getContext。返回当前View的Context对象，通常是正在显示的Activity对象。 Activity.getApplicationContext，即获取ApplicationContext。通常我们在使用Context对象，特别是要持有Context对象时，都要优先考虑这个全局的进程Context，可以避免很多内存泄漏问题。 ContextWrapper.getBaseContext()。返回ContextWrapper所包装的那个原始Context，在实际开发中用得很少，不建议使用。 Activity.this，返回当前的Activity实例。UI控件需要使用Activity作为Context对象，但其实默认的Toast实际上也可以用ApplicationContext。getApplication()和getApplicationContext()其实这两个函数获取的都是同一个对象，那么既然结果都是相同的，Android为啥要提供两个功能重复的方法呢？实际上，这两个方法在作用域上有比较大的区别。getApplication()方法只有在Activity和Service才能调用，而另一个方法范围就要广一些，比如在BroadcastReceiver中就可以使用getApplicationContext()来获取。 Context的错误使用引起的内存泄漏这里举两个常见的例子： 1. 错误的单例模式123456789101112131415public class Singleton &#123; private static Singleton instance; private Context mContext; private Singleton(Context context) &#123; this.mContext = context; &#125; public static Singleton getInstance(Context context) &#123; if (instance == null) &#123; instance = new Singleton(context); &#125; return instance; &#125;&#125; instance作为静态对象，位于GC ROOT节点上，生命周期要长于普通的对象。常驻内存的Singleton保存了传入的Activity对象并一直持有，即使Activity被销毁掉，但因为它的引用还存在于一个Singleton中，就不会被GC掉，这就导致了内存泄漏。解决方法是使用弱引用WeakReference；或者传入ApplicationContext。 2. View持有Activity引用123456789101112public class MainActivity extends Activity &#123; private static Drawable mDrawable; @Override protected void onCreate(Bundle saveInstanceState) &#123; super.onCreate(saveInstanceState); setContentView(R.layout.activity_main); ImageView iv = new ImageView(this); mDrawable = getResources().getDrawable(R.drawable.ic_launcher); iv.setImageDrawable(mDrawable); &#125;&#125; 代码中一个静态Drawable对象被设置在ImageView中。而ImageView传入的this是MainActivity的mContext，因为被static修饰的mDrawable是常驻内存的，MainActivity是它的间接引用，所以当MainActivity被销毁时，也不会被GC掉，造成内存泄漏。 使用Context的注意事项一般Context造成的内存泄漏几乎都是当Context被销毁时，由于还存在引用而导致销毁失败。不过Application是伴随进程而存在的唯一的Context，所以： 在Application适用的场景中优先考虑使用它。 不要让生命周期长于Activity的对象持有Activity的引用。 尽量不要在Activity中使用非静态内部类和匿名类，因为它们会持有外部实例的引用。而静态内部类会将外部引用作用为弱引用持有。]]></content>
    </entry>

    
  
  
</search>
