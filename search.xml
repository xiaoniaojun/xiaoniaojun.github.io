<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[synchronized锁]]></title>
      <url>%2F2017%2F03%2F23%2Fsychronized%E9%94%81.html</url>
      <content type="text"><![CDATA[之前提到了多线程共享内存的两个问题，一个是竞态条件，一个是内存可见性，解决这两个问题的方案之一是使用synchronized关键字，接下来就来详细讨论它。synchronized关键字可以用于修饰类的实例方法、静态方法和代码块。 实例方法在之前的那个1000个线程并发对静态变量+1操作的例子中，最后得到的结果和期望结果不符合(这里去掉下面代码中的synchronized就可以看到)。当时提到了可以用synchronized关键字解决这个问题，下面就来看看如何解决： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class CounterThreadEx extends Thread &#123; private Counter counter; public CounterThreadEx(Counter counter) &#123; this.counter = counter; &#125; @Override public void run() &#123; try &#123; Thread.sleep((long) (Math.random()*10)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; counter.incr(); &#125; public static void main(String[] args) throws InterruptedException &#123; int num = 1000; Counter counter = new Counter(); Thread[] threads = new Thread[num]; for (int i = 0; i &lt; num; i++) &#123; threads[i] = new CounterThreadEx(counter); threads[i].start(); &#125; for (int i = 0; i &lt; num; i++) &#123; threads[i].join(); &#125; System.out.println(counter.getCount()); &#125; public static class Counter&#123; private int count; public synchronized void incr() &#123; count++; &#125; public synchronized int getCount()&#123; return count; &#125; &#125;&#125; 与上个例子类似，创建了1000个线程，传递了相同的counter对象，每个线程的主要操作就是调用Counter的incr方法，main线程等待子线程全部退出后输出counter的值，这次的结果就完全符合期望结果。这里的synchronized看上去使得同一时间只能有一个线程执行实例方法，但这个理解是不准确的。多个线程可以同时执行同一个synchronized方法，只要它们访问的对象是不同的。比如： 123456Counter counter1 = new Counter();Counter counter2 = new Counter();Thread t1 = new CounterThread(counter1);Thread t2 = new CounterThread(counter2);t1.start();t2.start(); 这里，t1和t2两个线程是可以同时执行Counter的incr方法的，因为它们访问的是不同的Counter对象。所以，synchronized实例方法实际保护的是同一个对象的方法调用，确保同一时间只能有一个线程执行。具体说来就是synchronized实例方法保护的是当前实例对象，即this，this对象有一个锁和一个等待队列，锁只能被一个线程持有，其他试图获取同一锁的线程需要等待，执行synchronized实例方法的过程大致如下：1.线程尝试获取对象锁，如果能够获取锁，则开始执行下一步代码，否则加入等待队列，阻塞并等待唤醒；2.执行实例方法体的代码3.释放锁，如果等待队列上有等待的线程，从中取一个并唤醒，如果有多个等待的线程，唤醒哪一个是不一定的！不保证公平性。实际上sychronized的执行过程远比这个步骤要复杂得多，而且java虚拟机采用了多种优化方式以提高性能，但从概念上我们可以这样简单地理解。当线程无法获取锁时，它会加入等待队列，线程的状态会变为BLOCKED。 所以，synchronized保护的是对象而非代码，只要访问的是同一个对象的synchronized方法，即使是不同的代码，也会被同步的顺序访问，比如对于Counter中的两个方法incr()和getCounter()，对于同一个对象，一个线程执行incr，一个执行getCounter，它们也是不能同时执行的，会被synchronized以同步的顺序执行。此外需要说明的是，synchronized方法不防止非synchronized方法被同时执行。所以一般在保护变量时，需要在所有访问该变量的方法上加上synchronized。 静态方法synchronized同样可以用在静态方法中，比如：1234567891011public class StaticCounter &#123; private static int count = 0; public static synchronized void incr() &#123; count++; &#125; public static synchronized int getCount() &#123; return count; &#125;&#125; 对于实例方法，synchronized保护的是当前实例对象this，对静态方法，保护的是类对象。这里是StaticCounter.class。实际上，每个对象队友一个锁和一个等待队列，类对象也不例外。synchronized静态方法和synchronized实例方法保护的是不同的对象，不同的两个线程，可以同时地一个执行synchronized静态方法，另一个执行synchronized实例方法。代码块 除了用于修饰方法外，synchronized还可以用于包装代码块，比如对于前面的Counter类，等价的代码可以为： 12345678910111213public class Counter &#123; private int count; public void incr() &#123; synchronized (this) &#123; count++; &#125; &#125; public int getCount() &#123; synchronized (this) &#123; return count; &#125; &#125;&#125; 而对于StaticCounter类，等价代码为： 12345678910111213public class StaticCounter&#123; private static int count = 0; public static void incr() &#123; synchronized (StaticCounter.class) &#123; count++; &#125; &#125; public static int getCount() &#123; synchronized (StaticCounter.class) &#123; return count; &#125; &#125;&#125; synchronized同步的对象可以是任意对象，任何一个对象都具有锁和等待队列，或者说，任何对象都可以作为锁对象。比如说，Counter的等价代码还可以为: 123456789101112131415public class Counter&#123; private int count; private Object lock = new Object(); public void incr() &#123; synchronized (lock) &#123; count++; &#125; &#125; public int getCount() &#123; synchronized (lock) &#123; return count; &#125; &#125;&#125; 理解Synchronized接下来我们再从下面几个角度进一步理解一下synchronized:可重入性内存可见性死锁 可重入性synchronized有一个重要的特征，它是可重入的，也就是说，对于同一个执行线程，它在获得了锁之后，调用其他需要同样锁的代码时，可以直接调用。这是一个非常自然的特性，之所以强调，是因为并不是所有的锁都是可重入的。可重入是通过记录锁的持有线程和持有数量来实现的，当调用被synchronized保护的代码时，检查对象是否已被锁，如果是，在检查是否被当前线程锁定，如果是，增加持有数量，如果不是被当前线程锁定，才加入等待对象，当释放锁时，减少持有数量，当数量变为0时才释放整个锁。 内存可见性对于复杂一些的操作，synchronized可以实现原子操作，避免出现竞态条件，但对于明显的本来就是原子操作的方法，也需要加synchronized吗？比如说，对于开关类Switcher，它只有一个boolean变量on和对应的setter/getter方法。此时，当多个线程访问同一个Switcher对象时，的确不存在竞态条件的问题，但是仍然存在内存可见性的问题，加上synchronized就可以解决。所以synchronized除了保证原子操作之外，还有一个作用，就是保证内存可见性，在释放锁时，所有写入都会写回内存，而获得锁后，都会从内存中读数据。不过如果只是为了保证内存可见性，synchronized的成本有点高，有个更轻量级的方法就是给变量加修饰符volatile。加了volatile之后，Java会在操作对应变量时加入特殊的指令，保证读写到内存的最新值而非缓存。 死锁使用synchronized或其他锁的时候，要注意死锁。所谓死锁，比如，有a、b两个线程，a持有A锁，在等待B锁，b持有B锁，在等待A锁，a、b陷入了相互等待，最后一等就是一辈子。 要避免死锁，首先应该尽量避免在持有一个锁的同时去申请另一个锁，如果确实需要多个锁，所有代码都应该按照相同的顺序去申请。借助一些工具也可以发现运行中的死锁，比如，java自带的jstack命令会报告发现的死锁。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Retrofit源码分析]]></title>
      <url>%2F2017%2F03%2F23%2FRetrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
      <content type="text"><![CDATA[Retrofit源码分析 Retrofit的亮点 先来看一个最基本的Retrofit+Gson的用法： 1234567891011121314151617// https://raw.githubusercontent.com/xiaoniaojun/xiaoniaojun.github.io/master/test.json Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://raw.githubusercontent.com/") .addConverterFactory(GsonConverterFactory.create()) .build(); GitHub gitHub = retrofit.create(GitHub.class); Call&lt;User&gt; xiaoniaojun = gitHub.results("xiaoniaojun", "test.json"); xiaoniaojun.enqueue(new Callback&lt;User&gt;() &#123; @Override public void onResponse(Call&lt;User&gt; call, Response&lt;User&gt; response) &#123; User responseUser = response.body(); &#125; @Override public void onFailure(Call&lt;User&gt; call, Throwable t) &#123; t.printStackTrace(); &#125; Retrofit让我们可以使用注解接口方法的方式来实现解析Url，构造一个可执行对象，这个可执行对象可以直接调用网络请求的操作并对返回结果进行同步/异步处理。其中最亮的地方是，这个可执行对象既可以是一个在java8或者Android平台可以直接调用的Call对象，也可以是一个Observer对象。并且，对于返回的response，可以加入Converter来将其内容以特定的方式解析，比如请求json对象，可以使用GsonConverter来将response body直接解析为具体的对象，又或者是可以自定义如何包装request。 public Retrofit build()方法： 12345678910111213141516171819202122232425262728293031323334353637/** * 根据设置的配置值来创建&#123;@link Retrofit&#125;实例 * &lt;p&gt; * 注意: 如果&#123;@link #client&#125;和&#123;@link #callFactory&#125; 都没有被调用，就默认生成和使用&#123;@link * OkHttpClient&#125;。 */ public Retrofit build() &#123; // 如果不提供baseUrl，就会抛出异常。 if (baseUrl == null) &#123; throw new IllegalStateException("Base URL required."); &#125; // 这个callFactroy是一个空的值，所以这句代码没有任何作用，估计是遗留代码。 okhttp3.Call.Factory callFactory = this.callFactory; // 默认使用OkHttpClient来创建CallFactory // Factory是一个接口，内部只有一个newCall(Request r)方法。 if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; // 这里的CallbackExecutor，是封装了主线程Looper的Handler， // 所以这个默认的CallbackExecutor会将回调在主线程中执行。 Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; // 防御性拷贝adapters，并添加默认Call adapter。 // 1.解析defaultCallAdapterFactory List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); // Make a defensive copy of the converters. List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories); return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor, validateEagerly); &#125; 这个装配的过程其实就是在为Retrofit配置几个关键组件：我们先列出它们，再来一个一个分析。baseUrl: 基url地址，在它上面构建完整的url请求，这个没什么好解释的。callFactory:call工厂，call是干嘛的？是我们最终用来执行http请求和接受的。下面我们再来剖析这个东西。callbackExecutor：回调执行者，这个是用来执行回调的。为什么要封装它？因为它是用来控制执行线程的。adapterFactories：适配器工厂，适配的什么？converterFactories转换器工厂，转换的什么？ CallFactory首先，这个callFactory是由以下代码生成的： 1callFactory = new OkHttpClient(); 这条语句创建的。我们知道，Retrofit的网络请求是基于OkHttp实现的，那这里很明显是实际执行网络操作的请求的方法。我们跟进去OkHttpClient类， 1public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory 由于这里OkHttpClient行使的是Factory的职责，我们主要看OkHttpClient实现的这个接口的方法。Call.Factory只有一个方法： 123@Override public Call newCall(Request request) &#123; return new RealCall(this, request, false /* for web socket */); &#125; 传递进一个request对象，把它转换成可执行的Call对象。 到这里，callFactory就具备了它的职责，根据request来构建Call。 现在我们来审查一下这个OkHttpClient对象。它具备的能力有：执行各种网络操作、将这些操作构建成Call对象。 这里我们再谈谈Call接口。 request返回初始化这个call的原生request对象，其余都是控制请求执行的指令。 然后，这个RealCall是Call接口的实现类，它实际处理对OkHttp的调用。由于我们这里只分析Retrofit，所以这个部分我们就省略了。现在只需要知道，通过CallFactory，我们可以构建Call对象，而这个Call就是在执行网络请求。 CallbackExecutor同样来看一下生成CallbackExecutor实例的方法， 1callbackExecutor = platform.defaultCallbackExecutor(); 首先这个CallbackExecutor是一个Executor类型对象。Executor是java并发包中的接口，只有一个execute方法，就是用来执行Runnable的。这个是用来解耦的。 Platform工具类提供了多平台支持。它在初始化的时候调用其findPlatform方法查看调用环境。在Andoird平台上，提供了MainThreadExecutor用来在主线程中执行代码。那么这个CallbackExecutor是干什么的呢？看名字就知道，是用于执行回调的。网络请求返回response，接收处理的结果很多时候是需要在主线程中更新ui的。 123@Override public Executor defaultCallbackExecutor() &#123; return new MainThreadExecutor(); &#125; 所以最终在Andoird平台上，默认的CallbackExecutor是这个MainThreadExecutor，也就是说，回调默认是在主线程中执行的。 adapterFactory12List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); 接下来又是一个平台相关的CallAdapterFactory。在Android平台中，默认的defaultCallAdapterFactory是ExecutorCallAdapterFactory。 123@Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123; return new ExecutorCallAdapterFactory(callbackExecutor); &#125; 这个CallAdapter到底适配的是什么？答案就是，我们在定义那个创建链接的接口时，不是声明了一个Call吗，这个Adapter就是将我们的CallFactory产生的Call与CallbackExecutor融合起来，创建一个生产Call对象的工厂。注意CallAdapter接口里面的那个adapter方法，就是做这件事的。 1. CallAdapterFactory12345678CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123; // 如果callbackExecutor不为空，则调用ExecutorCallAdapterFactory(callbackExecutor) if (callbackExecutor != null) &#123; return new ExecutorCallAdapterFactory(callbackExecutor); &#125; // 否则返回默认的CallAdapterFactory return DefaultCallAdapterFactory.INSTANCE;&#125; 123456789101112131415161718192021222324252627final class ExecutorCallAdapterFactory extends CallAdapter.Factory &#123; final Executor callbackExecutor;# ExecutorCallAdapterFactory(Executor callbackExecutor) &#123; this.callbackExecutor = callbackExecutor; &#125; // 这个方法传入的参数有 // returnType，返回类型 // annotations，注解 // retrofit // 从这些参数我们可以推断，这个CallAdapter是将之前所有的请求设置封装到Call中的关键 @Override public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; if (getRawType(returnType) != Call.class) &#123; return null; &#125; final Type responseType = Utils.getCallResponseType(returnType); return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); &#125; &#125;; &#125; ##Retrofit构造函数 12345678910Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl, List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; adapterFactories, Executor callbackExecutor, boolean validateEagerly) &#123; this.callFactory = callFactory; this.baseUrl = baseUrl; this.converterFactories = unmodifiableList(converterFactories); // Defensive copy at call site. this.adapterFactories = unmodifiableList(adapterFactories); // Defensive copy at call site. this.callbackExecutor = callbackExecutor; this.validateEagerly = validateEagerly; &#125; 在构造方法中，将工厂中设置的所有配置变量进行初始化赋值。 1234567891011121314151617181920212223242526public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; // 首先检查传入的类是否为一个接口，以及，是否包含了其他接口(不合格) Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; 123456789101112class Plathform &#123;private static final Platform PLATFORM = findPlatform();// getterstatic Platform get();// 这个方法查看当前代码运行平台（java8 Android 等等）private static Platform findPlatform();&#125;// 默认回调Executor为nullExecutor defaultCallbackExecutor() &#123;return null&#125;;CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123; &#125; 动态代理的代码 12345678910111213141516171819202122return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 如果是Object声明的方法就直接调用。 if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; // 垃圾代码，已经弃用 if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; // 这里是在处理Retrofit注解 ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Retrofit2+Gson的基本用法]]></title>
      <url>%2F2017%2F03%2F13%2FRetrofit2-Gson%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.html</url>
      <content type="text"><![CDATA[Retrofit基本使用基本用法我们来实现一个最基本的请求Json结果的文件的Demo。 引入依赖首先新建一个工程，在app的build.gradle中加入以下依赖： 123compile 'com.squareup.retrofit2:retrofit:2.2.0'compile 'com.google.code.gson:gson:2.7'compile 'com.squareup.retrofit2:converter-gson:2.0.2' 第一行自然是引入retrofit2啦，由于我们需要解析Json文本，Retrofit为我们提供了一个很方便的工具Converter。我们在获取网络资源后，通常需要对其内容进行解析，这个步骤可以利用线程的解析库来实现，并且Retrofit为几个常见的解析库提供了相应了Converter类。Gson是一个常见的Json解析库，Retrofit为它提供了Converter。第二行和第三行就是分别引入Gson和GsonConverterFactory的，稍后用到这个Converter的时候会再提一下的。 然后，我们随便上传一个Json文件在GitHub上，这里大家就自己弄啦。 我传了一个Json文件上去，地址为：https://raw.githubusercontent.com/xiaoniaojun/xiaoniaojun.github.io/master/test.json 12345&#123;age: 22,name: "Bird",phoneNumber: "13550626331"&#125; 记下这个地址，后面的构建会用到。注意：这个地址可能随时失效，请大家自己动手上传。 构建请求接口12345// https://raw.githubusercontent.com/xiaoniaojun/xiaoniaojun.github.io/master/test.jsonpublic interface GitHub &#123; @GET("&#123;userId&#125;/&#123;userId&#125;.github.io/master/&#123;fileName&#125;") Call&lt;User&gt; results(@Path("userId") String userId, @Path("fileName") String fileName);&#125; 大家可以把目标链接用注释写在上面，方便写代码的时候对照。 @Get注解中编写请求链接的基本结构，其中用{}括起来的，表示替换块(replacation block)，可以在注解的方法中，通过@Path标注的参数，进行替换。这里有两点需要注意，替换块中的字符串需要和@Path参数的字符串相同才能被识别。其次，Call，这个T表示response返回的类型。 这个接口实现的请求方法，会在之后被用来构造Call对象，而这个Call对象就是封装好的可调用对象，它是后面实际执行请求所需要的关键对象。我们可以使用call进行异步或同步调用。最后，我们会将这一系列步骤串起来总结。 为json定义BeanCall中的泛型类型为User，它是我们自定义的Bean。所谓Bean，我的理解就是一个包含Json对象所有字段的数据模型类，是一个纯java类。这里，我们简单地定义一下这个User Bean。 1234567891011public class User &#123; private String name; private int age; private String phoneNumber; public User(String name, int age, String phoneNumber) &#123; this.name = name; this.age = age; this.phoneNumber = phoneNumber; &#125;&#125; 代码很简单，就是包含了Json中出现的所有字段。 构建GitHub实例我们的目的是，最终实现网络请求，刚刚说到，请求的必须品是Call实例，而Call实例是我们定义的接口方法results()返回的。所以，我们需要来构建接口类型GitHub的实例。 我们需要利用retrofit提供的建造者方法一步一步地来构建出刚刚定义的接口类型的实例。 123456Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://raw.githubusercontent.com/") .addConverterFactory(GsonConverterFactory.create()) .build(); GitHub gitHub = retrofit.create(GitHub.class); 首先，我们通过建造者模式的方法Retrofit.Builder()，一步一步构造retrofit对象。 baseUrl()方法用于指定基地址； addConverterFactroy()方法用于设置Converter。刚刚我们已经谈过它了，它的作用就是，在response返回对象的时候，将response的body体利用Gson来解析； 最后以build()方法结束建造。 这样retrofit就配置完成了，接下来调用retrofit的create方法，传入GitHub.class对象，来生成GitHub的实例。 最后一步得到了GitHub实例，我们就可以调用在GitHub接口中定义的results方法来获取Call了。在results方法中，我们定义了构造请求链接的参数userId，以及FileName，这里我们传入”xiaoniaojun”和”test.json”，就可以得到构造好的Call对象。 此时，Call的大刀早已饥渴难耐，就等着执行网络请求了！ Retrofit为我们提供了两个方法，execute和enqueue，分别是同步/异步调用。同步调用就是直接调用，阻塞到返回，没什么好说的；异步调用需要传入一个Callback对象，用来获取返回值。 123456789101112Call&lt;User&gt; xiaoniaojun = gitHub.results("xiaoniaojun", "test.json"); xiaoniaojun.enqueue(new Callback&lt;User&gt;() &#123; @Override public void onResponse(Call&lt;User&gt; call, Response&lt;User&gt; response) &#123; User responseUser = response.body(); &#125; @Override public void onFailure(Call&lt;User&gt; call, Throwable t) &#123; t.printStackTrace(); &#125; &#125;); Callback接口实现了两个方法，onFailure表示请求失败，返回call对象和Throwable；onResponse表示请求成功，返回call对象和response，这个response就是返回结果啦。 这里要说一下这个call对象有什么用。在Retrofit中，Call只能被执行一次，所以想要再次执行，就必须重新建立一个Call，或者，使用从回调中获取的这个call，它是可以被调用的。 基本使用步骤总结这里我们来简单总结一下，使用Retrofit来进行一个完整网络请求的步骤： 建立构造请求对象的接口； 使用Retrofit.Builder()来build Retrofit实例。 利用这个Retrofit实例的create方法，传入接口.class，创建出接口的实例。 利用这个实例中，我们在接口内实现的那个方法，传入构造请求链接的相关变量，创建出Call对象。 利用这个Call对象进行同步或异步调用，异步调用最后都需要构造一个匿名内部类Callback，实现onResponse回调和onFailure对返回结果进行处理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Retrofit文档翻译]]></title>
      <url>%2F2017%2F03%2F13%2FRetrofit%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91.html</url>
      <content type="text"><![CDATA[引入Retrofit1compile 'com.squareup.retrofit2:retrofit:2.2.0' 设置Retrofit通过Retrofit类可以让你的API接口转换成callable对象。默认情况下，Retrofit的默认设置已经足够应对大多数情况，不过你也可以进行自定义。 CONVERTERS默认情况下，Retrofit只能将HTTP体反序列化成OkHttp的ResponseBody类型，并且，默认只能接受RequestBody类型的@Body。 Converters可以帮我们获得对其他类型的支持。一共有六个converter可以使用，它们可以帮你适配六大常见的库。 Gson: com.squareup.retrofit2:converter-gson Jackson: com.squareup.retrofit2:converter-jackson Moshi: com.squareup.retrofit2:converter-moshi Protobuf: com.squareup.retrofit2:converter-protobuf Wire: com.squareup.retrofit2:converter-wire Simple XML: com.squareup.retrofit2:converter-simplexml 下面是一个使用GsonConverterFactory类来生成GitHubService的实现接口的例子，使用Gson库来反实例化。 123456Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.github.com") .addConverterFactory(GsonConverterFactory.create()) .build(); GitHubService service = retrofit.create(GitHubService.class); 自定义Coverters建立自己的adapter时，扩展Converter.Factory类并且传递一个它的实例进去。 Retrofit Api接口方法上的注解以及注解参数表明如何处理一个request。 REQUEST方法每个方法必须有一个HTTP注解用以提供请求方法和相对URL。一共有五个内建注解：GET、POST、PUT、DELETE和HEAD。资源的相对URL在注解中被指定。 1@GET("users/list") 你也可以在URL中指定请求参数。 12345@GET("user/list?sort=desc")``` ##URL MANIPULATION可以在方法中，动态地使用替换块(replacement block)和关联参数来替换URL中的参数。一个替换块是一个由字母和数字组成的用&#123;&#125;围起来的字符串，与其相关联的参数必须使用`@Path`注解来声明，并且注解参数要和替换块字符串相同。 @GET(“group/{id}/users”)Call]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[怒怼Rxjava2(RxAndroid)(1)]]></title>
      <url>%2F2017%2F03%2F12%2F%E6%80%92%E6%80%BCRxjava2-RxAndroid-1.html</url>
      <content type="text"><![CDATA[怒怼RxJava 2(RxAndroid) - （1）ReactiveX是一个异步编程库，它的风格是使用函数式观察者模式流来构建异步代码。这里主要讨论的是RxJava 2和RxAndroid。 ##基本工作模式 Rx的核心思想是观察者模式模型，当然观察者和被观察就是最核心的两个对象。 Rxjava2中，为了解决背压(BackPressure)问题，引入了两种观察者模式。 背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略《关于 RxJava 最友好的文章—— RxJava 2.0 全新来袭》 其中Observable和Flowable是观察者，而Observer和Subscribe是其各自对应的被观察者。 Rx的基本工作流程是，建立Observable，在里面提供数据、对象、事件等等，之后订阅被观察者，向被观察者传递这些东西，由被观察者进行处理。 创建ObservablesRx中，对象构建基于Build模式，所有的工作会在build链结束后才会被执行。Rx提供了许多创建Observables的方法： Create 最常规的创建方法，在RxAndroid中，参数需要传递一个ObservableOnSubscribe&lt;T&gt;对象。ObservableOnSubscribe&lt;T&gt;是一个接口，需要实现public void subscribe(final ObservableEmitter&lt;String&gt; e) throws Exception方法，它会提供一个Emitter对象。这个方法用来订阅被观察者，被观察者通过Emitter将数据传递给被观察者。 Q:怎么回事被观察者去订阅观察者呢？A:因为依靠这个逻辑，可以让被观察者实现一个完整的流式编程。 Defer会将创建Observable延迟被订阅时，传递一个Callable&lt;? extends ObservableOnSubscribe&lt;?&gt;&gt;。这个意思应该很明确。 Empty/Never/Throw字面意义。 From将其他对象或者数据容器转换成Observable。在RxJava中，from方法是一系列方法集。比如fromArray,fromCallable,fromInterable等。 Interval周期性地产生一系列依次递增的&lt;? extends Long&gt;类型的值emit。 Just发送一个/一系列对象emit给被观察者。最简单的方法。 Range产生一个范围的整形值emit给观察者。 Repeat 周期性重复产生一个或一组对象emit。 Timer在一定延迟之后emit单个对象。 A Demo Using Rx我们用一个实际例子来体验Rxjava的基本使用方法。在这个实例中，我们要做一个奶酪搜索app，在输入框中输入关键字，然后在准备好的数据集中搜索包含这些关键字的奶酪品牌。 准备工作首先，在主界面Layout设计UI，如图：然后，我们先封装一个BaseSearchActivity。在这个BaseSearchActivity中做以下封装： 持有各个控件的引用； 初始化RecyclerView，和设置它的内容的方法； 获取CheeseSearchEngine，搜索工具类的实例； 显示/隐藏ProgressBar； 获取数据集 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class CheeseActivity extends BaseSearchActivity &#123; private Disposable mDisposable; @Override protected void onStart() &#123; super.onStart(); Observable&lt;String&gt; textChangeStream = createTextChangeObservable(); Observable&lt;String&gt; buttonClickStream = createButtonClickObservable(); Observable&lt;String&gt; searchTextObservable = Observable.merge(textChangeStream, buttonClickStream); mDisposable = searchTextObservable .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; showProgressBar(); &#125; &#125;) .observeOn(Schedulers.io()) .map(new Function&lt;String, List&lt;String&gt;&gt;() &#123; @Override public List&lt;String&gt; apply(String query) throws Exception &#123; return mCheeseSearchEngine.search(query); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;List&lt;String&gt;&gt;() &#123; @Override public void accept(List&lt;String&gt; result) throws Exception &#123; hideProgressBar(); showResult(result); &#125; &#125;); &#125; private Observable&lt;String&gt; createButtonClickObservable()&#123; return Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(final ObservableEmitter&lt;String&gt; e) throws Exception &#123; mSearchButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; e.onNext(mQueryEditText.getText().toString()); &#125; &#125;); e.setCancellable(new Cancellable() &#123; @Override public void cancel() throws Exception &#123; mSearchButton.setOnClickListener(null); &#125; &#125;); &#125; &#125;); &#125; private Observable&lt;String&gt; createTextChangeObservable() &#123; Observable&lt;String&gt; textChangeObservable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(final ObservableEmitter&lt;String&gt; e) throws Exception &#123; final TextWatcher watcher = new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123;&#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123;&#125; @Override public void afterTextChanged(Editable s) &#123; e.onNext(s.toString()); &#125; &#125;; mQueryEditText.addTextChangedListener(watcher); e.setCancellable(new Cancellable() &#123; @Override public void cancel() throws Exception &#123; mQueryEditText.removeTextChangedListener(watcher); &#125; &#125;); &#125; &#125;); return textChangeObservable.filter(new Predicate&lt;String&gt;() &#123; @Override public boolean test(String query) throws Exception &#123; return query.length() &gt;= 2; &#125; // 防抖动 &#125;).debounce(1000, TimeUnit.MILLISECONDS); &#125; @Override protected void onStop() &#123; super.onStop(); if (!mDisposable.isDisposed()) &#123; mDisposable.dispose(); &#125; &#125;&#125; 其中，工具类CheeseSearchEngine的实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class CheeseActivity extends BaseSearchActivity &#123; private Disposable mDisposable; @Override protected void onStart() &#123; super.onStart(); Observable&lt;String&gt; textChangeStream = createTextChangeObservable(); Observable&lt;String&gt; buttonClickStream = createButtonClickObservable(); Observable&lt;String&gt; searchTextObservable = Observable.merge(textChangeStream, buttonClickStream); mDisposable = searchTextObservable .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; showProgressBar(); &#125; &#125;) .observeOn(Schedulers.io()) .map(new Function&lt;String, List&lt;String&gt;&gt;() &#123; @Override public List&lt;String&gt; apply(String query) throws Exception &#123; return mCheeseSearchEngine.search(query); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;List&lt;String&gt;&gt;() &#123; @Override public void accept(List&lt;String&gt; result) throws Exception &#123; hideProgressBar(); showResult(result); &#125; &#125;); &#125; private Observable&lt;String&gt; createButtonClickObservable()&#123; return Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(final ObservableEmitter&lt;String&gt; e) throws Exception &#123; mSearchButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; e.onNext(mQueryEditText.getText().toString()); &#125; &#125;); e.setCancellable(new Cancellable() &#123; @Override public void cancel() throws Exception &#123; mSearchButton.setOnClickListener(null); &#125; &#125;); &#125; &#125;); &#125; private Observable&lt;String&gt; createTextChangeObservable() &#123; Observable&lt;String&gt; textChangeObservable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(final ObservableEmitter&lt;String&gt; e) throws Exception &#123; final TextWatcher watcher = new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123;&#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123;&#125; @Override public void afterTextChanged(Editable s) &#123; e.onNext(s.toString()); &#125; &#125;; mQueryEditText.addTextChangedListener(watcher); e.setCancellable(new Cancellable() &#123; @Override public void cancel() throws Exception &#123; mQueryEditText.removeTextChangedListener(watcher); &#125; &#125;); &#125; &#125;); return textChangeObservable.filter(new Predicate&lt;String&gt;() &#123; @Override public boolean test(String query) throws Exception &#123; return query.length() &gt;= 2; &#125; // 防抖动 &#125;).debounce(1000, TimeUnit.MILLISECONDS); &#125; @Override protected void onStop() &#123; super.onStop(); if (!mDisposable.isDisposed()) &#123; mDisposable.dispose(); &#125; &#125;&#125; 这里顺便再给出Adapter的实现代码： 1234567891011121314151617181920212223242526272829303132333435public class CheeseAdapter extends RecyclerView.Adapter&lt;CheeseAdapter.CheeseViewHolder&gt; &#123; private List&lt;String&gt; mCheeses; @Override public CheeseViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; LayoutInflater layoutInflater = LayoutInflater.from(parent.getContext()); View view = layoutInflater.inflate(android.R.layout.simple_list_item_1, parent, false); return new CheeseViewHolder(view); &#125; @Override public void onBindViewHolder(CheeseViewHolder holder, int position) &#123; holder.title.setText(mCheeses.get(position)); &#125; @Override public int getItemCount() &#123; return mCheeses == null ? 0 : mCheeses.size(); &#125; public void setCheeses(List&lt;String&gt; cheeses) &#123; mCheeses = cheeses; notifyDataSetChanged(); &#125; public static class CheeseViewHolder extends RecyclerView.ViewHolder &#123; public final TextView title; public CheeseViewHolder(View itemView) &#123; super(itemView); title = (TextView) itemView.findViewById(android.R.id.text1); &#125; &#125;&#125; 准备工作就做完了，然后，我们再新建一个CheeseActivity类，并将其设置为启动Activity。我们的代码实现将在这个Activity中进行。 为按钮绑定搜索事件我们首先来实现，如何来实现点击按钮进行搜索。 基于观察者模式的思维，我们可以这样想：在被观察者中注册按钮事件，当点击按钮时，将输入框中的内容emit给被观察者。在被观察者中，我们接受到这个emit内容，并进行搜索任务。 按照这个逻辑，我们首先来建立被观察者。 12345678910111213141516171819private Observable&lt;String&gt; createOnClickObservable() &#123; return Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(final ObservableEmitter&lt;String&gt; e) throws Exception &#123; mSearchButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; e.onNext(String.valueOf(mQueryEditText.getText())); &#125; &#125;); e.setCancellable(new Cancellable() &#123; @Override public void cancel() throws Exception &#123; mSearchButton.setOnClickListener(null); &#125; &#125;); &#125; &#125;); &#125; 在CheeseActivity中添加一个私有方法来构建Observable。其中，T代表我们要emit的内容的类型。我们使用create方法来创建，这里要实现ObservableOnSubscribe接口中的subscribe方法。该方法是订阅观察者的方法，在其中我们需要手动实现emit。 需要注意的是，需要在e.setCancellable中将Listener清除。当我们手动取消订阅时，如果没有将Listener清除，这个Listener就会导致整个引用链无法被GC。 接下来，我们要设置观察者接受到emit内容后的逻辑了。我们重写onStart()方法，在其中做完整的初始化工作： 123456789101112@Overrideprotected void onStart() &#123; super.onStart(); Observable&lt;String&gt; onClickObservable = createOnClickObservable(); onClickObservable.subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String query) throws Exception &#123; List&lt;String&gt; result = mCheeseSearchEngine.search(query); showResult(result); &#125; &#125;);&#125; 首先我们调用createOnClickObservable()方法创建Observable对象，然后开始链式build整个观察者模式。这里我们使用subscribe订阅观察者，注意，是订阅观察者！subscribe的标准参数是一个Observer类型接口，它的实现如下： 12345678910public interface Observer&lt;T&gt; &#123; //在订阅后发送数据之前会先回调整个方法，使用d可以取消订阅 void onSubscribe(Disposable d); // 用来接收emit过来的数值 void onNext(T value); // 出错会回调这个方法 void onError(Throwable e); // 取消订阅会回调这个方法 void onComplete();&#125; 不过，我们这里使用的Consumer接口是一个简化的观察者，它的实现： 1234public interface Consumer&lt;T&gt; &#123; // 接收emit参数，可以抛出异常 void accept(T t) throws Exception;&#125; 大多数情况下都可以使用这个简化版本来处理emit过来的值。 不过，我们这里偷了个懒。如果按照正宗的函数式编程思想，emit传递过来的值是String类型，而我们交给界面显示的值是一个List，这两个不是相同的类型。这种情况，我们应该使用Map操作符来执行类型转换。 操作符来执行类型转换。 上面的代码实现可以这样， 123456789101112131415161718@Override protected void onStart() &#123; super.onStart(); Observable&lt;String&gt; onClickObservable = createOnClickObservable(); onClickObservable .map(new Function&lt;String, List&lt;String&gt;&gt;() &#123; @Override public List&lt;String&gt; apply(String query) throws Exception &#123; return mCheeseSearchEngine.search(query); &#125; &#125;) .subscribe(new Consumer&lt;List&lt;String&gt;&gt;() &#123; @Override public void accept(List&lt;String&gt; cheese) throws Exception &#123; showResult(cheese); &#125; &#125;); &#125; 关于函数式编程的思想不是本文的重点，这里就不多说了，有兴趣可以自行查阅相关资料。 我们的代码是运行成功了，结果也没有问题。可是，因为查询操作通常都是很耗时的，按下按钮后，我们也会卡在主界面无法操作。并且，Android Monitor也给出了类似下面这样的提示，通常，这种提示会在主线程长期无法响应时出现。所以我们要避免这种情况，就要使用多线程。 Rxjava一个最牛逼的地方就在于，可以极其方便地将代码执行在不同线程中。我们再来重构一下我们的代码。 1234567891011121314151617181920@Override protected void onStart() &#123; super.onStart(); Observable&lt;String&gt; onClickObservable = createOnClickObservable(); onClickObservable .observeOn(Schedulers.io()) .map(new Function&lt;String, List&lt;String&gt;&gt;() &#123; @Override public List&lt;String&gt; apply(String query) throws Exception &#123; return mCheeseSearchEngine.search(query); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;List&lt;String&gt;&gt;() &#123; @Override public void accept(List&lt;String&gt; cheese) throws Exception &#123; showResult(cheese); &#125; &#125;); &#125; 可以看到，我们在build链中添加了两个observeOn()方法。这个方法用于指定接下来的操作所在的线程。Rx为我们预先定义了很多Scheduler，代表执行的线程环境，我们可以很方便地使用它们。比如Scheduler.io()就代表在io线程中执行，AndroidScheduler.mainThread()表示主线程。 顿时异步编程如同儿戏一般简单，这就是Rx的一个亮点之一。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Dagger2使用手册]]></title>
      <url>%2F2017%2F03%2F11%2FDagger2%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.html</url>
      <content type="text"><![CDATA[参考文章：Dagger2入门，以初学者的角度 在项目中引入Dagger2step 1. 在项目build.gradle文件中添加apt插件： 1234567891011121314buildscript &#123; ... dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files // 添加apt插件 classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8' &#125;&#125;... step2. 在app目录下的build.gradle文件中添加： 123456789101112//应用apt插件apply plugin: 'com.neenbedankt.android-apt'...dependencies &#123; ... // 引入dagger2 compile 'com.google.dagger:dagger:2.4' apt 'com.google.dagger:dagger-compiler:2.4' //java注解 provided 'org.glassfish:javax.annotation:10.0-b28'&#125; 入门篇Dagger2基本用法 —— 使用Moudle类现在我们有个需求，要在MainActivity中使用Car对象。那么用依赖注入的方法要怎么实现呢？首先我们来看看其中较复杂但功能也较强大的方式是如何实现的： 1. 首先编写一个依赖对象类Car1234567891011121314151617181920public class Car &#123; private String car; public Car(String brand) &#123; this.car = brand; &#125; public String getCar() &#123; return this.car; &#125; public void setColor(String color) &#123; this.car = color; &#125; @Override public String toString() &#123; return "一辆" + this.car; &#125;&#125; 该类包含一个属性car。 2. 编写Moudle类Moudle类被用于向对象需求方MainActivity提供依赖对象。 12345678@Modulepublic class MainModule &#123; @Provides public Car getCar() &#123; Car car = new Car("BWM"); return car; &#125;&#125; 这就是一个简单的Module实现。注意到代码中有两个注解：@Module和@Provides。其中@Module用来向Dagger2标明这是一个Module类，@Provides是用来标记Module类中，哪些方法是用来提供依赖对象的。后面我们还会编写一个Component接口，需求对象需要实现这个Component接口才可以被注入对象。而当Component实现类需要依赖对象时，它会根据Moudle类中@Provides方法的返回值类型来选择应该调用哪个方法获取对象。 3. 编写Component接口1234@Component(modules=MainMoudle.class)public interface MainComponent &#123; void inject(MainActivity mainActivity);&#125; 同样，Component接口需要用@Component注解标注，但是@Component的注解具备更强大的功能，它有modules和dependencies两个属性，这两个属性的类型都是Class数组。modules是用来申明该Component含有几个Moudle，当Component需要某个依赖对象时，就会去这些Moudle类中寻找相应的@Provides方法。dependency属性，则是生命Component类的依赖关系，稍后再详细解释。 接口中的inject方法是干嘛的呢？inject方法被用来将需求对象MainActivity送入Component类，Component类会根据需求对象中声明的依赖关系来注入需求对象所需要的依赖对象。需求对象MainActivity中需要依赖对象Car，所以我们通过inject方法将MainActivity的实例传入到MainComponent中，MainComponent就会从MainModule中的getCar方法中获取实例，并将该实例赋值给MainActivity中声明的依赖对象字段。 需要注意的是，inject方法的参数不能用父类来接收。 4. 在需求对象中声明依赖关系12345678910111213141516public class MainActivity extends AppCompatActivity &#123; private TextView tvHello; @Inject Car car; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tvHello = (TextView) findViewById(R.id.tv_hello); MainComponent build = DaggerMainComponent.builder().mainMoudle(new MainModule()).build(); build.inject(this); tvHello.setText("我买了" + car); &#125;&#125; 上面代码中，@Inject注解用来声明依赖，Dagger2中所有的依赖对象都是通过@Inject注解声明的。但是，@Inject注解的字段不能是private和protected。 其次，Dagger2会帮我们自动生成Component的实现类。创建这个类时，需要提供Moudle类的实例。要强调的是，我们需要在编写完Component接口之后，使用rebuild重新生成项目，Dagger2才会帮我们创建好对应的类。 之后，将需求对象，此处为this，传递给inject方法。之后，你就会发现，@Inject注解的字段已经被赋值，而该对象就是我们在Moudle的getCar方法中创建的那个对象。 最简单的用法怎么tm这么麻烦？就tm赋个值就写这么多代码？怕是还不如不用依赖注入方便呢。别急，对于这种简单地依赖情形，我们还有更简单的方法。 创建依赖类12345678910public class Insurance &#123; @Inject public Insurance() &#123; &#125; @Override public String toString() &#123; return "一份保险"; &#125;&#125; 这次，我们直接在依赖类的构造函数上面添加了@Inject注解。当Component在所拥有的Moudle类中找不到需求方需要的类型时，Dagger2就会检查需要的类型有没有被@Inject声明的构造方法，有则用该构造方法去创建一个。 同样，要将这个对象注入到需求方中，也需要在需求方实现代码中添加字段声明并用@Inject注解。 123456789101112public class MainActivity extends AppCompatActivity &#123; ... @Inject Insurance insurance; ... @Override protect void onCreate(Bundle savedInstanceState) &#123; ... tvHello.setText("我买了" + car + "和" + insurance); &#125;&#125; 是不是很简单？那为什么不都用这种方法呢？不过，如果我们使用别人的jar包，是不能修改别人的代码去添加注解的，所以不得不通过Module类来提供对象。 应对依赖的依赖上面的例子中，我们创建的这些依赖类都不用依赖于其他的类。但是，如果需要依赖于其他依赖类，又要怎么使用呢？ 首先我们来创建一个类Driver： 123456789101112131415161718public class Driver &#123; private Car car; private String driver; public Driver(Car car,String name) &#123; this.car = car; driver = name; &#125; public Car getCar() &#123; return car; &#125; @Override public String toString() &#123; return "老司机" + driver + "有一辆" + car; &#125;&#125; 这个Driver类依赖于Car对象，如果我们要在MainActivity中需要注入Driver对象，又该怎么办呢？ 在Module类中增加Provide方法：首先我们会自然地想到在Moudle类中添加如下的方法： 12345@Providespublic Driver getDriver() &#123; Car car = new Car("BWM"); return new Driver("BWM","小明");&#125; 这样的确是可以的，不过我们之前就已经创建了一个提供Car对象的方法，能不能直接利用起来呢？Dagger2提供了这种功能，我们只需要在getDriver的方法中，添加Car参数，Dagger2会自动地像帮助需求对象查找依赖对象那样，找到该方法依赖的Car实例。所以我们的代码可以写成这样： 1234@Providespublic Driver getDriver(Car car) &#123; return new Driver(car,"小明");&#125; 这样，我们就可以在MainActivity注入依赖啦。 12345678910111213141516public class MainActivity extends AppCompatActivity &#123; private TextView mTVHello; @Inject Driver driver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTVHello = (TextView) findViewById(R.id.tv_Hello); MainComponent build = DaggerMainComponent.builder().mainModule(new MainModule()).build(); build.inject(this); mTVHello.setText(driver.toString()); &#125;&#125; 不光如此，带有@Inject注解的构造函数，若是需要依赖于其他对象，Dagger2也会根据这个规则为你自动注入。 Dagger2依赖提供规则总结123456789101112131415161718192021222324//伪代码function(依赖对象) &#123; if (查找Moudle类中是否存在创建依赖对象的方法)&#123; //如果存在 if (检查该方法是否存在参数) &#123; //如果有参数，则递归调用寻找注入方法 function(参数中的依赖对象) &#125; else &#123; //如果没有参数，就直接初始化该实例 return 成功注入一次 &#125; &#125; else &#123; // 如果不存在创建依赖的方法，就查找带Inject注解的构造函数，看是构造函数是否存在参数 if (存在参数) &#123; // 存在参数就去找能否注入 function(参数中的对象) &#125; else &#123; // 不存参数，直接初始化 return 成功注入一次 &#125; &#125;&#125; 可以看到，Dagger2会递归地提供依赖。 进阶篇@Name和@Qulifier@Named最近小明发了大财，于是买了一辆梦寐以求的限量版法拉利。 12345678910//在Module类中修改@Providespublic Car getBWMCar() &#123; return new Car("BWM");&#125;@Providespublic Car getFerrariCar() &#123; return new Car("限量版法拉利");&#125; 我们将小明的法拉利添加到了Moudle中。不过，我们之前提到过，Dagger2是依靠返回值来确定注入对象的。现在我们有两台Car，小明要怎么开上自己最新买的法拉利呢？ Dagger2为我们提供了@Name注解。它有一个参数value，用来区别相同类型的依赖对象。下面的代码展示了如何使用@Name注解： 123456789101112//在Module中@Provides@Named("BWM")public Car getBWMCar() &#123; return new Car("BWM");&#125;@Provides@Named("Ferrari")public Car getFerrariCar() &#123; return new Car("限量版法拉利");&#125; 可以看到，通过@Named注解，我们为相同返回类型的Provides方法，命名加以区分。 在Module类中，也通过@Named注解来标注该调用哪个提供方法： 12345678910111213141516public class MainActivity extends AppCompatActivity &#123; private TextView mTVHello; @Inject @Named("BWM") Car bwmCar; @Inject @Named("Ferrari") Car ferrariCar; @Override protected void onCreate(Bundle savedInstanceState) &#123; ... mTVHello.setText("小明现在有" + bwmCar + "和" + ferrariCar); &#125;&#125; @Qulifier@Qulifier的功能和@Name一样，并且，@Name继承于@Qulifier。那么如何使用@Qulifier呢？需要自定义注解： 1234@Qualifier@Retention(RetentionPolicy.RUNTIME)public @interface BWM() &#123;&#125; 效果和@Named(value)是一样的。在Module中的Provide方法中标注@BWM注解就可以了。 另外，这个两个注解可以用在依赖参数上，比如 1234@Providespublic Driver getDriver(@Named("Ferrari") car) &#123; return new Driver(car, "小明");&#125; @Singleton和@Scope@Singleton小明出车祸了，法拉利撞得面目全非，不过幸好人没出事，没几天就出院了。出院的小明回到家中，看到家门口有一辆和自己一模一样的法拉利，竟然完好无损！这是怎么回事呢？ Module类中的小明和法拉利： 123456789101112@Modulepublic class MainModule &#123; @Provides public Car getFerrariCar() &#123; return new Car("限量版法拉利"); &#125; @Provides public Driver getDriver(Car car) &#123; return new Driver(car, "小明"); &#125;&#125; 接着在MainActivity中声明： 123456789101112131415161718public class MainActivity extends AppCompatActivity &#123; private TextView mTVHello; @Inject Car car; @Inject Driver driver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTVHello = (TextView) findViewById(R.id.tv_Hello); MainComponent build = DaggerMainComponent.builder().mainModule(new MainModule()).build(); build.inject(this); mTVHello.setText("这个car是小明的法拉利吗？"+(car == driver.getCar())); &#125;&#125; 原来这辆车是隔壁老王的。 通过这个例子可以发现，我们在MainActivity中注入的Car和Driver中注入的Car并不是同一个对象。在注入过程中，调用了两次创建依赖对象的方法。 那么，如果需要MainActivity中的Car对象和Driver中的Car对象是同一个对象，又要怎么办呢？Dagger2中，使用@Singleton注解可以实现这个需求: 12345@Singleton@Providespublic Car getFerrariCar() &#123; return new Car("限量版法拉利");&#125; 同时，需要在MainComponent接口中添加该注解： 12345@Singleton@Component(modules=MainModule.class)public interface MainComponent&#123; void inject(MainActivity mainActivity);&#125; @Scope@Scope用来申明作用范围，其实@Singleton就是基于它来实现的。使用它的时候，也需要自定义注解： 1234@Scope@Retention(RetentionPolicy.RUNTIME)public @interface PerActivity &#123;&#125; 之后将Module中的Provide方法打上@PerActivity，就可以将该方法包含在PerActivity作用范围之内。别忘了在Component接口上也要使用这个注解 这个作用范围有什么用呢？在Dagger2里面，同一作用范围内的Provide方法，在需要生成多个依赖对象时，都只会被调用一次，因此，需求方得到的以来对象实例就会是同一个实例。(只有在Moudle类中声明了作用范围的Provide方法才会有这样的行为) Dagger2提供这个注解的目的在于可以让我们自定义作用范围名，提高代码的可读性。 **Note： 在通过构造函数提供依赖的方式中，需要将作用范围在类名上注解，而不是在构造方法上。 只有在同一个Component实例下提供依赖才能实现Singleton。** 组件依赖Dependencies开发中，如果遇到工具类这种，在整个APP生命周期中都是单例的情形该怎么处理呢？ 首先添加一个工具类： 12345public class CarMarket &#123; public Driver deal(Car car, String buyer) &#123; return new Driver(car, buyer); &#125;&#125; 接着建立一个BaseModule来提供工具类： 12345678@Modulepublic class BaseModule &#123; @Singleton @Provides public CarMarket getCarMarket() &#123; return new CarMarket(); &#125;&#125; 再创建一个接口： 12345@Singleton@Component(modules = BaseModule.class)public interface BaseComponent &#123; ClothHandler getClothHandler();&#125; Q:这个Component为什么没有inject方法呢？A:因为BaseComponent这个接口是给其他Component提供依赖的，具体注入由子Component类提供。这里仅仅是告诉其子类BaseComponent能提供这个ClothHandler对象，因此，它不需要inject方法。 接下来，在MainComponent和SecondComponent两个子类中声明依赖。 1234567891011@PerActivity@Component(modules=MainModule.class,dependencies=BaseComponent.class)public interface MainComponent &#123; void inject(MainActivity mainActivity);&#125;@PerActivity@Component(modules=SecondModule.class,dependencies=BaseComponent.class)public interface SecondComponent &#123; void inject(SecondActivity secondActivity);&#125; 此时，rebuild工程就可以看到，创建MainComponent和SecondComponent实例的时候，多了一个baseComponent方法。 我们需要为这个BaseComponent传递一个实例。如果要保证两个子Component能获取同一个BaseComponent实例，有一种方法是：自定义一个Application类。 Q:如何保证某个对象在App生命周期中只有一个实例？A:使用静态工厂，或者自定义一个Application类。 12345678910111213141516// 在Application中持有baseComponent，// 从而获得一个在整个App生命周期内仅有的baseComponent实例，// 这样做还有个隐含好处：// BaseModule中需要Context对象的时候，可以直接传入this。public class MyApplication extends Application &#123; private BaseComponent baseComponent; @Override public void onCreate() &#123; super.onCreate(); baseComponent = DaggerBaseComponent.builder().baseModule(new BaseModule()).build(); &#125; public BaseComponent getBaseComponent() &#123; return baseComponent; &#125; &#125; 创建完自定义类后，还需要在AndroidManifest.xml中声明新建的MyApplication: 12345...&lt;application android:name = ".MyApplication"... 接下来，在MainActivity和SecondActivity中，只需要在构建子Component实例中这样调用就行了: 1MainComponent build = DaggerMainComponent.builder().baseComponent((MyApplication)getApplication()).getBaseComponent()) @Subcomponent注解@Subcomponent注解和dependencies类似，但是@Subcomponent使用起来有点不同，需要在父组件(BaseComponent)中声明一个返回值为子组件（SubComponent）的方法。当子组件需要什么Moudle时，就在该方法中添加该类型的参数： 子组件接口应该改为使用@Subcomponent 12345@PerActivity@Subcomponent(modules=MainModule.class)public interface SubComponent &#123; void inject(MainActivity activity);&#125; 在父组件中需要声明一个提供子组件的方法： 1234567@Singleton@Component(modules=BaseModule.class)public interface BaseComponent &#123; CarMarket getCarMarket(); // @Subcomponent关键点 SubComponent getSubComponent(MainModule module);&#125; 之后调用注入的时候，指定要使用的Module就行了。 12MyApplication application = (MyApplication) getApplication(); application.getBaseComponent().getSubComponent(new MainModule()).inject(this); 使用这个方法同样可以实现单例，因为BaseComponent是同一个实例。 ##Lazy和Provider包装容器这两个容器是用来包装依赖对象的。注入时，如果用这两个容器包装依赖对象，Lazy容器懒加载方式就会只在你需要用到该依赖对象的时候才会去获取一个；而Provider容器的对象不光具有Lazy特性，而且每次要用到的时候，都会重新调用生成依赖对象的方法注入。 12345//在需求类中@InjectLazy&lt;Car&gt; car;@InjectProvider&lt;Driver&gt; driver; 不过，如果声明了单例，Provider也就失去了意义。 ##Component生命周期一般情况下，都是在Activity中的onCreate方法中创建Component实例，再调用inject完成依赖注入。 在onCreate()方法调用完成之后，Component实例就会因为没有被引用而被GC，其中Module实例也会被一并回收。不过，使用Lazy和Provider时，与该依赖对象有关的Module实例会被引用，这个Moudle实例将不会被回收。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android内存泄漏分析]]></title>
      <url>%2F2017%2F03%2F10%2FAndroid%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90.html</url>
      <content type="text"><![CDATA[具体的垃圾回收机制四种引用类型的介绍 强引用（Strong Reference）：JVM宁可抛出OOM，也不会让GC回收具有强引用的对象； 软引用（Soft Reference）：只有在内存空间不足时，才被回收的对象； 软引用（Weak Reference）：在GC时，一旦发现了只具有若引用的对象，不管当前内存空间是否充足，都会回收它的内存； 虚引用（Phantom Reference）：任何时候都可以被GC回收。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否需要回收。 我们常说的内存泄漏是指new出来的Object无法被GC回收，即为强引用。 常见内存泄漏案例case1.单例造成的内存泄漏单利的特性导致其生命周期同应用一样长。解决方案： 1.将该属性的引用方式改为弱引用；2.如果传入Context，使用ApplicationContext。 例子： 泄漏代码片段 1234567891011121314151617181920private static ScrollHelper mInstance;private ScrollHelper() &#123;&#125;public static ScrollHelper getInstance()&#123; if (mInstance == null) &#123; synchronized (ScrollHelper.class) &#123; if (mInstance == null) &#123; mInstance = new ScrollHelper(); &#125; &#125; &#125; return mInstance;&#125;/*** 被单击的View*/private View mScrolledView = null;public void setScrolledView(View scrolledView) &#123; mScrolledView = scrolledView;&#125; 使用弱引用WeakReference之后： 1234567891011121314151617181920private static ScrollHelper mInstance;private ScrollHelper() &#123;&#125;public static ScrollHelper getInstance()&#123; if (mInstance == null) &#123; synchronized (ScrollHelper.class) &#123; if (mInstance == null) &#123; mInstance = new ScrollHelper(); &#125; &#125; &#125; return mInstance;&#125;/*** 被单击的View*/private WeakReference&lt;View&gt; mScrolledViewWeakRef = null;public void setScrolledView(View scrolledView) &#123; mScrolledViewWeakRef = new WeakReference&lt;View&gt;(scrolledView);&#125; case 2. InnerClass匿名内部类在Java中，非静态内部类和匿名类都会潜在地引用它们所属的外部类。如果它们内部做了一些耗时操作，就会造成外围对象不会被回收，从而导致内存泄漏。但是静态内部类却不会。 解决方案： 1.将内部类改为静态内部类；2.如果有强引用Activity中的属性，则将该属性改为弱引用；3.如果允许，尽可能在Activity执行onDestory时，结束掉这些耗时任务。 例子： 1234567891011121314151617181920212223public class LeakAct extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.aty_leak); test(); &#125; //这儿发生泄漏 public void test() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125;&#125; 改为静态匿名内部类： 1234567891011121314151617181920212223public class LeakAct extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.aty_leak); test(); &#125; //加上static，变成静态匿名内部类 public static void test() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125;&#125; Case 3. Activity Context 使用不正确在Android中应用程序通常可以使用两种Context对象：Activity和Application。当类或方法需要Context对象的时候常见的做法就是使用第一个作为Context参数。这就意味着View对象对整个Activity保持引用，因此也就保持对Activity的所有的引用。 假设一个场景，当应用程序有个比较大的Bitmap类型的图片，每次旋转都重新加载图片，所用时间较多。为了提高屏幕旋转时Activity的创建速度，最简单的方法就是将这个Bitmap对象用Static修饰。当一个Drawable绑定在View上，实际上这个View对象就会成为这份Drawable的一个Callback成员变量。而静态变量的生命周期要长于Activity。导致了屏幕旋转时，Activity无法被回收，而造成内存泄漏。解决方案：1.使用ApplicationContext代替ActivityContext，因为ApplicationContext会随着应用程序的存在而存在，而不依赖于Activity的生命周期；2.对Context的引用不要超过它本身的生命周期，慎重地对Context使用“static”关键字。Context里如果有线程，一定要在onDestroy（）里及时停掉。例子： 123456789101112private static Drawable sBackground;@Overrideprotected void onCreate(Bundle state) &#123; super.onCreate(state); TextView label = new TextView(this); label.setText("Leaks are bad"); if (sBackground == null) &#123; sBackground = getDrawable(R.drawable.large_bitmap); &#125; label.setBackgroundDrawable(sBackgroud); setContextView(label);&#125; 解决方案： 123456789101112private static Drawable sBackground;@Overrideprotect void onCreate(Bundle state) &#123; super.onCreate(state); TextView label = new TextView(this); label.setText("Leaks are bad"); if (sBackground == null) &#123; sBackground = getApplicationContext().getDrawable(R.drawable.large_bitmap); &#125; label.setBackgroundDrawable(sBackground); setContextView(label);&#125; case 4. Handler引起的内存泄漏当Handler中有延迟的任务或是等待执行的任务队列过长，由于消息持有对Handler的引用，而Handler又持有对其外部类的引用。这条引用关系会一直保持到消息得到处理，而导致了Activity无法被垃圾回收器回收，而导致了内存泄漏。解决方案：1.可以把Handler类放在单独的类文件中，或者使用静态内部类便可以避免泄漏；2.如果想在Handler内部去调用所在的Activity，那么可以在handler内部使用弱引用的方式去指向所在Activity。使用static+WeakReference的方式来达到断开Handler与Activity之间存在引用关系的目的。解决方案： 123456789@Overrideprotected void doOnDestroy() &#123; super.doOnDestory(); if (mHandler != null) &#123; mHandler.removeCallbackAndMessages(null); &#125; mHandler = null; mRenderCallback = null;&#125; case 5.注册监听器的泄漏系统服务可以通过Context.getSystemService获取，它们负责执行某些后台任务，或者为硬件提供访问接口。如果Context对象想要在服务内部的事件发生时被通知，那就需要把自己注册到服务的监听器中。然而，这会让服务持有Activity的引用，如果在Activity的onDestroy时没有释放掉引用就会内存泄漏。 解决方案： 1.使用ApplicationContext代替ActivityContext；2.在Activity执行onDestroy时，调用反注册； mSensorManager = (SensorManager) this.getSystemService(Context.SENSOR_SERVICE);解决方案：mSensorManager = (SensorManager) getApplicationContext().getSystemService(Context.SENSOR_SERVICE);下面是容易造成内存泄漏的系统服务：InputMethodManager imm = (InputMethod) context.getApplicationContext().getSystemService(Context.INPUT_METHOD_SERVICE);解决方案： 12345678910111213protected void onDetachedFromWindow() &#123; if (this.mActionShell != null) &#123; this.mActionShell.setOnClickListener((OnAreaClickListener)null); &#125; if (this.mButtonShell != null) &#123; this.mButtonShell.setOnClickListener((OnAreaClickListener)null); &#125; if (this.mCountShell != this.mCountShell) &#123; this.mCountShell.setOnClickListener((OnAreaClickListener)null); &#125; super.onDetachedFromWindow();&#125;&#125; case 6. Cursor，Stream没有close，View没有recyle资源性对象比如Cursor、File等往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于JVM中，还存在于JVM之外。如果我们仅仅是把它的引用设置为null，而不是调用其提供的接口关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如SQLiteCursor，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样效率太低了。因此，在使用完资源性对象后，应该调用对应的close()方法，将其关闭后，再设为null。在我们的程序退出时一定要确保我们的资源性对象已经关闭。 case 7. 集合中的对象没有清理造成的泄漏容器中的对象在不需要时，如果没有及时把对象的引用清理掉，这个集合就会越来越大。如果这个集合是static的话情况就更严重。所以在退出程序之前，要将集合里面的东西clear，然后设置为null，在退出程序。解决方案： 在Activity退出之前，将集合中的所有东西clear，然后置null，再退出程序。解决方法： 1234567private List&lt;EmotionPanelInfo&gt; data;public void onDestroy() &#123; if (data != null) &#123; data.clear(); data = null; &#125;&#125; case 8. WebView造成的泄漏当我们不再使用WebView对象时，应该调用它的destroy()函数来销毁它，并释放其内存，否则其占用的内存长期也不能被回收，从而造成内存泄漏。解决方案： 为webView开启另外一个进程，通过AIDL与主线程进行通信，WebView所在的进程可以根据业务需要选择合适的时机进行销毁，从而达到完整的内存释放。 case 9. 构造Adapter时，没有使用缓存的ConvertView初始时ListView会从Adapter中根据当前的屏幕布局实例化一定数量的View对象，同时ListView会将这些View对象缓存起来。当向上滚动ListView时，原先位于最上面的List Item的View对象会被回收，然后被用来构造新出现的最下面的List Item。这个构造过程就是由getView()方法完成的，getView()的第二个形参View ConvertView就是被缓存起来的List Item的View对象（初始化时缓存中没有View对象则ConvertView是null）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[走近科学：揭秘Context]]></title>
      <url>%2F2017%2F03%2F09%2F%E8%B5%B0%E8%BF%91%E7%A7%91%E5%AD%A6%EF%BC%9A%E6%8F%AD%E7%A7%98Context.html</url>
      <content type="text"><![CDATA[Activity可以new吗？Activity mActivity = new Activity();可能很多人没有想过这个问题：Activity可以new吗？本质上，Activity也是一个类，照理来说它应该符合Java的语法，可是上面那种用法到底有什么问题呢？ Android程序不像Java程序，随便写一个类，添加一个main()方法就能运行。Android是基于组件的应用设计模式，组件的运行需要有一个完整的Android工程环境。只有在这个环境下，Activity、Service等系统组件才能正常工作。不过这些组件并不能采取普通的Java对象创建的方式，new一下就能创建实例了。它们的建立需要有各自的上下文环境，而这就是我们要讨论的Context。 Context是维持Andoird程序各组件能正常工作的一个核心功能类。 Context到底是什么？Context的字面意思是“语境”、“上下文”，可以理解为当前对象在程序中的一个环境，一个与系统交互的过程。比如微信聊天，此时的context是指聊天界面以及相关的数据请求与传输。Context在加载资源、启动Activity、获取系统服务、创建View等操作都要参与。 那Android中的Context到底是什么呢？一个Activity就是一个Context，一个Service也是一个Context。Android设计者把“应用场景”抽象为了Context类，认为用户和操作系统的每一种交互都是一个场景。比如打电话、发短信、这些都是一个有界面的场景。还有一些没有界面的场景，比如后台运行的服务（Service）。一个应用程序可以认为是一个工作环境，用户在这个工作环境中会切换到不同的场景。它就像一个公司的前台秘书，可能需要接待客人，可能要打印文件，还可能要接听客户电话。而这些任务就可以称之为不同的场景，这个前台秘书可以称之为一个应用程序。 其实，Context也可以看做是一个应用与系统交互的中间层。在Android的源码中，对Context的注释文档说明： 它是一个抽象类，它的执行被Android系统所提供。它允许获取以应用为特征的资源和类型，是一个统领一些资源（应用程序环境变量等）的上下文。就是说，它描述一个应用程序环境的信息（即上下文）；是一个抽象类，Android提供了该抽象类的具体实现类；通过它我们可以获取应用程序的资源和类（包括应用级别操作，如启动Activity，发广播，接受Intent等）。 Context的实现类既然源码中说明了它是一个抽象类，那么肯定就有它的实现类咯。Context的实现类可以形成如下的关系图：Context类本身是一个纯抽象类，它有两个具体的实现子类：ContextImpl和ContextWrapper。熟悉设计模式的应该可以反应过来，其实就是个装饰者模式的类图。 其中ContextWrapper只是一个包装类。它的构造函数中必须包含一个真正的Context引用，同时ContextWrapper提供了attachBaseContext()用于给ContextWrapper对象中执行真正的Context对象。ContextWrapper中的方法都会被转向其所包含的真正的Context对象。 ContextThemeWrapper类的内部包含了与主题（Theme）相关的接口。这里说的主题就是指在AndroidManifest.xml中，通过android:theme为Application元素或者Activity元素指定的主题。当然，因为只有Activity有可视化界面，Service没有，所以只有Activity才需要主题，因此Service是直接继承与ContextWrapper的，Application同理。 而ContextImpl类才真正实现了Context中的所有方法。应用程序中调用的各种Context类的方法，其实现均来自于该类。 总结一下，ContextImpl是Context的具体实现类，ContextWrapper是Context的包装类。Activity，Application，Service虽然都继承自ContextWrapper，但它们在初始化时都会创建ContextImpl对象，由ContextImpl实现Context中的方法。 一个应用有几个Context？其实我们从关系图中就可以知道，在一个应用程序中，Context的具体实现类就是Activity、Service和Application。 于是，Context的数量 = Activity数量 + Service数量 + 1。 有人会问，Boradcast Receiver，Content Provider呢？它们并不是Context的子类，其所持有的Context都是其他地方传递过去的，所以并不增加Context总数。 Context到底能干什么？Context能实现的功能就太多了，弹出Toast、启动和操作四大组件、获取资源等等都需要Context。 Context作用域虽然Context地位崇高、能力强大，但是并不是随便拿一个Context就能为所欲为的。Context的具体是由ContextImpl实现的，因此绝大多数的场景中，Activity、Service、Application这三种Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity和弹出Dialog。因为一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成返回栈。而Dialog则必须在一个Activity上面弹出（除了System Alert类型的Dialog），因此，Activity类型的Context的用途是最广的。 这里说一下上图中Application和Service所不推荐的两种使用情况。 1.如果我们用ApplicationContext去启动一个LaunchMode为standard的Activity的时候会报错android.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?这是因为非Activity类型的Context并没有所谓的任务栈，所以待启动的Activity就找不到栈了。解决这个问题的方法就是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就为它创建一个新的任务栈，而此时Activity是以singleTask模式启动的。所有这种用Application启动Activity的方式不推荐使用，Service同Application。 2.在Application和Service中去layout inflate也是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。所以这种方式也不推荐使用。 一句话总结：凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。 如何获取Context主要有以下4种方法： View.getContext。返回当前View的Context对象，通常是正在显示的Activity对象。 Activity.getApplicationContext，即获取ApplicationContext。通常我们在使用Context对象，特别是要持有Context对象时，都要优先考虑这个全局的进程Context，可以避免很多内存泄漏问题。 ContextWrapper.getBaseContext()。返回ContextWrapper所包装的那个原始Context，在实际开发中用得很少，不建议使用。 Activity.this，返回当前的Activity实例。UI控件需要使用Activity作为Context对象，但其实默认的Toast实际上也可以用ApplicationContext。getApplication()和getApplicationContext()其实这两个函数获取的都是同一个对象，那么既然结果都是相同的，Android为啥要提供两个功能重复的方法呢？实际上，这两个方法在作用域上有比较大的区别。getApplication()方法只有在Activity和Service才能调用，而另一个方法范围就要广一些，比如在BroadcastReceiver中就可以使用getApplicationContext()来获取。 Context的错误使用引起的内存泄漏这里举两个常见的例子： 1. 错误的单例模式123456789101112131415public class Singleton &#123; private static Singleton instance; private Context mContext; private Singleton(Context context) &#123; this.mContext = context; &#125; public static Singleton getInstance(Context context) &#123; if (instance == null) &#123; instance = new Singleton(context); &#125; return instance; &#125;&#125; instance作为静态对象，位于GC ROOT节点上，生命周期要长于普通的对象。常驻内存的Singleton保存了传入的Activity对象并一直持有，即使Activity被销毁掉，但因为它的引用还存在于一个Singleton中，就不会被GC掉，这就导致了内存泄漏。解决方法是使用弱引用WeakReference；或者传入ApplicationContext。 2. View持有Activity引用123456789101112public class MainActivity extends Activity &#123; private static Drawable mDrawable; @Override protected void onCreate(Bundle saveInstanceState) &#123; super.onCreate(saveInstanceState); setContentView(R.layout.activity_main); ImageView iv = new ImageView(this); mDrawable = getResources().getDrawable(R.drawable.ic_launcher); iv.setImageDrawable(mDrawable); &#125;&#125; 代码中一个静态Drawable对象被设置在ImageView中。而ImageView传入的this是MainActivity的mContext，因为被static修饰的mDrawable是常驻内存的，MainActivity是它的间接引用，所以当MainActivity被销毁时，也不会被GC掉，造成内存泄漏。 使用Context的注意事项一般Context造成的内存泄漏几乎都是当Context被销毁时，由于还存在引用而导致销毁失败。不过Application是伴随进程而存在的唯一的Context，所以： 在Application适用的场景中优先考虑使用它。 不要让生命周期长于Activity的对象持有Activity的引用。 尽量不要在Activity中使用非静态内部类和匿名类，因为它们会持有外部实例的引用。而静态内部类会将外部引用作用为弱引用持有。]]></content>
    </entry>

    
  
  
</search>
