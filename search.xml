<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Scroller]]></title>
      <url>%2F2017%2F03%2F24%2FScoller.html</url>
      <content type="text"><![CDATA[Q:mScrollX和mScrollY是什么东西？A:它们是在scrollTo方法中定义的变量，表示View在X、Y方向的滚动距离。其中，ScrollBy会调用ScrollTo，相当于在mScrollX和mScrollY上加上其参数所指定的偏移量。 Q:传入一个正数会向负轴移动？A:利用这两个方法发生移动的是View的内容。在Invalidate方法中，重新计算绘制大小时是减去mScrollX/Y的，所以是负方向移动。 Q:Scroll是怎么让view滚动起来的？A: Q:实现View的滑动？A：(1)使用layout方法;(2)修改View的LayoutParams;(3)采用动画向View施加移动效果;(4)使用Scroll。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[线程协作机制]]></title>
      <url>%2F2017%2F03%2F23%2F%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C%E6%9C%BA%E5%88%B6.html</url>
      <content type="text"><![CDATA[摘要了解了wait/notify基本协作方法的使用及其原理，并且利用它们来演示了如何实现各种常见线程间协作情景的基本原理线程之间协作的关键是要弄清共享变量和条件是什么。提到了java中专门为处理这些场景开发的阻塞队列、同步工具类以及Executors框架，在实际开发中，应该尽可能使用这些现成的类，而非重新发明轮子。后续再详细解析这些工具。 之前分析了多线程之间竞争访问同一个资源的问题以及一个解决方案synchronized。但是，多线程除了竞争外，还经常需要协作，下面先来提一些问题。 都有哪些场景需要协作？wait/notify是什么？如何使用？实现原理是什么？协作的核心是什么？如何实现各种典型的协作场景？ 协作的场景生产者/消费者协作模式：这是一种比较常见的协作模式，生产者与消费者线程通过共享队列进行协作，由生产者将数据或任务放到队列上，消费者从队列中取出项目进行处理。如果队列有限，那么在队列满了的时候，生产者需要等待；而在队列为空的时候，消费者也需要等待。同时开始：要求多个线程能同时开始任务。等待结束：主线程将任务分解为多个子任务，为每个子任务创建一个线程，主线程在继续执行其他任务之前需要等待每个子任务执行完毕。这也是一种非常常见的主从协作模式。异步结果：在主从协作模式中，主线程手工创建子线程的写法往往比较麻烦，另一种常见的做法是将子线程的管理封装为异步调用，异步调用会马上返回，但返回的不是最终的结果，而是一个一般称为Promise或Future的对象，通过它可以在随后获取到最终的结果。集合点：所有从不同的出发点出发的线程，在完成各自的任务之后到达一个集合点，所有线程到齐之后进行下一项活动。在探讨这些常见情景的实现之前，先了解一下协作的基本方法wait/notify。 wait/notify我们知道，Java中所有类的根类是Object，Java在Object类中(而非Thread类中)，定义了一些线程协作的基本方法，使得每一个对象都可以调用这些方法，这些方法有两类，一类是wait，一类是notify。主要有两个wait方法： 12public final void wait() throws InternalExceptionpublic final native void wait(long timeout) throws InternalException 下面的方法带一个时间参数，单位毫秒，表示最多等待这么长的时间，参数为0表示无限期等待。上面那个不带时间参数的wait其实就是调用了wait(0)。在等待期间都可以被中断，如果中断就会抛出InterruptedException，之后会介绍中断和中断处理。 wait实际上做了什么？它在等待什么？之前说过每个对象都有一个锁和一个等待队列，一个线程在进入synchronized代码块后，会尝试获取锁，如果获取不到的话就会把当前线程加入等待队列之中，不过，其实每个对象还有另一个等待队列，表示条件队列，该队列用于线程间的协作。当一个线程t调用wait方法时，就会把该线程t放到条件队列中并阻塞，表示当前线程t不能继续执行了，它需要等待一个条件，这个条件它自己无法改变，必须要其他线程来改变。要改变这个条件，需要其他线程来调用这个对象的notify方法。12public final native void notify()public final native void notifyAll() notify做的事情就是从条件队列中选择一个线程，将其从队列中移除并唤醒，让它继续执行。notify和notifyAll的区别就是，后者会将条件队列中所有的线程全部唤醒。 来看一个简单的例子，一个线程启动后，在执行一项操作前，需要等待主线程的指令，收到指令后才能执行： 1234567891011121314151617181920212223242526272829public class WaitThread extends Thread &#123; private volatile boolean fire = false; @Override public void run() &#123; try &#123; synchronized (this) &#123; while (!fire) &#123; wait(); &#125; &#125; System.out.println("fired"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public synchronized void fire() &#123; this.fire = true; notify(); &#125; public static void main(String[] args) throws InterruptedException &#123; WaitThread waitThread = new WaitThread(); waitThread.start(); Thread.sleep(1000); System.out.println("main fire"); waitThread.fire(); &#125;&#125; 代码中有两条线程，一个是主线程，一个是WaitThread，协作的条件变量是fire，waitThread等待该变量变成true，在该变量不为ture时调用wait阻塞，主线程设置该变量并调用nofity唤醒waitThread。由于两个线程都要访问修改协作变量fire，容易出现竞态条件，所以相关代码都需要用synchronized保护。实际上，wait/notify方法只能在synchronized代码块内被调用，如果调用wait/notify方法时，当前线程没有持有对象锁，会抛出java.lang.IllegalMonitorStateException异常。 细心的人会发现，如果wait被synchronized保护，那么另一个线程怎么可能调用同样被synchronized保护的notify方法呢？这里我们需要进一步理解wait的内部过程，虽然是在synchronized方法内，但是调用wait时，线程会释放对象锁，wait的具体过程是：1.把当前线程放入条件等待队列，释放对象锁，阻塞等待，线程状态变为WAITING或TIMED_WAITING；2.在被其他线程调用notify系列方法或超过设置的等待时间时，要重新竞争对象锁如果能获得锁，线程状态会变为RUNNABLE，并从wait调用中返回；否则，该线程加入对象锁的等待队列，线程状态变为BLOCKED，只有在获得锁后才从wait调用中返回。 线程从wait返回后，不代表其他等待条件一定成立，它需要重新检查其他等待条件，一般的调用模式是： 1234synchronized (obj) &#123; while (条件不成立) obj.wait(); // 条件满足后执行的操作&#125; 调用notify会把在条件队列中等待的线程唤醒并从队列中移除，但它不会释放对象锁，也就是说，只有在包含notify的synchronized代码块执行完后，等待的线程才会从wait调用中返回。 下面来总结一下wait/notify方法，一个线程调用对象的wait方法，会将该线程加入该对象的条件队列中并阻塞线程，而其他线程调用该对象的notify方法才能将该线程从对象的条件队列中移除并唤醒，所以要搞清楚wait等待的究竟是什么，notify唤醒的究竟是什么。使用wait/notify进行线程协作实际上是围绕共享变量进行协作的，这个共享条件变量是要求具体代码自己来维护的，上面的一般调用模式显示了这种机制的模式，当条件不成立时进入wait，另一个线程修改了条件后调用notify，唤醒调用wait的线程重新检查条件变量。我们在设计多线程协作时，需要想清楚协作的共享变量和条件是什么，这是协作的核心。接下来就来通过wait/notify解决最开始提到的那几种协作场景。 生产者/消费者模式根据上面提到的原则，在生产者/消费者模式种，协作共享变量是队列，条件是生产者在队列满了时wait，而消费者在队列空了的时候wait。下面是一个简单地生产/消费者模式的演示代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.Queue;import java.util.ArrayDeque;public class ProducerConsumerDemo &#123; static class MyBlockingQueue&lt;E&gt; &#123; private Queue&lt;E&gt; queue = null; private int limit; public MyBlockingQueue(int limit) &#123; this.limit = limit; queue = new ArrayDeque&lt;&gt;(limit); &#125; public synchronized void put(E e) throws InterruptedException &#123; while (queue.size() == limit) &#123; wait(); &#125; queue.add(e); notifyAll(); &#125; public synchronized E take() throws InterruptedException &#123; while (queue.isEmpty()) &#123; wait(); &#125; E e = queue.poll(); notifyAll(); return e; &#125; &#125; static class Producer extends Thread &#123; MyBlockingQueue&lt;String&gt; queue; public Producer(MyBlockingQueue&lt;String&gt; queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; int num = 0; try &#123; while (true) &#123; String task = String.valueOf(num); queue.put(task); System.out.println("生产任务 "+task); num++; Thread.sleep((long) (Math.random()*100)); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; static class Consumer extends Thread &#123; MyBlockingQueue&lt;String&gt; queue; public Consumer(MyBlockingQueue&lt;String&gt; queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; try&#123; while (true) &#123; String task = queue.take(); System.out.println("处理任务 "+ task); Thread.sleep((long) (Math.random()*100)); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; MyBlockingQueue&lt;String&gt; queue = new MyBlockingQueue&lt;&gt;(10); new Producer(queue).start(); new Consumer(queue).start(); &#125;&#125; 运行该程序会看到生产者和消费者线程的输出交替出现。其中，MyBlockingQueue是一个长度有限的队列，长度通过构造方法的参数进行传递，有两个方法put和take。生产者调用put往队列中添加数据，满了就wait，并且只要放上一个数据就调用notifyAll通知潜在的消费者。tak是给消费者用的，道理是一样的。我们看到，put和wait都调用了wait，但调用它们的线程是不一样的，等待的条件也是不一样的，put等待的是队列不满，take等待的是队列不空，但是它们都会加入相同的条件队列，也就是MyBlockingQueue对象内部维护的那个条件队列。由于条件不同，但又使用的是相同的等待队列，所以要调用notifyAll而不是notify，因为notify只能唤醒一个线程，而如果唤醒的是同类线程就起不到协调的作用。 只能有一个条件队列，这是wait/notify机制的局限性，这使得对于等待条件的分析变得复杂，后续会学习显式的锁和条件，它可以解决该问题。 我们实现的这个MyBlockingQueue主要是用于演示，Java提供了专门的阻塞队列实现，包括：接口BlockingQueue和BlockingDeque基于数组的实现类ArrayBlockingQueue基于链表的实现类LinkedBlockingQueue和LinkedBlockingDeque基于堆的实现类PriorityBlockingQueue在实际的工程中，应该考虑使用这些成熟的类，后续会详细学习它们。同时开始这个场景类似于运动员比赛，在听到比赛枪响后同时开始，下面我们来模拟这个过程，场景中有一个主线程和N个子线程，每个子线程模拟一个运动员，主线程模拟裁判，它们协作的共享变量是一个开始信号。我们用一个FireFlag类来表示这个协作对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class synchronizedStart &#123; static class FireFlag &#123; private volatile boolean fired = false; public synchronized void waitForFire() throws InterruptedException &#123; while (!fired) &#123; wait(); &#125; &#125; public synchronized void fire() &#123; this.fired = true; notifyAll(); &#125; &#125; static class Racer extends Thread &#123; FireFlag fireFlag; public Racer(FireFlag fireFlag) &#123; this.fireFlag = fireFlag; &#125; @Override public void run() &#123; try &#123; this.fireFlag.waitForFire(); System.out.println(Thread.currentThread().getName() + "开始跑步"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; int num = 10; FireFlag fireFlag = new FireFlag(); Thread[] racers = new Thread[num]; for (int i = 0; i &lt; num; i++) &#123; racers[i] = new Racer(fireFlag); racers[i].start(); &#125; Thread.sleep(1000); fireFlag.fire(); &#125;&#125; 可以看到我们用10个Racer线程模拟了10个运动员，每个Racer线程都持有一个fireFlag，它是一个共享变量，当主线程调用fire方法后，这个阻滞条件被打破，FireFlag调用notifyAll唤醒所有等待的线程，线程检查共享变量发现满足条件，于是所有线程开始同时执行，注意这里的同时也是相对而言的。 等待结束先来回头看看join是怎么回事，实际上join就是调用了wait。其主要代码为： 123while(isAlive()) &#123;wait(0);&#125; 只要线程存活，join就会一直等待，当线程结束运行时，Java系统会调用notifyAll来通知。使用协作对象 使用join有时比较麻烦，需要主线程逐一等待每个子线程。这里有一种新的写法，主线程与各个子线程协作的共享变量是一个数，这个数表示未完成的线程个数，初始值为子线程个数，主线程等待该变量为0，而每个子线程结束后就将这个协作值减一，当减到0时调用notifyAll，我们用MyLatch来表示这个协作对象，示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class WaitingForComplete &#123; public static class MyLatch &#123; private int count; public MyLatch(int count) &#123; this.count = count; &#125; public synchronized void await() throws InterruptedException &#123; while (count &gt; 0) &#123; wait(); &#125; &#125; public synchronized void countDown() &#123; count--; if (count&lt;=0) &#123; notifyAll(); &#125; &#125; &#125; static class Worker extends Thread &#123; MyLatch latch; public Worker(MyLatch latch) &#123; this.latch = latch; &#125; @Override public void run() &#123; try &#123; Thread.sleep((long) (Math.random()*1000)); System.out.println(this.getName()+"完成工作。"); this.latch.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; int workerNum = 100; MyLatch latch = new MyLatch(workerNum); Worker[] workers = new Worker[workerNum]; for (int i = 0; i &lt; workerNum; i++) &#123; workers[i] = new Worker(latch); workers[i].start(); &#125; latch.await(); System.out.println("所有worker均已经执行完毕"); &#125;&#125; 这里，MyLatch的构造方法参数应该为子线程个数，主线程应该调用MyLatch的await()方法，而子线程应该在执行完后调用countDown()方法。MyLatch是一个用于同步协作的工具类，我们的代码演示了其基本原理，Java中有一个专门的同步类CountDownLatch，在实际开发中应该使用它，后续还会有介绍。MyLatch的功能也是比较通用的，在上面的”同时开始“场景中，如果将它的初始值设为1，子线程调用await()，主线程调用countDown()，也可以实现同样的效果。 异步结果在主从模式种，手工创建线程往往比较麻烦，一种常见的模式是异步调用，异步调用返回一个一般称为Promise或Future的对象，通过它可以获得最终的结果。在Java中，表示子任务的接口是Callable，声明为： 123public interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; 位于java.util.concurrent.Callable包中。为了表示异步调用的结果，我们定义一个接口MyFuture，如下所示： 123public interface MyFuture&lt;V&gt; &#123; V get() throws Exception;&#125; 该方法返回最终的执行结果，如果计算还没完成就会阻塞直到完成，如果调用过程中发生异常，则get方法会抛出过程中遇到的异常。 为了方便主线程调用子任务，我们定义一个类MyExecutor，其中定义一个public方法execute，表示执行子任务并返回异步结果，利用这个方法，主线程就不需要创建并管理子线程了，而且可以很方便地获取异步调用的结果。 下面是一个实例： 123456789101112131415161718public static void main(String[] args) &#123; MyExecutor executor = new MyExecutor(); Callable&lt;Integer&gt; subTask = new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; int millis = (int) (Math.random() * 1000); Thread.sleep(millis); return millis; &#125; &#125;; MyExecutor.MyFuture&lt;Integer&gt; future = executor.execute(subTask); try &#123; Integer result = future.get(); System.out.println(result); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 要执行异步任务，只需构造一个Callable实例，并且调用MyExecutor对象的execute方法将它传入就行了。execute会返回一个Future对象，用于稍后获取结果。下面我们来看一下MyExecutor的execute方法是如何实现的： 123456789101112131415161718192021222324public &lt;V&gt; MyFuture&lt;V&gt; execute(final Callable&lt;V&gt; task) &#123; final Object lock = new Object(); final ExecuteThread&lt;V&gt; thread = new ExecuteThread&lt;&gt;(task,lock); thread.start(); MyFuture&lt;V&gt; future = new MyFuture&lt;V&gt;() &#123; @Override public V get() throws Exception &#123; synchronized (lock) &#123; while (!thread.isDone()) &#123; try&#123; lock.wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; if (thread.getException() != null) &#123; throw thread.getException(); &#125; return thread.getResult(); &#125; &#125; &#125;; return future;&#125; 首先是创建一个Object实例用于使用条件队列，然后创建了一个ExecuteThread对象： 123456789101112131415161718192021222324252627282930313233343536373839public class ExecuteThread&lt;V&gt; extends Thread &#123; private V result = null; private Exception exception = null; private boolean isDone = false; private Callable&lt;V&gt; task; private Object lock; public ExecuteThread(Callable&lt;V&gt; task, Object lock) &#123; this.task = task; this.lock = lock; &#125; @Override public void run() &#123; try&#123; result = task.call(); &#125; catch (Exception e) &#123; exception = e; &#125; finally &#123; synchronized (lock) &#123; isDone = true; lock.notifyAll(); &#125; &#125; &#125; public V getResult() &#123; return this.result; &#125; public boolean isDone() &#123; return this.isDone; &#125; public Exception getException() &#123; return this.exception; &#125; &#125;&#125; ExecuteThread用于实际执行Callable。在它的内部封装了Callable执行的相关结构，如Callable本身，结果result，结束标志isDone同时也是协作变量，执行过程中可能产生的Exception，同时还会持有一个用于协作的Obj对象。run方法中具体执行Callable。值得注意的是执行最后会notifyAll唤醒外部等待结果的线程。我们再回到execute方法，在开启ExecuteThread.start()后，这个方法将会wait来等待返回结果。其实这就是一个典型的wait/notify协作情景。以上的MyExecutor和MyFuture主要用于演示基本原理，实际上Java包中已经包含了一套完整的Executors框架，相关的部分接口有：表示异步结果的接口Future和实现类FutureTask用于执行异步任务的接口Executor、以及有更多功能的子接口ExecutorService用于创建Executor和ExecutorService的工厂方法类Executors后续还会详细介绍这套框架。 集合点这个场景中所有的线程先是分头行动，然后各自到达一个集合点，在集合点需要集齐所有的线程，交换数据，然后再进行下一步行动。我们可以考虑协作变量是一个数，这个数表示未到集合点的线程个数，初始值为子线程个数，每个到达集合点的线程都将这个值减一。如果这个值不为0，说明还有线程未到达，继续等待；如果为0，则表示当前线程自己是最后一个到达的，调用notifyAll唤醒所有线程。我们利用AssemblePoint类表示这个协作对象，示例代码如下： 1234567891011121314151617181920public class AssemblePoint &#123; private int n; public AssemblePoint(int n) &#123; this.n = n; &#125; public synchronized void await() throws InterruptedException &#123; if (n &gt; 0) &#123; n--; if (n == 0) &#123; notifyAll(); &#125; else &#123; while ( n != 0) &#123; wait(); &#125; &#125; &#125; &#125;&#125; 有多个子线程，先各自独立运行，然后使用该协作对象到达集合点进行同步，示例代码如下： 12345678910111213141516171819202122232425262728293031public class AssemblePointDemo &#123; static class Tourist extends Thread &#123; AssemblePoint ap; public Tourist(AssemblePoint ap) &#123; this.ap = ap; &#125; @Override public void run() &#123; try &#123; Thread.sleep((long) (Math.random() * 1000)); ap.await(); System.out.println("子线程到达"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; int num = 10; Tourist[] tourists = new Tourist[num]; AssemblePoint ap = new AssemblePoint(num); for (int i = 0; i &lt; num; i++) &#123; tourists[i] = new Tourist(ap); tourists[i].start(); &#125; &#125;&#125; 代码很清楚就不详细分析了。这里实现的AssemblePoint主要是用于演示基本原理，Java中有一个专门的同步工具类CyclicBarrier可以代替它，关于该类，后续在介绍。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[synchronized锁]]></title>
      <url>%2F2017%2F03%2F23%2Fsychronized%E9%94%81.html</url>
      <content type="text"><![CDATA[之前提到了多线程共享内存的两个问题，一个是竞态条件，一个是内存可见性，解决这两个问题的方案之一是使用synchronized关键字，接下来就来详细讨论它。synchronized关键字可以用于修饰类的实例方法、静态方法和代码块。 实例方法在之前的那个1000个线程并发对静态变量+1操作的例子中，最后得到的结果和期望结果不符合(这里去掉下面代码中的synchronized就可以看到)。当时提到了可以用synchronized关键字解决这个问题，下面就来看看如何解决： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class CounterThreadEx extends Thread &#123; private Counter counter; public CounterThreadEx(Counter counter) &#123; this.counter = counter; &#125; @Override public void run() &#123; try &#123; Thread.sleep((long) (Math.random()*10)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; counter.incr(); &#125; public static void main(String[] args) throws InterruptedException &#123; int num = 1000; Counter counter = new Counter(); Thread[] threads = new Thread[num]; for (int i = 0; i &lt; num; i++) &#123; threads[i] = new CounterThreadEx(counter); threads[i].start(); &#125; for (int i = 0; i &lt; num; i++) &#123; threads[i].join(); &#125; System.out.println(counter.getCount()); &#125; public static class Counter&#123; private int count; public synchronized void incr() &#123; count++; &#125; public synchronized int getCount()&#123; return count; &#125; &#125;&#125; 与上个例子类似，创建了1000个线程，传递了相同的counter对象，每个线程的主要操作就是调用Counter的incr方法，main线程等待子线程全部退出后输出counter的值，这次的结果就完全符合期望结果。这里的synchronized看上去使得同一时间只能有一个线程执行实例方法，但这个理解是不准确的。多个线程可以同时执行同一个synchronized方法，只要它们访问的对象是不同的。比如： 123456Counter counter1 = new Counter();Counter counter2 = new Counter();Thread t1 = new CounterThread(counter1);Thread t2 = new CounterThread(counter2);t1.start();t2.start(); 这里，t1和t2两个线程是可以同时执行Counter的incr方法的，因为它们访问的是不同的Counter对象。所以，synchronized实例方法实际保护的是同一个对象的方法调用，确保同一时间只能有一个线程执行。具体说来就是synchronized实例方法保护的是当前实例对象，即this，this对象有一个锁和一个等待队列，锁只能被一个线程持有，其他试图获取同一锁的线程需要等待，执行synchronized实例方法的过程大致如下：1.线程尝试获取对象锁，如果能够获取锁，则开始执行下一步代码，否则加入等待队列，阻塞并等待唤醒；2.执行实例方法体的代码3.释放锁，如果等待队列上有等待的线程，从中取一个并唤醒，如果有多个等待的线程，唤醒哪一个是不一定的！不保证公平性。实际上sychronized的执行过程远比这个步骤要复杂得多，而且java虚拟机采用了多种优化方式以提高性能，但从概念上我们可以这样简单地理解。当线程无法获取锁时，它会加入等待队列，线程的状态会变为BLOCKED。 所以，synchronized保护的是对象而非代码，只要访问的是同一个对象的synchronized方法，即使是不同的代码，也会被同步的顺序访问，比如对于Counter中的两个方法incr()和getCounter()，对于同一个对象，一个线程执行incr，一个执行getCounter，它们也是不能同时执行的，会被synchronized以同步的顺序执行。此外需要说明的是，synchronized方法不防止非synchronized方法被同时执行。所以一般在保护变量时，需要在所有访问该变量的方法上加上synchronized。 静态方法synchronized同样可以用在静态方法中，比如：1234567891011public class StaticCounter &#123; private static int count = 0; public static synchronized void incr() &#123; count++; &#125; public static synchronized int getCount() &#123; return count; &#125;&#125; 对于实例方法，synchronized保护的是当前实例对象this，对静态方法，保护的是类对象。这里是StaticCounter.class。实际上，每个对象队友一个锁和一个等待队列，类对象也不例外。synchronized静态方法和synchronized实例方法保护的是不同的对象，不同的两个线程，可以同时地一个执行synchronized静态方法，另一个执行synchronized实例方法。代码块 除了用于修饰方法外，synchronized还可以用于包装代码块，比如对于前面的Counter类，等价的代码可以为： 12345678910111213public class Counter &#123; private int count; public void incr() &#123; synchronized (this) &#123; count++; &#125; &#125; public int getCount() &#123; synchronized (this) &#123; return count; &#125; &#125;&#125; 而对于StaticCounter类，等价代码为： 12345678910111213public class StaticCounter&#123; private static int count = 0; public static void incr() &#123; synchronized (StaticCounter.class) &#123; count++; &#125; &#125; public static int getCount() &#123; synchronized (StaticCounter.class) &#123; return count; &#125; &#125;&#125; synchronized同步的对象可以是任意对象，任何一个对象都具有锁和等待队列，或者说，任何对象都可以作为锁对象。比如说，Counter的等价代码还可以为: 123456789101112131415public class Counter&#123; private int count; private Object lock = new Object(); public void incr() &#123; synchronized (lock) &#123; count++; &#125; &#125; public int getCount() &#123; synchronized (lock) &#123; return count; &#125; &#125;&#125; 理解Synchronized接下来我们再从下面几个角度进一步理解一下synchronized:可重入性内存可见性死锁 可重入性synchronized有一个重要的特征，它是可重入的，也就是说，对于同一个执行线程，它在获得了锁之后，调用其他需要同样锁的代码时，可以直接调用。这是一个非常自然的特性，之所以强调，是因为并不是所有的锁都是可重入的。可重入是通过记录锁的持有线程和持有数量来实现的，当调用被synchronized保护的代码时，检查对象是否已被锁，如果是，在检查是否被当前线程锁定，如果是，增加持有数量，如果不是被当前线程锁定，才加入等待对象，当释放锁时，减少持有数量，当数量变为0时才释放整个锁。 内存可见性对于复杂一些的操作，synchronized可以实现原子操作，避免出现竞态条件，但对于明显的本来就是原子操作的方法，也需要加synchronized吗？比如说，对于开关类Switcher，它只有一个boolean变量on和对应的setter/getter方法。此时，当多个线程访问同一个Switcher对象时，的确不存在竞态条件的问题，但是仍然存在内存可见性的问题，加上synchronized就可以解决。所以synchronized除了保证原子操作之外，还有一个作用，就是保证内存可见性，在释放锁时，所有写入都会写回内存，而获得锁后，都会从内存中读数据。不过如果只是为了保证内存可见性，synchronized的成本有点高，有个更轻量级的方法就是给变量加修饰符volatile。加了volatile之后，Java会在操作对应变量时加入特殊的指令，保证读写到内存的最新值而非缓存。 死锁使用synchronized或其他锁的时候，要注意死锁。所谓死锁，比如，有a、b两个线程，a持有A锁，在等待B锁，b持有B锁，在等待A锁，a、b陷入了相互等待，最后一等就是一辈子。 要避免死锁，首先应该尽量避免在持有一个锁的同时去申请另一个锁，如果确实需要多个锁，所有代码都应该按照相同的顺序去申请。借助一些工具也可以发现运行中的死锁，比如，java自带的jstack命令会报告发现的死锁。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Retrofit源码分析]]></title>
      <url>%2F2017%2F03%2F23%2FRetrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
      <content type="text"><![CDATA[Retrofit源码分析 Retrofit的亮点 先来看一个最基本的Retrofit+Gson的用法： 1234567891011121314151617// https://raw.githubusercontent.com/xiaoniaojun/xiaoniaojun.github.io/master/test.json Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://raw.githubusercontent.com/") .addConverterFactory(GsonConverterFactory.create()) .build(); GitHub gitHub = retrofit.create(GitHub.class); Call&lt;User&gt; xiaoniaojun = gitHub.results("xiaoniaojun", "test.json"); xiaoniaojun.enqueue(new Callback&lt;User&gt;() &#123; @Override public void onResponse(Call&lt;User&gt; call, Response&lt;User&gt; response) &#123; User responseUser = response.body(); &#125; @Override public void onFailure(Call&lt;User&gt; call, Throwable t) &#123; t.printStackTrace(); &#125; Retrofit让我们可以使用注解接口方法的方式来实现解析Url，构造一个可执行对象，这个可执行对象可以直接调用网络请求的操作并对返回结果进行同步/异步处理。其中最亮的地方是，这个可执行对象既可以是一个在java8或者Android平台可以直接调用的Call对象，也可以是一个Observer对象。并且，对于返回的response，可以加入Converter来将其内容以特定的方式解析，比如请求json对象，可以使用GsonConverter来将response body直接解析为具体的对象，又或者是可以自定义如何包装request。 public Retrofit build()方法： 12345678910111213141516171819202122232425262728293031323334353637/** * 根据设置的配置值来创建&#123;@link Retrofit&#125;实例 * &lt;p&gt; * 注意: 如果&#123;@link #client&#125;和&#123;@link #callFactory&#125; 都没有被调用，就默认生成和使用&#123;@link * OkHttpClient&#125;。 */ public Retrofit build() &#123; // 如果不提供baseUrl，就会抛出异常。 if (baseUrl == null) &#123; throw new IllegalStateException("Base URL required."); &#125; // 这个callFactroy是一个空的值，所以这句代码没有任何作用，估计是遗留代码。 okhttp3.Call.Factory callFactory = this.callFactory; // 默认使用OkHttpClient来创建CallFactory // Factory是一个接口，内部只有一个newCall(Request r)方法。 if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; // 这里的CallbackExecutor，是封装了主线程Looper的Handler， // 所以这个默认的CallbackExecutor会将回调在主线程中执行。 Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; // 防御性拷贝adapters，并添加默认Call adapter。 // 1.解析defaultCallAdapterFactory List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); // Make a defensive copy of the converters. List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories); return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor, validateEagerly); &#125; 这个装配的过程其实就是在为Retrofit配置几个关键组件：我们先列出它们，再来一个一个分析。baseUrl: 基url地址，在它上面构建完整的url请求，这个没什么好解释的。callFactory:call工厂，call是干嘛的？是我们最终用来执行http请求和接受的。下面我们再来剖析这个东西。callbackExecutor：回调执行者，这个是用来执行回调的。为什么要封装它？因为它是用来控制执行线程的。adapterFactories：适配器工厂，适配的什么？converterFactories转换器工厂，转换的什么？ CallFactory首先，这个callFactory是由以下代码生成的： 1callFactory = new OkHttpClient(); 这条语句创建的。我们知道，Retrofit的网络请求是基于OkHttp实现的，那这里很明显是实际执行网络操作的请求的方法。我们跟进去OkHttpClient类， 1public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory 由于这里OkHttpClient行使的是Factory的职责，我们主要看OkHttpClient实现的这个接口的方法。Call.Factory只有一个方法： 123@Override public Call newCall(Request request) &#123; return new RealCall(this, request, false /* for web socket */); &#125; 传递进一个request对象，把它转换成可执行的Call对象。 到这里，callFactory就具备了它的职责，根据request来构建Call。 现在我们来审查一下这个OkHttpClient对象。它具备的能力有：执行各种网络操作、将这些操作构建成Call对象。 这里我们再谈谈Call接口。 request返回初始化这个call的原生request对象，其余都是控制请求执行的指令。 然后，这个RealCall是Call接口的实现类，它实际处理对OkHttp的调用。由于我们这里只分析Retrofit，所以这个部分我们就省略了。现在只需要知道，通过CallFactory，我们可以构建Call对象，而这个Call就是在执行网络请求。 CallbackExecutor同样来看一下生成CallbackExecutor实例的方法， 1callbackExecutor = platform.defaultCallbackExecutor(); 首先这个CallbackExecutor是一个Executor类型对象。Executor是java并发包中的接口，只有一个execute方法，就是用来执行Runnable的。这个是用来解耦的。 Platform工具类提供了多平台支持。它在初始化的时候调用其findPlatform方法查看调用环境。在Andoird平台上，提供了MainThreadExecutor用来在主线程中执行代码。那么这个CallbackExecutor是干什么的呢？看名字就知道，是用于执行回调的。网络请求返回response，接收处理的结果很多时候是需要在主线程中更新ui的。 123@Override public Executor defaultCallbackExecutor() &#123; return new MainThreadExecutor(); &#125; 所以最终在Andoird平台上，默认的CallbackExecutor是这个MainThreadExecutor，也就是说，回调默认是在主线程中执行的。 adapterFactory12List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); 接下来又是一个平台相关的CallAdapterFactory。在Android平台中，默认的defaultCallAdapterFactory是ExecutorCallAdapterFactory。 123@Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123; return new ExecutorCallAdapterFactory(callbackExecutor); &#125; 这个CallAdapter到底适配的是什么？答案就是，我们在定义那个创建链接的接口时，不是声明了一个Call吗，这个Adapter就是将我们的CallFactory产生的Call与CallbackExecutor融合起来，创建一个生产Call对象的工厂。注意CallAdapter接口里面的那个adapter方法，就是做这件事的。 1. CallAdapterFactory12345678CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123; // 如果callbackExecutor不为空，则调用ExecutorCallAdapterFactory(callbackExecutor) if (callbackExecutor != null) &#123; return new ExecutorCallAdapterFactory(callbackExecutor); &#125; // 否则返回默认的CallAdapterFactory return DefaultCallAdapterFactory.INSTANCE;&#125; 123456789101112131415161718192021222324252627final class ExecutorCallAdapterFactory extends CallAdapter.Factory &#123; final Executor callbackExecutor;# ExecutorCallAdapterFactory(Executor callbackExecutor) &#123; this.callbackExecutor = callbackExecutor; &#125; // 这个方法传入的参数有 // returnType，返回类型 // annotations，注解 // retrofit // 从这些参数我们可以推断，这个CallAdapter是将之前所有的请求设置封装到Call中的关键 @Override public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; if (getRawType(returnType) != Call.class) &#123; return null; &#125; final Type responseType = Utils.getCallResponseType(returnType); return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); &#125; &#125;; &#125; ##Retrofit构造函数 12345678910Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl, List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; adapterFactories, Executor callbackExecutor, boolean validateEagerly) &#123; this.callFactory = callFactory; this.baseUrl = baseUrl; this.converterFactories = unmodifiableList(converterFactories); // Defensive copy at call site. this.adapterFactories = unmodifiableList(adapterFactories); // Defensive copy at call site. this.callbackExecutor = callbackExecutor; this.validateEagerly = validateEagerly; &#125; 在构造方法中，将工厂中设置的所有配置变量进行初始化赋值。 1234567891011121314151617181920212223242526public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; // 首先检查传入的类是否为一个接口，以及，是否包含了其他接口(不合格) Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; 123456789101112class Plathform &#123;private static final Platform PLATFORM = findPlatform();// getterstatic Platform get();// 这个方法查看当前代码运行平台（java8 Android 等等）private static Platform findPlatform();&#125;// 默认回调Executor为nullExecutor defaultCallbackExecutor() &#123;return null&#125;;CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123; &#125; 动态代理的代码 12345678910111213141516171819202122return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 如果是Object声明的方法就直接调用。 if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; // 垃圾代码，已经弃用 if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; // 这里是在处理Retrofit注解 ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Retrofit2+Gson的基本用法]]></title>
      <url>%2F2017%2F03%2F13%2FRetrofit2-Gson%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.html</url>
      <content type="text"><![CDATA[Retrofit基本使用基本用法我们来实现一个最基本的请求Json结果的文件的Demo。 引入依赖首先新建一个工程，在app的build.gradle中加入以下依赖： 123compile 'com.squareup.retrofit2:retrofit:2.2.0'compile 'com.google.code.gson:gson:2.7'compile 'com.squareup.retrofit2:converter-gson:2.0.2' 第一行自然是引入retrofit2啦，由于我们需要解析Json文本，Retrofit为我们提供了一个很方便的工具Converter。我们在获取网络资源后，通常需要对其内容进行解析，这个步骤可以利用线程的解析库来实现，并且Retrofit为几个常见的解析库提供了相应了Converter类。Gson是一个常见的Json解析库，Retrofit为它提供了Converter。第二行和第三行就是分别引入Gson和GsonConverterFactory的，稍后用到这个Converter的时候会再提一下的。 然后，我们随便上传一个Json文件在GitHub上，这里大家就自己弄啦。 我传了一个Json文件上去，地址为：https://raw.githubusercontent.com/xiaoniaojun/xiaoniaojun.github.io/master/test.json 12345&#123;age: 22,name: "Bird",phoneNumber: "13550626331"&#125; 记下这个地址，后面的构建会用到。注意：这个地址可能随时失效，请大家自己动手上传。 构建请求接口12345// https://raw.githubusercontent.com/xiaoniaojun/xiaoniaojun.github.io/master/test.jsonpublic interface GitHub &#123; @GET("&#123;userId&#125;/&#123;userId&#125;.github.io/master/&#123;fileName&#125;") Call&lt;User&gt; results(@Path("userId") String userId, @Path("fileName") String fileName);&#125; 大家可以把目标链接用注释写在上面，方便写代码的时候对照。 @Get注解中编写请求链接的基本结构，其中用{}括起来的，表示替换块(replacation block)，可以在注解的方法中，通过@Path标注的参数，进行替换。这里有两点需要注意，替换块中的字符串需要和@Path参数的字符串相同才能被识别。其次，Call，这个T表示response返回的类型。 这个接口实现的请求方法，会在之后被用来构造Call对象，而这个Call对象就是封装好的可调用对象，它是后面实际执行请求所需要的关键对象。我们可以使用call进行异步或同步调用。最后，我们会将这一系列步骤串起来总结。 为json定义BeanCall中的泛型类型为User，它是我们自定义的Bean。所谓Bean，我的理解就是一个包含Json对象所有字段的数据模型类，是一个纯java类。这里，我们简单地定义一下这个User Bean。 1234567891011public class User &#123; private String name; private int age; private String phoneNumber; public User(String name, int age, String phoneNumber) &#123; this.name = name; this.age = age; this.phoneNumber = phoneNumber; &#125;&#125; 代码很简单，就是包含了Json中出现的所有字段。 构建GitHub实例我们的目的是，最终实现网络请求，刚刚说到，请求的必须品是Call实例，而Call实例是我们定义的接口方法results()返回的。所以，我们需要来构建接口类型GitHub的实例。 我们需要利用retrofit提供的建造者方法一步一步地来构建出刚刚定义的接口类型的实例。 123456Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://raw.githubusercontent.com/") .addConverterFactory(GsonConverterFactory.create()) .build(); GitHub gitHub = retrofit.create(GitHub.class); 首先，我们通过建造者模式的方法Retrofit.Builder()，一步一步构造retrofit对象。 baseUrl()方法用于指定基地址； addConverterFactroy()方法用于设置Converter。刚刚我们已经谈过它了，它的作用就是，在response返回对象的时候，将response的body体利用Gson来解析； 最后以build()方法结束建造。 这样retrofit就配置完成了，接下来调用retrofit的create方法，传入GitHub.class对象，来生成GitHub的实例。 最后一步得到了GitHub实例，我们就可以调用在GitHub接口中定义的results方法来获取Call了。在results方法中，我们定义了构造请求链接的参数userId，以及FileName，这里我们传入”xiaoniaojun”和”test.json”，就可以得到构造好的Call对象。 此时，Call的大刀早已饥渴难耐，就等着执行网络请求了！ Retrofit为我们提供了两个方法，execute和enqueue，分别是同步/异步调用。同步调用就是直接调用，阻塞到返回，没什么好说的；异步调用需要传入一个Callback对象，用来获取返回值。 123456789101112Call&lt;User&gt; xiaoniaojun = gitHub.results("xiaoniaojun", "test.json"); xiaoniaojun.enqueue(new Callback&lt;User&gt;() &#123; @Override public void onResponse(Call&lt;User&gt; call, Response&lt;User&gt; response) &#123; User responseUser = response.body(); &#125; @Override public void onFailure(Call&lt;User&gt; call, Throwable t) &#123; t.printStackTrace(); &#125; &#125;); Callback接口实现了两个方法，onFailure表示请求失败，返回call对象和Throwable；onResponse表示请求成功，返回call对象和response，这个response就是返回结果啦。 这里要说一下这个call对象有什么用。在Retrofit中，Call只能被执行一次，所以想要再次执行，就必须重新建立一个Call，或者，使用从回调中获取的这个call，它是可以被调用的。 基本使用步骤总结这里我们来简单总结一下，使用Retrofit来进行一个完整网络请求的步骤： 建立构造请求对象的接口； 使用Retrofit.Builder()来build Retrofit实例。 利用这个Retrofit实例的create方法，传入接口.class，创建出接口的实例。 利用这个实例中，我们在接口内实现的那个方法，传入构造请求链接的相关变量，创建出Call对象。 利用这个Call对象进行同步或异步调用，异步调用最后都需要构造一个匿名内部类Callback，实现onResponse回调和onFailure对返回结果进行处理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Retrofit文档翻译]]></title>
      <url>%2F2017%2F03%2F13%2FRetrofit%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91.html</url>
      <content type="text"><![CDATA[引入Retrofit1compile 'com.squareup.retrofit2:retrofit:2.2.0' 设置Retrofit通过Retrofit类可以让你的API接口转换成callable对象。默认情况下，Retrofit的默认设置已经足够应对大多数情况，不过你也可以进行自定义。 CONVERTERS默认情况下，Retrofit只能将HTTP体反序列化成OkHttp的ResponseBody类型，并且，默认只能接受RequestBody类型的@Body。 Converters可以帮我们获得对其他类型的支持。一共有六个converter可以使用，它们可以帮你适配六大常见的库。 Gson: com.squareup.retrofit2:converter-gson Jackson: com.squareup.retrofit2:converter-jackson Moshi: com.squareup.retrofit2:converter-moshi Protobuf: com.squareup.retrofit2:converter-protobuf Wire: com.squareup.retrofit2:converter-wire Simple XML: com.squareup.retrofit2:converter-simplexml 下面是一个使用GsonConverterFactory类来生成GitHubService的实现接口的例子，使用Gson库来反实例化。 123456Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.github.com") .addConverterFactory(GsonConverterFactory.create()) .build(); GitHubService service = retrofit.create(GitHubService.class); 自定义Coverters建立自己的adapter时，扩展Converter.Factory类并且传递一个它的实例进去。 Retrofit Api接口方法上的注解以及注解参数表明如何处理一个request。 REQUEST方法每个方法必须有一个HTTP注解用以提供请求方法和相对URL。一共有五个内建注解：GET、POST、PUT、DELETE和HEAD。资源的相对URL在注解中被指定。 1@GET("users/list") 你也可以在URL中指定请求参数。 12345@GET("user/list?sort=desc")``` ##URL MANIPULATION可以在方法中，动态地使用替换块(replacement block)和关联参数来替换URL中的参数。一个替换块是一个由字母和数字组成的用&#123;&#125;围起来的字符串，与其相关联的参数必须使用`@Path`注解来声明，并且注解参数要和替换块字符串相同。 @GET(“group/{id}/users”)Call]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[怒怼Rxjava2(RxAndroid)(1)]]></title>
      <url>%2F2017%2F03%2F12%2F%E6%80%92%E6%80%BCRxjava2-RxAndroid-1.html</url>
      <content type="text"><![CDATA[怒怼RxJava 2(RxAndroid) - （1）ReactiveX是一个异步编程库，它的风格是使用函数式观察者模式流来构建异步代码。这里主要讨论的是RxJava 2和RxAndroid。 ##基本工作模式 Rx的核心思想是观察者模式模型，当然观察者和被观察就是最核心的两个对象。 Rxjava2中，为了解决背压(BackPressure)问题，引入了两种观察者模式。 背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略《关于 RxJava 最友好的文章—— RxJava 2.0 全新来袭》 其中Observable和Flowable是观察者，而Observer和Subscribe是其各自对应的被观察者。 Rx的基本工作流程是，建立Observable，在里面提供数据、对象、事件等等，之后订阅被观察者，向被观察者传递这些东西，由被观察者进行处理。 创建ObservablesRx中，对象构建基于Build模式，所有的工作会在build链结束后才会被执行。Rx提供了许多创建Observables的方法： Create 最常规的创建方法，在RxAndroid中，参数需要传递一个ObservableOnSubscribe&lt;T&gt;对象。ObservableOnSubscribe&lt;T&gt;是一个接口，需要实现public void subscribe(final ObservableEmitter&lt;String&gt; e) throws Exception方法，它会提供一个Emitter对象。这个方法用来订阅被观察者，被观察者通过Emitter将数据传递给被观察者。 Q:怎么回事被观察者去订阅观察者呢？A:因为依靠这个逻辑，可以让被观察者实现一个完整的流式编程。 Defer会将创建Observable延迟被订阅时，传递一个Callable&lt;? extends ObservableOnSubscribe&lt;?&gt;&gt;。这个意思应该很明确。 Empty/Never/Throw字面意义。 From将其他对象或者数据容器转换成Observable。在RxJava中，from方法是一系列方法集。比如fromArray,fromCallable,fromInterable等。 Interval周期性地产生一系列依次递增的&lt;? extends Long&gt;类型的值emit。 Just发送一个/一系列对象emit给被观察者。最简单的方法。 Range产生一个范围的整形值emit给观察者。 Repeat 周期性重复产生一个或一组对象emit。 Timer在一定延迟之后emit单个对象。 A Demo Using Rx我们用一个实际例子来体验Rxjava的基本使用方法。在这个实例中，我们要做一个奶酪搜索app，在输入框中输入关键字，然后在准备好的数据集中搜索包含这些关键字的奶酪品牌。 准备工作首先，在主界面Layout设计UI，如图：然后，我们先封装一个BaseSearchActivity。在这个BaseSearchActivity中做以下封装： 持有各个控件的引用； 初始化RecyclerView，和设置它的内容的方法； 获取CheeseSearchEngine，搜索工具类的实例； 显示/隐藏ProgressBar； 获取数据集 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class CheeseActivity extends BaseSearchActivity &#123; private Disposable mDisposable; @Override protected void onStart() &#123; super.onStart(); Observable&lt;String&gt; textChangeStream = createTextChangeObservable(); Observable&lt;String&gt; buttonClickStream = createButtonClickObservable(); Observable&lt;String&gt; searchTextObservable = Observable.merge(textChangeStream, buttonClickStream); mDisposable = searchTextObservable .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; showProgressBar(); &#125; &#125;) .observeOn(Schedulers.io()) .map(new Function&lt;String, List&lt;String&gt;&gt;() &#123; @Override public List&lt;String&gt; apply(String query) throws Exception &#123; return mCheeseSearchEngine.search(query); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;List&lt;String&gt;&gt;() &#123; @Override public void accept(List&lt;String&gt; result) throws Exception &#123; hideProgressBar(); showResult(result); &#125; &#125;); &#125; private Observable&lt;String&gt; createButtonClickObservable()&#123; return Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(final ObservableEmitter&lt;String&gt; e) throws Exception &#123; mSearchButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; e.onNext(mQueryEditText.getText().toString()); &#125; &#125;); e.setCancellable(new Cancellable() &#123; @Override public void cancel() throws Exception &#123; mSearchButton.setOnClickListener(null); &#125; &#125;); &#125; &#125;); &#125; private Observable&lt;String&gt; createTextChangeObservable() &#123; Observable&lt;String&gt; textChangeObservable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(final ObservableEmitter&lt;String&gt; e) throws Exception &#123; final TextWatcher watcher = new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123;&#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123;&#125; @Override public void afterTextChanged(Editable s) &#123; e.onNext(s.toString()); &#125; &#125;; mQueryEditText.addTextChangedListener(watcher); e.setCancellable(new Cancellable() &#123; @Override public void cancel() throws Exception &#123; mQueryEditText.removeTextChangedListener(watcher); &#125; &#125;); &#125; &#125;); return textChangeObservable.filter(new Predicate&lt;String&gt;() &#123; @Override public boolean test(String query) throws Exception &#123; return query.length() &gt;= 2; &#125; // 防抖动 &#125;).debounce(1000, TimeUnit.MILLISECONDS); &#125; @Override protected void onStop() &#123; super.onStop(); if (!mDisposable.isDisposed()) &#123; mDisposable.dispose(); &#125; &#125;&#125; 其中，工具类CheeseSearchEngine的实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class CheeseActivity extends BaseSearchActivity &#123; private Disposable mDisposable; @Override protected void onStart() &#123; super.onStart(); Observable&lt;String&gt; textChangeStream = createTextChangeObservable(); Observable&lt;String&gt; buttonClickStream = createButtonClickObservable(); Observable&lt;String&gt; searchTextObservable = Observable.merge(textChangeStream, buttonClickStream); mDisposable = searchTextObservable .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; showProgressBar(); &#125; &#125;) .observeOn(Schedulers.io()) .map(new Function&lt;String, List&lt;String&gt;&gt;() &#123; @Override public List&lt;String&gt; apply(String query) throws Exception &#123; return mCheeseSearchEngine.search(query); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;List&lt;String&gt;&gt;() &#123; @Override public void accept(List&lt;String&gt; result) throws Exception &#123; hideProgressBar(); showResult(result); &#125; &#125;); &#125; private Observable&lt;String&gt; createButtonClickObservable()&#123; return Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(final ObservableEmitter&lt;String&gt; e) throws Exception &#123; mSearchButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; e.onNext(mQueryEditText.getText().toString()); &#125; &#125;); e.setCancellable(new Cancellable() &#123; @Override public void cancel() throws Exception &#123; mSearchButton.setOnClickListener(null); &#125; &#125;); &#125; &#125;); &#125; private Observable&lt;String&gt; createTextChangeObservable() &#123; Observable&lt;String&gt; textChangeObservable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(final ObservableEmitter&lt;String&gt; e) throws Exception &#123; final TextWatcher watcher = new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123;&#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123;&#125; @Override public void afterTextChanged(Editable s) &#123; e.onNext(s.toString()); &#125; &#125;; mQueryEditText.addTextChangedListener(watcher); e.setCancellable(new Cancellable() &#123; @Override public void cancel() throws Exception &#123; mQueryEditText.removeTextChangedListener(watcher); &#125; &#125;); &#125; &#125;); return textChangeObservable.filter(new Predicate&lt;String&gt;() &#123; @Override public boolean test(String query) throws Exception &#123; return query.length() &gt;= 2; &#125; // 防抖动 &#125;).debounce(1000, TimeUnit.MILLISECONDS); &#125; @Override protected void onStop() &#123; super.onStop(); if (!mDisposable.isDisposed()) &#123; mDisposable.dispose(); &#125; &#125;&#125; 这里顺便再给出Adapter的实现代码： 1234567891011121314151617181920212223242526272829303132333435public class CheeseAdapter extends RecyclerView.Adapter&lt;CheeseAdapter.CheeseViewHolder&gt; &#123; private List&lt;String&gt; mCheeses; @Override public CheeseViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; LayoutInflater layoutInflater = LayoutInflater.from(parent.getContext()); View view = layoutInflater.inflate(android.R.layout.simple_list_item_1, parent, false); return new CheeseViewHolder(view); &#125; @Override public void onBindViewHolder(CheeseViewHolder holder, int position) &#123; holder.title.setText(mCheeses.get(position)); &#125; @Override public int getItemCount() &#123; return mCheeses == null ? 0 : mCheeses.size(); &#125; public void setCheeses(List&lt;String&gt; cheeses) &#123; mCheeses = cheeses; notifyDataSetChanged(); &#125; public static class CheeseViewHolder extends RecyclerView.ViewHolder &#123; public final TextView title; public CheeseViewHolder(View itemView) &#123; super(itemView); title = (TextView) itemView.findViewById(android.R.id.text1); &#125; &#125;&#125; 准备工作就做完了，然后，我们再新建一个CheeseActivity类，并将其设置为启动Activity。我们的代码实现将在这个Activity中进行。 为按钮绑定搜索事件我们首先来实现，如何来实现点击按钮进行搜索。 基于观察者模式的思维，我们可以这样想：在被观察者中注册按钮事件，当点击按钮时，将输入框中的内容emit给被观察者。在被观察者中，我们接受到这个emit内容，并进行搜索任务。 按照这个逻辑，我们首先来建立被观察者。 12345678910111213141516171819private Observable&lt;String&gt; createOnClickObservable() &#123; return Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(final ObservableEmitter&lt;String&gt; e) throws Exception &#123; mSearchButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; e.onNext(String.valueOf(mQueryEditText.getText())); &#125; &#125;); e.setCancellable(new Cancellable() &#123; @Override public void cancel() throws Exception &#123; mSearchButton.setOnClickListener(null); &#125; &#125;); &#125; &#125;); &#125; 在CheeseActivity中添加一个私有方法来构建Observable。其中，T代表我们要emit的内容的类型。我们使用create方法来创建，这里要实现ObservableOnSubscribe接口中的subscribe方法。该方法是订阅观察者的方法，在其中我们需要手动实现emit。 需要注意的是，需要在e.setCancellable中将Listener清除。当我们手动取消订阅时，如果没有将Listener清除，这个Listener就会导致整个引用链无法被GC。 接下来，我们要设置观察者接受到emit内容后的逻辑了。我们重写onStart()方法，在其中做完整的初始化工作： 123456789101112@Overrideprotected void onStart() &#123; super.onStart(); Observable&lt;String&gt; onClickObservable = createOnClickObservable(); onClickObservable.subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String query) throws Exception &#123; List&lt;String&gt; result = mCheeseSearchEngine.search(query); showResult(result); &#125; &#125;);&#125; 首先我们调用createOnClickObservable()方法创建Observable对象，然后开始链式build整个观察者模式。这里我们使用subscribe订阅观察者，注意，是订阅观察者！subscribe的标准参数是一个Observer类型接口，它的实现如下： 12345678910public interface Observer&lt;T&gt; &#123; //在订阅后发送数据之前会先回调整个方法，使用d可以取消订阅 void onSubscribe(Disposable d); // 用来接收emit过来的数值 void onNext(T value); // 出错会回调这个方法 void onError(Throwable e); // 取消订阅会回调这个方法 void onComplete();&#125; 不过，我们这里使用的Consumer接口是一个简化的观察者，它的实现： 1234public interface Consumer&lt;T&gt; &#123; // 接收emit参数，可以抛出异常 void accept(T t) throws Exception;&#125; 大多数情况下都可以使用这个简化版本来处理emit过来的值。 不过，我们这里偷了个懒。如果按照正宗的函数式编程思想，emit传递过来的值是String类型，而我们交给界面显示的值是一个List，这两个不是相同的类型。这种情况，我们应该使用Map操作符来执行类型转换。 操作符来执行类型转换。 上面的代码实现可以这样， 123456789101112131415161718@Override protected void onStart() &#123; super.onStart(); Observable&lt;String&gt; onClickObservable = createOnClickObservable(); onClickObservable .map(new Function&lt;String, List&lt;String&gt;&gt;() &#123; @Override public List&lt;String&gt; apply(String query) throws Exception &#123; return mCheeseSearchEngine.search(query); &#125; &#125;) .subscribe(new Consumer&lt;List&lt;String&gt;&gt;() &#123; @Override public void accept(List&lt;String&gt; cheese) throws Exception &#123; showResult(cheese); &#125; &#125;); &#125; 关于函数式编程的思想不是本文的重点，这里就不多说了，有兴趣可以自行查阅相关资料。 我们的代码是运行成功了，结果也没有问题。可是，因为查询操作通常都是很耗时的，按下按钮后，我们也会卡在主界面无法操作。并且，Android Monitor也给出了类似下面这样的提示，通常，这种提示会在主线程长期无法响应时出现。所以我们要避免这种情况，就要使用多线程。 Rxjava一个最牛逼的地方就在于，可以极其方便地将代码执行在不同线程中。我们再来重构一下我们的代码。 1234567891011121314151617181920@Override protected void onStart() &#123; super.onStart(); Observable&lt;String&gt; onClickObservable = createOnClickObservable(); onClickObservable .observeOn(Schedulers.io()) .map(new Function&lt;String, List&lt;String&gt;&gt;() &#123; @Override public List&lt;String&gt; apply(String query) throws Exception &#123; return mCheeseSearchEngine.search(query); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;List&lt;String&gt;&gt;() &#123; @Override public void accept(List&lt;String&gt; cheese) throws Exception &#123; showResult(cheese); &#125; &#125;); &#125; 可以看到，我们在build链中添加了两个observeOn()方法。这个方法用于指定接下来的操作所在的线程。Rx为我们预先定义了很多Scheduler，代表执行的线程环境，我们可以很方便地使用它们。比如Scheduler.io()就代表在io线程中执行，AndroidScheduler.mainThread()表示主线程。 顿时异步编程如同儿戏一般简单，这就是Rx的一个亮点之一。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Dagger2使用手册]]></title>
      <url>%2F2017%2F03%2F11%2FDagger2%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.html</url>
      <content type="text"><![CDATA[参考文章：Dagger2入门，以初学者的角度 在项目中引入Dagger2step 1. 在项目build.gradle文件中添加apt插件： 1234567891011121314buildscript &#123; ... dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files // 添加apt插件 classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8' &#125;&#125;... step2. 在app目录下的build.gradle文件中添加： 123456789101112//应用apt插件apply plugin: 'com.neenbedankt.android-apt'...dependencies &#123; ... // 引入dagger2 compile 'com.google.dagger:dagger:2.4' apt 'com.google.dagger:dagger-compiler:2.4' //java注解 provided 'org.glassfish:javax.annotation:10.0-b28'&#125; 入门篇Dagger2基本用法 —— 使用Moudle类现在我们有个需求，要在MainActivity中使用Car对象。那么用依赖注入的方法要怎么实现呢？首先我们来看看其中较复杂但功能也较强大的方式是如何实现的： 1. 首先编写一个依赖对象类Car1234567891011121314151617181920public class Car &#123; private String car; public Car(String brand) &#123; this.car = brand; &#125; public String getCar() &#123; return this.car; &#125; public void setColor(String color) &#123; this.car = color; &#125; @Override public String toString() &#123; return "一辆" + this.car; &#125;&#125; 该类包含一个属性car。 2. 编写Moudle类Moudle类被用于向对象需求方MainActivity提供依赖对象。 12345678@Modulepublic class MainModule &#123; @Provides public Car getCar() &#123; Car car = new Car("BWM"); return car; &#125;&#125; 这就是一个简单的Module实现。注意到代码中有两个注解：@Module和@Provides。其中@Module用来向Dagger2标明这是一个Module类，@Provides是用来标记Module类中，哪些方法是用来提供依赖对象的。后面我们还会编写一个Component接口，需求对象需要实现这个Component接口才可以被注入对象。而当Component实现类需要依赖对象时，它会根据Moudle类中@Provides方法的返回值类型来选择应该调用哪个方法获取对象。 3. 编写Component接口1234@Component(modules=MainMoudle.class)public interface MainComponent &#123; void inject(MainActivity mainActivity);&#125; 同样，Component接口需要用@Component注解标注，但是@Component的注解具备更强大的功能，它有modules和dependencies两个属性，这两个属性的类型都是Class数组。modules是用来申明该Component含有几个Moudle，当Component需要某个依赖对象时，就会去这些Moudle类中寻找相应的@Provides方法。dependency属性，则是生命Component类的依赖关系，稍后再详细解释。 接口中的inject方法是干嘛的呢？inject方法被用来将需求对象MainActivity送入Component类，Component类会根据需求对象中声明的依赖关系来注入需求对象所需要的依赖对象。需求对象MainActivity中需要依赖对象Car，所以我们通过inject方法将MainActivity的实例传入到MainComponent中，MainComponent就会从MainModule中的getCar方法中获取实例，并将该实例赋值给MainActivity中声明的依赖对象字段。 需要注意的是，inject方法的参数不能用父类来接收。 4. 在需求对象中声明依赖关系12345678910111213141516public class MainActivity extends AppCompatActivity &#123; private TextView tvHello; @Inject Car car; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tvHello = (TextView) findViewById(R.id.tv_hello); MainComponent build = DaggerMainComponent.builder().mainMoudle(new MainModule()).build(); build.inject(this); tvHello.setText("我买了" + car); &#125;&#125; 上面代码中，@Inject注解用来声明依赖，Dagger2中所有的依赖对象都是通过@Inject注解声明的。但是，@Inject注解的字段不能是private和protected。 其次，Dagger2会帮我们自动生成Component的实现类。创建这个类时，需要提供Moudle类的实例。要强调的是，我们需要在编写完Component接口之后，使用rebuild重新生成项目，Dagger2才会帮我们创建好对应的类。 之后，将需求对象，此处为this，传递给inject方法。之后，你就会发现，@Inject注解的字段已经被赋值，而该对象就是我们在Moudle的getCar方法中创建的那个对象。 最简单的用法怎么tm这么麻烦？就tm赋个值就写这么多代码？怕是还不如不用依赖注入方便呢。别急，对于这种简单地依赖情形，我们还有更简单的方法。 创建依赖类12345678910public class Insurance &#123; @Inject public Insurance() &#123; &#125; @Override public String toString() &#123; return "一份保险"; &#125;&#125; 这次，我们直接在依赖类的构造函数上面添加了@Inject注解。当Component在所拥有的Moudle类中找不到需求方需要的类型时，Dagger2就会检查需要的类型有没有被@Inject声明的构造方法，有则用该构造方法去创建一个。 同样，要将这个对象注入到需求方中，也需要在需求方实现代码中添加字段声明并用@Inject注解。 123456789101112public class MainActivity extends AppCompatActivity &#123; ... @Inject Insurance insurance; ... @Override protect void onCreate(Bundle savedInstanceState) &#123; ... tvHello.setText("我买了" + car + "和" + insurance); &#125;&#125; 是不是很简单？那为什么不都用这种方法呢？不过，如果我们使用别人的jar包，是不能修改别人的代码去添加注解的，所以不得不通过Module类来提供对象。 应对依赖的依赖上面的例子中，我们创建的这些依赖类都不用依赖于其他的类。但是，如果需要依赖于其他依赖类，又要怎么使用呢？ 首先我们来创建一个类Driver： 123456789101112131415161718public class Driver &#123; private Car car; private String driver; public Driver(Car car,String name) &#123; this.car = car; driver = name; &#125; public Car getCar() &#123; return car; &#125; @Override public String toString() &#123; return "老司机" + driver + "有一辆" + car; &#125;&#125; 这个Driver类依赖于Car对象，如果我们要在MainActivity中需要注入Driver对象，又该怎么办呢？ 在Module类中增加Provide方法：首先我们会自然地想到在Moudle类中添加如下的方法： 12345@Providespublic Driver getDriver() &#123; Car car = new Car("BWM"); return new Driver("BWM","小明");&#125; 这样的确是可以的，不过我们之前就已经创建了一个提供Car对象的方法，能不能直接利用起来呢？Dagger2提供了这种功能，我们只需要在getDriver的方法中，添加Car参数，Dagger2会自动地像帮助需求对象查找依赖对象那样，找到该方法依赖的Car实例。所以我们的代码可以写成这样： 1234@Providespublic Driver getDriver(Car car) &#123; return new Driver(car,"小明");&#125; 这样，我们就可以在MainActivity注入依赖啦。 12345678910111213141516public class MainActivity extends AppCompatActivity &#123; private TextView mTVHello; @Inject Driver driver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTVHello = (TextView) findViewById(R.id.tv_Hello); MainComponent build = DaggerMainComponent.builder().mainModule(new MainModule()).build(); build.inject(this); mTVHello.setText(driver.toString()); &#125;&#125; 不光如此，带有@Inject注解的构造函数，若是需要依赖于其他对象，Dagger2也会根据这个规则为你自动注入。 Dagger2依赖提供规则总结123456789101112131415161718192021222324//伪代码function(依赖对象) &#123; if (查找Moudle类中是否存在创建依赖对象的方法)&#123; //如果存在 if (检查该方法是否存在参数) &#123; //如果有参数，则递归调用寻找注入方法 function(参数中的依赖对象) &#125; else &#123; //如果没有参数，就直接初始化该实例 return 成功注入一次 &#125; &#125; else &#123; // 如果不存在创建依赖的方法，就查找带Inject注解的构造函数，看是构造函数是否存在参数 if (存在参数) &#123; // 存在参数就去找能否注入 function(参数中的对象) &#125; else &#123; // 不存参数，直接初始化 return 成功注入一次 &#125; &#125;&#125; 可以看到，Dagger2会递归地提供依赖。 进阶篇@Name和@Qulifier@Named最近小明发了大财，于是买了一辆梦寐以求的限量版法拉利。 12345678910//在Module类中修改@Providespublic Car getBWMCar() &#123; return new Car("BWM");&#125;@Providespublic Car getFerrariCar() &#123; return new Car("限量版法拉利");&#125; 我们将小明的法拉利添加到了Moudle中。不过，我们之前提到过，Dagger2是依靠返回值来确定注入对象的。现在我们有两台Car，小明要怎么开上自己最新买的法拉利呢？ Dagger2为我们提供了@Name注解。它有一个参数value，用来区别相同类型的依赖对象。下面的代码展示了如何使用@Name注解： 123456789101112//在Module中@Provides@Named("BWM")public Car getBWMCar() &#123; return new Car("BWM");&#125;@Provides@Named("Ferrari")public Car getFerrariCar() &#123; return new Car("限量版法拉利");&#125; 可以看到，通过@Named注解，我们为相同返回类型的Provides方法，命名加以区分。 在Module类中，也通过@Named注解来标注该调用哪个提供方法： 12345678910111213141516public class MainActivity extends AppCompatActivity &#123; private TextView mTVHello; @Inject @Named("BWM") Car bwmCar; @Inject @Named("Ferrari") Car ferrariCar; @Override protected void onCreate(Bundle savedInstanceState) &#123; ... mTVHello.setText("小明现在有" + bwmCar + "和" + ferrariCar); &#125;&#125; @Qulifier@Qulifier的功能和@Name一样，并且，@Name继承于@Qulifier。那么如何使用@Qulifier呢？需要自定义注解： 1234@Qualifier@Retention(RetentionPolicy.RUNTIME)public @interface BWM() &#123;&#125; 效果和@Named(value)是一样的。在Module中的Provide方法中标注@BWM注解就可以了。 另外，这个两个注解可以用在依赖参数上，比如 1234@Providespublic Driver getDriver(@Named("Ferrari") car) &#123; return new Driver(car, "小明");&#125; @Singleton和@Scope@Singleton小明出车祸了，法拉利撞得面目全非，不过幸好人没出事，没几天就出院了。出院的小明回到家中，看到家门口有一辆和自己一模一样的法拉利，竟然完好无损！这是怎么回事呢？ Module类中的小明和法拉利： 123456789101112@Modulepublic class MainModule &#123; @Provides public Car getFerrariCar() &#123; return new Car("限量版法拉利"); &#125; @Provides public Driver getDriver(Car car) &#123; return new Driver(car, "小明"); &#125;&#125; 接着在MainActivity中声明： 123456789101112131415161718public class MainActivity extends AppCompatActivity &#123; private TextView mTVHello; @Inject Car car; @Inject Driver driver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTVHello = (TextView) findViewById(R.id.tv_Hello); MainComponent build = DaggerMainComponent.builder().mainModule(new MainModule()).build(); build.inject(this); mTVHello.setText("这个car是小明的法拉利吗？"+(car == driver.getCar())); &#125;&#125; 原来这辆车是隔壁老王的。 通过这个例子可以发现，我们在MainActivity中注入的Car和Driver中注入的Car并不是同一个对象。在注入过程中，调用了两次创建依赖对象的方法。 那么，如果需要MainActivity中的Car对象和Driver中的Car对象是同一个对象，又要怎么办呢？Dagger2中，使用@Singleton注解可以实现这个需求: 12345@Singleton@Providespublic Car getFerrariCar() &#123; return new Car("限量版法拉利");&#125; 同时，需要在MainComponent接口中添加该注解： 12345@Singleton@Component(modules=MainModule.class)public interface MainComponent&#123; void inject(MainActivity mainActivity);&#125; @Scope@Scope用来申明作用范围，其实@Singleton就是基于它来实现的。使用它的时候，也需要自定义注解： 1234@Scope@Retention(RetentionPolicy.RUNTIME)public @interface PerActivity &#123;&#125; 之后将Module中的Provide方法打上@PerActivity，就可以将该方法包含在PerActivity作用范围之内。别忘了在Component接口上也要使用这个注解 这个作用范围有什么用呢？在Dagger2里面，同一作用范围内的Provide方法，在需要生成多个依赖对象时，都只会被调用一次，因此，需求方得到的以来对象实例就会是同一个实例。(只有在Moudle类中声明了作用范围的Provide方法才会有这样的行为) Dagger2提供这个注解的目的在于可以让我们自定义作用范围名，提高代码的可读性。 **Note： 在通过构造函数提供依赖的方式中，需要将作用范围在类名上注解，而不是在构造方法上。 只有在同一个Component实例下提供依赖才能实现Singleton。** 组件依赖Dependencies开发中，如果遇到工具类这种，在整个APP生命周期中都是单例的情形该怎么处理呢？ 首先添加一个工具类： 12345public class CarMarket &#123; public Driver deal(Car car, String buyer) &#123; return new Driver(car, buyer); &#125;&#125; 接着建立一个BaseModule来提供工具类： 12345678@Modulepublic class BaseModule &#123; @Singleton @Provides public CarMarket getCarMarket() &#123; return new CarMarket(); &#125;&#125; 再创建一个接口： 12345@Singleton@Component(modules = BaseModule.class)public interface BaseComponent &#123; ClothHandler getClothHandler();&#125; Q:这个Component为什么没有inject方法呢？A:因为BaseComponent这个接口是给其他Component提供依赖的，具体注入由子Component类提供。这里仅仅是告诉其子类BaseComponent能提供这个ClothHandler对象，因此，它不需要inject方法。 接下来，在MainComponent和SecondComponent两个子类中声明依赖。 1234567891011@PerActivity@Component(modules=MainModule.class,dependencies=BaseComponent.class)public interface MainComponent &#123; void inject(MainActivity mainActivity);&#125;@PerActivity@Component(modules=SecondModule.class,dependencies=BaseComponent.class)public interface SecondComponent &#123; void inject(SecondActivity secondActivity);&#125; 此时，rebuild工程就可以看到，创建MainComponent和SecondComponent实例的时候，多了一个baseComponent方法。 我们需要为这个BaseComponent传递一个实例。如果要保证两个子Component能获取同一个BaseComponent实例，有一种方法是：自定义一个Application类。 Q:如何保证某个对象在App生命周期中只有一个实例？A:使用静态工厂，或者自定义一个Application类。 12345678910111213141516// 在Application中持有baseComponent，// 从而获得一个在整个App生命周期内仅有的baseComponent实例，// 这样做还有个隐含好处：// BaseModule中需要Context对象的时候，可以直接传入this。public class MyApplication extends Application &#123; private BaseComponent baseComponent; @Override public void onCreate() &#123; super.onCreate(); baseComponent = DaggerBaseComponent.builder().baseModule(new BaseModule()).build(); &#125; public BaseComponent getBaseComponent() &#123; return baseComponent; &#125; &#125; 创建完自定义类后，还需要在AndroidManifest.xml中声明新建的MyApplication: 12345...&lt;application android:name = ".MyApplication"... 接下来，在MainActivity和SecondActivity中，只需要在构建子Component实例中这样调用就行了: 1MainComponent build = DaggerMainComponent.builder().baseComponent((MyApplication)getApplication()).getBaseComponent()) @Subcomponent注解@Subcomponent注解和dependencies类似，但是@Subcomponent使用起来有点不同，需要在父组件(BaseComponent)中声明一个返回值为子组件（SubComponent）的方法。当子组件需要什么Moudle时，就在该方法中添加该类型的参数： 子组件接口应该改为使用@Subcomponent 12345@PerActivity@Subcomponent(modules=MainModule.class)public interface SubComponent &#123; void inject(MainActivity activity);&#125; 在父组件中需要声明一个提供子组件的方法： 1234567@Singleton@Component(modules=BaseModule.class)public interface BaseComponent &#123; CarMarket getCarMarket(); // @Subcomponent关键点 SubComponent getSubComponent(MainModule module);&#125; 之后调用注入的时候，指定要使用的Module就行了。 12MyApplication application = (MyApplication) getApplication(); application.getBaseComponent().getSubComponent(new MainModule()).inject(this); 使用这个方法同样可以实现单例，因为BaseComponent是同一个实例。 ##Lazy和Provider包装容器这两个容器是用来包装依赖对象的。注入时，如果用这两个容器包装依赖对象，Lazy容器懒加载方式就会只在你需要用到该依赖对象的时候才会去获取一个；而Provider容器的对象不光具有Lazy特性，而且每次要用到的时候，都会重新调用生成依赖对象的方法注入。 12345//在需求类中@InjectLazy&lt;Car&gt; car;@InjectProvider&lt;Driver&gt; driver; 不过，如果声明了单例，Provider也就失去了意义。 ##Component生命周期一般情况下，都是在Activity中的onCreate方法中创建Component实例，再调用inject完成依赖注入。 在onCreate()方法调用完成之后，Component实例就会因为没有被引用而被GC，其中Module实例也会被一并回收。不过，使用Lazy和Provider时，与该依赖对象有关的Module实例会被引用，这个Moudle实例将不会被回收。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android内存泄漏分析]]></title>
      <url>%2F2017%2F03%2F10%2FAndroid%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90.html</url>
      <content type="text"><![CDATA[具体的垃圾回收机制四种引用类型的介绍 强引用（Strong Reference）：JVM宁可抛出OOM，也不会让GC回收具有强引用的对象； 软引用（Soft Reference）：只有在内存空间不足时，才被回收的对象； 软引用（Weak Reference）：在GC时，一旦发现了只具有若引用的对象，不管当前内存空间是否充足，都会回收它的内存； 虚引用（Phantom Reference）：任何时候都可以被GC回收。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否需要回收。 我们常说的内存泄漏是指new出来的Object无法被GC回收，即为强引用。 常见内存泄漏案例case1.单例造成的内存泄漏单利的特性导致其生命周期同应用一样长。解决方案： 1.将该属性的引用方式改为弱引用；2.如果传入Context，使用ApplicationContext。 例子： 泄漏代码片段 1234567891011121314151617181920private static ScrollHelper mInstance;private ScrollHelper() &#123;&#125;public static ScrollHelper getInstance()&#123; if (mInstance == null) &#123; synchronized (ScrollHelper.class) &#123; if (mInstance == null) &#123; mInstance = new ScrollHelper(); &#125; &#125; &#125; return mInstance;&#125;/*** 被单击的View*/private View mScrolledView = null;public void setScrolledView(View scrolledView) &#123; mScrolledView = scrolledView;&#125; 使用弱引用WeakReference之后： 1234567891011121314151617181920private static ScrollHelper mInstance;private ScrollHelper() &#123;&#125;public static ScrollHelper getInstance()&#123; if (mInstance == null) &#123; synchronized (ScrollHelper.class) &#123; if (mInstance == null) &#123; mInstance = new ScrollHelper(); &#125; &#125; &#125; return mInstance;&#125;/*** 被单击的View*/private WeakReference&lt;View&gt; mScrolledViewWeakRef = null;public void setScrolledView(View scrolledView) &#123; mScrolledViewWeakRef = new WeakReference&lt;View&gt;(scrolledView);&#125; case 2. InnerClass匿名内部类在Java中，非静态内部类和匿名类都会潜在地引用它们所属的外部类。如果它们内部做了一些耗时操作，就会造成外围对象不会被回收，从而导致内存泄漏。但是静态内部类却不会。 解决方案： 1.将内部类改为静态内部类；2.如果有强引用Activity中的属性，则将该属性改为弱引用；3.如果允许，尽可能在Activity执行onDestory时，结束掉这些耗时任务。 例子： 1234567891011121314151617181920212223public class LeakAct extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.aty_leak); test(); &#125; //这儿发生泄漏 public void test() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125;&#125; 改为静态匿名内部类： 1234567891011121314151617181920212223public class LeakAct extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.aty_leak); test(); &#125; //加上static，变成静态匿名内部类 public static void test() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125;&#125; Case 3. Activity Context 使用不正确在Android中应用程序通常可以使用两种Context对象：Activity和Application。当类或方法需要Context对象的时候常见的做法就是使用第一个作为Context参数。这就意味着View对象对整个Activity保持引用，因此也就保持对Activity的所有的引用。 假设一个场景，当应用程序有个比较大的Bitmap类型的图片，每次旋转都重新加载图片，所用时间较多。为了提高屏幕旋转时Activity的创建速度，最简单的方法就是将这个Bitmap对象用Static修饰。当一个Drawable绑定在View上，实际上这个View对象就会成为这份Drawable的一个Callback成员变量。而静态变量的生命周期要长于Activity。导致了屏幕旋转时，Activity无法被回收，而造成内存泄漏。解决方案：1.使用ApplicationContext代替ActivityContext，因为ApplicationContext会随着应用程序的存在而存在，而不依赖于Activity的生命周期；2.对Context的引用不要超过它本身的生命周期，慎重地对Context使用“static”关键字。Context里如果有线程，一定要在onDestroy（）里及时停掉。例子： 123456789101112private static Drawable sBackground;@Overrideprotected void onCreate(Bundle state) &#123; super.onCreate(state); TextView label = new TextView(this); label.setText("Leaks are bad"); if (sBackground == null) &#123; sBackground = getDrawable(R.drawable.large_bitmap); &#125; label.setBackgroundDrawable(sBackgroud); setContextView(label);&#125; 解决方案： 123456789101112private static Drawable sBackground;@Overrideprotect void onCreate(Bundle state) &#123; super.onCreate(state); TextView label = new TextView(this); label.setText("Leaks are bad"); if (sBackground == null) &#123; sBackground = getApplicationContext().getDrawable(R.drawable.large_bitmap); &#125; label.setBackgroundDrawable(sBackground); setContextView(label);&#125; case 4. Handler引起的内存泄漏当Handler中有延迟的任务或是等待执行的任务队列过长，由于消息持有对Handler的引用，而Handler又持有对其外部类的引用。这条引用关系会一直保持到消息得到处理，而导致了Activity无法被垃圾回收器回收，而导致了内存泄漏。解决方案：1.可以把Handler类放在单独的类文件中，或者使用静态内部类便可以避免泄漏；2.如果想在Handler内部去调用所在的Activity，那么可以在handler内部使用弱引用的方式去指向所在Activity。使用static+WeakReference的方式来达到断开Handler与Activity之间存在引用关系的目的。解决方案： 123456789@Overrideprotected void doOnDestroy() &#123; super.doOnDestory(); if (mHandler != null) &#123; mHandler.removeCallbackAndMessages(null); &#125; mHandler = null; mRenderCallback = null;&#125; case 5.注册监听器的泄漏系统服务可以通过Context.getSystemService获取，它们负责执行某些后台任务，或者为硬件提供访问接口。如果Context对象想要在服务内部的事件发生时被通知，那就需要把自己注册到服务的监听器中。然而，这会让服务持有Activity的引用，如果在Activity的onDestroy时没有释放掉引用就会内存泄漏。 解决方案： 1.使用ApplicationContext代替ActivityContext；2.在Activity执行onDestroy时，调用反注册； mSensorManager = (SensorManager) this.getSystemService(Context.SENSOR_SERVICE);解决方案：mSensorManager = (SensorManager) getApplicationContext().getSystemService(Context.SENSOR_SERVICE);下面是容易造成内存泄漏的系统服务：InputMethodManager imm = (InputMethod) context.getApplicationContext().getSystemService(Context.INPUT_METHOD_SERVICE);解决方案： 12345678910111213protected void onDetachedFromWindow() &#123; if (this.mActionShell != null) &#123; this.mActionShell.setOnClickListener((OnAreaClickListener)null); &#125; if (this.mButtonShell != null) &#123; this.mButtonShell.setOnClickListener((OnAreaClickListener)null); &#125; if (this.mCountShell != this.mCountShell) &#123; this.mCountShell.setOnClickListener((OnAreaClickListener)null); &#125; super.onDetachedFromWindow();&#125;&#125; case 6. Cursor，Stream没有close，View没有recyle资源性对象比如Cursor、File等往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于JVM中，还存在于JVM之外。如果我们仅仅是把它的引用设置为null，而不是调用其提供的接口关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如SQLiteCursor，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样效率太低了。因此，在使用完资源性对象后，应该调用对应的close()方法，将其关闭后，再设为null。在我们的程序退出时一定要确保我们的资源性对象已经关闭。 case 7. 集合中的对象没有清理造成的泄漏容器中的对象在不需要时，如果没有及时把对象的引用清理掉，这个集合就会越来越大。如果这个集合是static的话情况就更严重。所以在退出程序之前，要将集合里面的东西clear，然后设置为null，在退出程序。解决方案： 在Activity退出之前，将集合中的所有东西clear，然后置null，再退出程序。解决方法： 1234567private List&lt;EmotionPanelInfo&gt; data;public void onDestroy() &#123; if (data != null) &#123; data.clear(); data = null; &#125;&#125; case 8. WebView造成的泄漏当我们不再使用WebView对象时，应该调用它的destroy()函数来销毁它，并释放其内存，否则其占用的内存长期也不能被回收，从而造成内存泄漏。解决方案： 为webView开启另外一个进程，通过AIDL与主线程进行通信，WebView所在的进程可以根据业务需要选择合适的时机进行销毁，从而达到完整的内存释放。 case 9. 构造Adapter时，没有使用缓存的ConvertView初始时ListView会从Adapter中根据当前的屏幕布局实例化一定数量的View对象，同时ListView会将这些View对象缓存起来。当向上滚动ListView时，原先位于最上面的List Item的View对象会被回收，然后被用来构造新出现的最下面的List Item。这个构造过程就是由getView()方法完成的，getView()的第二个形参View ConvertView就是被缓存起来的List Item的View对象（初始化时缓存中没有View对象则ConvertView是null）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[走近科学：揭秘Context]]></title>
      <url>%2F2017%2F03%2F09%2F%E8%B5%B0%E8%BF%91%E7%A7%91%E5%AD%A6%EF%BC%9A%E6%8F%AD%E7%A7%98Context.html</url>
      <content type="text"><![CDATA[Activity可以new吗？Activity mActivity = new Activity();可能很多人没有想过这个问题：Activity可以new吗？本质上，Activity也是一个类，照理来说它应该符合Java的语法，可是上面那种用法到底有什么问题呢？ Android程序不像Java程序，随便写一个类，添加一个main()方法就能运行。Android是基于组件的应用设计模式，组件的运行需要有一个完整的Android工程环境。只有在这个环境下，Activity、Service等系统组件才能正常工作。不过这些组件并不能采取普通的Java对象创建的方式，new一下就能创建实例了。它们的建立需要有各自的上下文环境，而这就是我们要讨论的Context。 Context是维持Andoird程序各组件能正常工作的一个核心功能类。 Context到底是什么？Context的字面意思是“语境”、“上下文”，可以理解为当前对象在程序中的一个环境，一个与系统交互的过程。比如微信聊天，此时的context是指聊天界面以及相关的数据请求与传输。Context在加载资源、启动Activity、获取系统服务、创建View等操作都要参与。 那Android中的Context到底是什么呢？一个Activity就是一个Context，一个Service也是一个Context。Android设计者把“应用场景”抽象为了Context类，认为用户和操作系统的每一种交互都是一个场景。比如打电话、发短信、这些都是一个有界面的场景。还有一些没有界面的场景，比如后台运行的服务（Service）。一个应用程序可以认为是一个工作环境，用户在这个工作环境中会切换到不同的场景。它就像一个公司的前台秘书，可能需要接待客人，可能要打印文件，还可能要接听客户电话。而这些任务就可以称之为不同的场景，这个前台秘书可以称之为一个应用程序。 其实，Context也可以看做是一个应用与系统交互的中间层。在Android的源码中，对Context的注释文档说明： 它是一个抽象类，它的执行被Android系统所提供。它允许获取以应用为特征的资源和类型，是一个统领一些资源（应用程序环境变量等）的上下文。就是说，它描述一个应用程序环境的信息（即上下文）；是一个抽象类，Android提供了该抽象类的具体实现类；通过它我们可以获取应用程序的资源和类（包括应用级别操作，如启动Activity，发广播，接受Intent等）。 Context的实现类既然源码中说明了它是一个抽象类，那么肯定就有它的实现类咯。Context的实现类可以形成如下的关系图：Context类本身是一个纯抽象类，它有两个具体的实现子类：ContextImpl和ContextWrapper。熟悉设计模式的应该可以反应过来，其实就是个装饰者模式的类图。 其中ContextWrapper只是一个包装类。它的构造函数中必须包含一个真正的Context引用，同时ContextWrapper提供了attachBaseContext()用于给ContextWrapper对象中执行真正的Context对象。ContextWrapper中的方法都会被转向其所包含的真正的Context对象。 ContextThemeWrapper类的内部包含了与主题（Theme）相关的接口。这里说的主题就是指在AndroidManifest.xml中，通过android:theme为Application元素或者Activity元素指定的主题。当然，因为只有Activity有可视化界面，Service没有，所以只有Activity才需要主题，因此Service是直接继承与ContextWrapper的，Application同理。 而ContextImpl类才真正实现了Context中的所有方法。应用程序中调用的各种Context类的方法，其实现均来自于该类。 总结一下，ContextImpl是Context的具体实现类，ContextWrapper是Context的包装类。Activity，Application，Service虽然都继承自ContextWrapper，但它们在初始化时都会创建ContextImpl对象，由ContextImpl实现Context中的方法。 一个应用有几个Context？其实我们从关系图中就可以知道，在一个应用程序中，Context的具体实现类就是Activity、Service和Application。 于是，Context的数量 = Activity数量 + Service数量 + 1。 有人会问，Boradcast Receiver，Content Provider呢？它们并不是Context的子类，其所持有的Context都是其他地方传递过去的，所以并不增加Context总数。 Context到底能干什么？Context能实现的功能就太多了，弹出Toast、启动和操作四大组件、获取资源等等都需要Context。 Context作用域虽然Context地位崇高、能力强大，但是并不是随便拿一个Context就能为所欲为的。Context的具体是由ContextImpl实现的，因此绝大多数的场景中，Activity、Service、Application这三种Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity和弹出Dialog。因为一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成返回栈。而Dialog则必须在一个Activity上面弹出（除了System Alert类型的Dialog），因此，Activity类型的Context的用途是最广的。 这里说一下上图中Application和Service所不推荐的两种使用情况。 1.如果我们用ApplicationContext去启动一个LaunchMode为standard的Activity的时候会报错android.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?这是因为非Activity类型的Context并没有所谓的任务栈，所以待启动的Activity就找不到栈了。解决这个问题的方法就是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就为它创建一个新的任务栈，而此时Activity是以singleTask模式启动的。所有这种用Application启动Activity的方式不推荐使用，Service同Application。 2.在Application和Service中去layout inflate也是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。所以这种方式也不推荐使用。 一句话总结：凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。 如何获取Context主要有以下4种方法： View.getContext。返回当前View的Context对象，通常是正在显示的Activity对象。 Activity.getApplicationContext，即获取ApplicationContext。通常我们在使用Context对象，特别是要持有Context对象时，都要优先考虑这个全局的进程Context，可以避免很多内存泄漏问题。 ContextWrapper.getBaseContext()。返回ContextWrapper所包装的那个原始Context，在实际开发中用得很少，不建议使用。 Activity.this，返回当前的Activity实例。UI控件需要使用Activity作为Context对象，但其实默认的Toast实际上也可以用ApplicationContext。getApplication()和getApplicationContext()其实这两个函数获取的都是同一个对象，那么既然结果都是相同的，Android为啥要提供两个功能重复的方法呢？实际上，这两个方法在作用域上有比较大的区别。getApplication()方法只有在Activity和Service才能调用，而另一个方法范围就要广一些，比如在BroadcastReceiver中就可以使用getApplicationContext()来获取。 Context的错误使用引起的内存泄漏这里举两个常见的例子： 1. 错误的单例模式123456789101112131415public class Singleton &#123; private static Singleton instance; private Context mContext; private Singleton(Context context) &#123; this.mContext = context; &#125; public static Singleton getInstance(Context context) &#123; if (instance == null) &#123; instance = new Singleton(context); &#125; return instance; &#125;&#125; instance作为静态对象，位于GC ROOT节点上，生命周期要长于普通的对象。常驻内存的Singleton保存了传入的Activity对象并一直持有，即使Activity被销毁掉，但因为它的引用还存在于一个Singleton中，就不会被GC掉，这就导致了内存泄漏。解决方法是使用弱引用WeakReference；或者传入ApplicationContext。 2. View持有Activity引用123456789101112public class MainActivity extends Activity &#123; private static Drawable mDrawable; @Override protected void onCreate(Bundle saveInstanceState) &#123; super.onCreate(saveInstanceState); setContentView(R.layout.activity_main); ImageView iv = new ImageView(this); mDrawable = getResources().getDrawable(R.drawable.ic_launcher); iv.setImageDrawable(mDrawable); &#125;&#125; 代码中一个静态Drawable对象被设置在ImageView中。而ImageView传入的this是MainActivity的mContext，因为被static修饰的mDrawable是常驻内存的，MainActivity是它的间接引用，所以当MainActivity被销毁时，也不会被GC掉，造成内存泄漏。 使用Context的注意事项一般Context造成的内存泄漏几乎都是当Context被销毁时，由于还存在引用而导致销毁失败。不过Application是伴随进程而存在的唯一的Context，所以： 在Application适用的场景中优先考虑使用它。 不要让生命周期长于Activity的对象持有Activity的引用。 尽量不要在Activity中使用非静态内部类和匿名类，因为它们会持有外部实例的引用。而静态内部类会将外部引用作用为弱引用持有。]]></content>
    </entry>

    
  
  
</search>
