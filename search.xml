<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android内存泄漏分析]]></title>
      <url>%2F2017%2F03%2F10%2Fcj03e5yrn0001hmo67hphn5yo%2F</url>
      <content type="text"><![CDATA[Android内存泄漏分析具体的垃圾回收机制四种引用类型的介绍 强引用（Strong Reference）：JVM宁可抛出OOM，也不会让GC回收具有强引用的对象； 软引用（Soft Reference）：只有在内存空间不足时，才被回收的对象； 软引用（Weak Reference）：在GC时，一旦发现了只具有若引用的对象，不管当前内存空间是否充足，都会回收它的内存； 虚引用（Phantom Reference）：任何时候都可以被GC回收。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否需要回收。 我们常说的内存泄漏是指new出来的Object无法被GC回收，即为强引用。 常见内存泄漏案例case1.单例造成的内存泄漏单利的特性导致其生命周期同应用一样长。解决方案： 1.将该属性的引用方式改为弱引用；2.如果传入Context，使用ApplicationContext。 例子： 泄漏代码片段 1234567891011121314151617181920private static ScrollHelper mInstance;private ScrollHelper() &#123;&#125;public static ScrollHelper getInstance()&#123; if (mInstance == null) &#123; synchronized (ScrollHelper.class) &#123; if (mInstance == null) &#123; mInstance = new ScrollHelper(); &#125; &#125; &#125; return mInstance;&#125;/*** 被单击的View*/private View mScrolledView = null;public void setScrolledView(View scrolledView) &#123; mScrolledView = scrolledView;&#125; 使用弱引用WeakReference之后： 1234567891011121314151617181920private static ScrollHelper mInstance;private ScrollHelper() &#123;&#125;public static ScrollHelper getInstance()&#123; if (mInstance == null) &#123; synchronized (ScrollHelper.class) &#123; if (mInstance == null) &#123; mInstance = new ScrollHelper(); &#125; &#125; &#125; return mInstance;&#125;/*** 被单击的View*/private WeakReference&lt;View&gt; mScrolledViewWeakRef = null;public void setScrolledView(View scrolledView) &#123; mScrolledViewWeakRef = new WeakReference&lt;View&gt;(scrolledView);&#125; case 2. InnerClass匿名内部类在Java中，非静态内部类和匿名类都会潜在地引用它们所属的外部类。如果它们内部做了一些耗时操作，就会造成外围对象不会被回收，从而导致内存泄漏。但是静态内部类却不会。 解决方案： 1.将内部类改为静态内部类；2.如果有强引用Activity中的属性，则将该属性改为弱引用；3.如果允许，尽可能在Activity执行onDestory时，结束掉这些耗时任务。 例子： 1234567891011121314151617181920212223public class LeakAct extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.aty_leak); test(); &#125; //这儿发生泄漏 public void test() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125;&#125; 改为静态匿名内部类： 1234567891011121314151617181920212223public class LeakAct extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.aty_leak); test(); &#125; //加上static，变成静态匿名内部类 public static void test() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125;&#125; Case 3. Activity Context 使用不正确在Android中应用程序通常可以使用两种Context对象：Activity和Application。当类或方法需要Context对象的时候常见的做法就是使用第一个作为Context参数。这就意味着View对象对整个Activity保持引用，因此也就保持对Activity的所有的引用。 假设一个场景，当应用程序有个比较大的Bitmap类型的图片，每次旋转都重新加载图片，所用时间较多。为了提高屏幕旋转时Activity的创建速度，最简单的方法就是将这个Bitmap对象用Static修饰。当一个Drawable绑定在View上，实际上这个View对象就会成为这份Drawable的一个Callback成员变量。而静态变量的生命周期要长于Activity。导致了屏幕旋转时，Activity无法被回收，而造成内存泄漏。解决方案：1.使用ApplicationContext代替ActivityContext，因为ApplicationContext会随着应用程序的存在而存在，而不依赖于Activity的生命周期；2.对Context的引用不要超过它本身的生命周期，慎重地对Context使用“static”关键字。Context里如果有线程，一定要在onDestroy（）里及时停掉。例子： 123456789101112private static Drawable sBackground;@Overrideprotected void onCreate(Bundle state) &#123; super.onCreate(state); TextView label = new TextView(this); label.setText("Leaks are bad"); if (sBackground == null) &#123; sBackground = getDrawable(R.drawable.large_bitmap); &#125; label.setBackgroundDrawable(sBackgroud); setContextView(label);&#125; 解决方案： 123456789101112private static Drawable sBackground;@Overrideprotect void onCreate(Bundle state) &#123; super.onCreate(state); TextView label = new TextView(this); label.setText("Leaks are bad"); if (sBackground == null) &#123; sBackground = getApplicationContext().getDrawable(R.drawable.large_bitmap); &#125; label.setBackgroundDrawable(sBackground); setContextView(label);&#125; case 4. Handler引起的内存泄漏当Handler中有延迟的任务或是等待执行的任务队列过长，由于消息持有对Handler的引用，而Handler又持有对其外部类的引用。这条引用关系会一直保持到消息得到处理，而导致了Activity无法被垃圾回收器回收，而导致了内存泄漏。解决方案：1.可以把Handler类放在单独的类文件中，或者使用静态内部类便可以避免泄漏；2.如果想在Handler内部去调用所在的Activity，那么可以在handler内部使用弱引用的方式去指向所在Activity。使用static+WeakReference的方式来达到断开Handler与Activity之间存在引用关系的目的。解决方案： 123456789@Overrideprotected void doOnDestroy() &#123; super.doOnDestory(); if (mHandler != null) &#123; mHandler.removeCallbackAndMessages(null); &#125; mHandler = null; mRenderCallback = null;&#125; case 5.注册监听器的泄漏系统服务可以通过Context.getSystemService获取，它们负责执行某些后台任务，或者为硬件提供访问接口。如果Context对象想要在服务内部的事件发生时被通知，那就需要把自己注册到服务的监听器中。然而，这会让服务持有Activity的引用，如果在Activity的onDestroy时没有释放掉引用就会内存泄漏。 解决方案： 1.使用ApplicationContext代替ActivityContext；2.在Activity执行onDestroy时，调用反注册； mSensorManager = (SensorManager) this.getSystemService(Context.SENSOR_SERVICE);解决方案：mSensorManager = (SensorManager) getApplicationContext().getSystemService(Context.SENSOR_SERVICE);下面是容易造成内存泄漏的系统服务：InputMethodManager imm = (InputMethod) context.getApplicationContext().getSystemService(Context.INPUT_METHOD_SERVICE);解决方案： 12345678910111213protected void onDetachedFromWindow() &#123; if (this.mActionShell != null) &#123; this.mActionShell.setOnClickListener((OnAreaClickListener)null); &#125; if (this.mButtonShell != null) &#123; this.mButtonShell.setOnClickListener((OnAreaClickListener)null); &#125; if (this.mCountShell != this.mCountShell) &#123; this.mCountShell.setOnClickListener((OnAreaClickListener)null); &#125; super.onDetachedFromWindow();&#125;&#125; case 6. Cursor，Stream没有close，View没有recyle资源性对象比如Cursor、File等往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于JVM中，还存在于JVM之外。如果我们仅仅是把它的引用设置为null，而不是调用其提供的接口关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如SQLiteCursor，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样效率太低了。因此，在使用完资源性对象后，应该调用对应的close()方法，将其关闭后，再设为null。在我们的程序退出时一定要确保我们的资源性对象已经关闭。 case 7. 集合中的对象没有清理造成的泄漏容器中的对象在不需要时，如果没有及时把对象的引用清理掉，这个集合就会越来越大。如果这个集合是static的话情况就更严重。所以在退出程序之前，要将集合里面的东西clear，然后设置为null，在退出程序。解决方案： 在Activity退出之前，将集合中的所有东西clear，然后置null，再退出程序。解决方法： 1234567private List&lt;EmotionPanelInfo&gt; data;public void onDestroy() &#123; if (data != null) &#123; data.clear(); data = null; &#125;&#125; case 8. WebView造成的泄漏当我们不再使用WebView对象时，应该调用它的destroy()函数来销毁它，并释放其内存，否则其占用的内存长期也不能被回收，从而造成内存泄漏。解决方案： 为webView开启另外一个进程，通过AIDL与主线程进行通信，WebView所在的进程可以根据业务需要选择合适的时机进行销毁，从而达到完整的内存释放。 case 9. 构造Adapter时，没有使用缓存的ConvertView初始时ListView会从Adapter中根据当前的屏幕布局实例化一定数量的View对象，同时ListView会将这些View对象缓存起来。当向上滚动ListView时，原先位于最上面的List Item的View对象会被回收，然后被用来构造新出现的最下面的List Item。这个构造过程就是由getView()方法完成的，getView()的第二个形参View ConvertView就是被缓存起来的List Item的View对象（初始化时缓存中没有View对象则ConvertView是null）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[走近科学：揭秘Context]]></title>
      <url>%2F2017%2F03%2F09%2Fcj03e5yri0000hmo6zt2sc4db%2F</url>
      <content type="text"><![CDATA[Activity可以new吗？Activity mActivity = new Activity();可能很多人没有想过这个问题：Activity可以new吗？本质上，Activity也是一个类，照理来说它应该符合Java的语法，可是上面那种用法到底有什么问题呢？ Android程序不像Java程序，随便写一个类，添加一个main()方法就能运行。Android是基于组件的应用设计模式，组件的运行需要有一个完整的Android工程环境。只有在这个环境下，Activity、Service等系统组件才能正常工作。不过这些组件并不能采取普通的Java对象创建的方式，new一下就能创建实例了。它们的建立需要有各自的上下文环境，而这就是我们要讨论的Context。 Context是维持Andoird程序各组件能正常工作的一个核心功能类。 Context到底是什么？Context的字面意思是“语境”、“上下文”，可以理解为当前对象在程序中的一个环境，一个与系统交互的过程。比如微信聊天，此时的context是指聊天界面以及相关的数据请求与传输。Context在加载资源、启动Activity、获取系统服务、创建View等操作都要参与。 那Android中的Context到底是什么呢？一个Activity就是一个Context，一个Service也是一个Context。Android设计者把“应用场景”抽象为了Context类，认为用户和操作系统的每一种交互都是一个场景。比如打电话、发短信、这些都是一个有界面的场景。还有一些没有界面的场景，比如后台运行的服务（Service）。一个应用程序可以认为是一个工作环境，用户在这个工作环境中会切换到不同的场景。它就像一个公司的前台秘书，可能需要接待客人，可能要打印文件，还可能要接听客户电话。而这些任务就可以称之为不同的场景，这个前台秘书可以称之为一个应用程序。 其实，Context也可以看做是一个应用与系统交互的中间层。在Android的源码中，对Context的注释文档说明： 它是一个抽象类，它的执行被Android系统所提供。它允许获取以应用为特征的资源和类型，是一个统领一些资源（应用程序环境变量等）的上下文。就是说，它描述一个应用程序环境的信息（即上下文）；是一个抽象类，Android提供了该抽象类的具体实现类；通过它我们可以获取应用程序的资源和类（包括应用级别操作，如启动Activity，发广播，接受Intent等）。 Context的实现类既然源码中说明了它是一个抽象类，那么肯定就有它的实现类咯。Context的实现类可以形成如下的关系图：Context类本身是一个纯抽象类，它有两个具体的实现子类：ContextImpl和ContextWrapper。熟悉设计模式的应该可以反应过来，其实就是个装饰者模式的类图。 其中ContextWrapper只是一个包装类。它的构造函数中必须包含一个真正的Context引用，同时ContextWrapper提供了attachBaseContext()用于给ContextWrapper对象中执行真正的Context对象。ContextWrapper中的方法都会被转向其所包含的真正的Context对象。 ContextThemeWrapper类的内部包含了与主题（Theme）相关的接口。这里说的主题就是指在AndroidManifest.xml中，通过android:theme为Application元素或者Activity元素指定的主题。当然，因为只有Activity有可视化界面，Service没有，所以只有Activity才需要主题，因此Service是直接继承与ContextWrapper的，Application同理。 而ContextImpl类才真正实现了Context中的所有方法。应用程序中调用的各种Context类的方法，其实现均来自于该类。 总结一下，ContextImpl是Context的具体实现类，ContextWrapper是Context的包装类。Activity，Application，Service虽然都继承自ContextWrapper，但它们在初始化时都会创建ContextImpl对象，由ContextImpl实现Context中的方法。 一个应用有几个Context？其实我们从关系图中就可以知道，在一个应用程序中，Context的具体实现类就是Activity、Service和Application。 于是，Context的数量 = Activity数量 + Service数量 + 1。 有人会问，Boradcast Receiver，Content Provider呢？它们并不是Context的子类，其所持有的Context都是其他地方传递过去的，所以并不增加Context总数。 Context到底能干什么？Context能实现的功能就太多了，弹出Toast、启动和操作四大组件、获取资源等等都需要Context。 Context作用域虽然Context地位崇高、能力强大，但是并不是随便拿一个Context就能为所欲为的。Context的具体是由ContextImpl实现的，因此绝大多数的场景中，Activity、Service、Application这三种Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity和弹出Dialog。因为一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成返回栈。而Dialog则必须在一个Activity上面弹出（除了System Alert类型的Dialog），因此，Activity类型的Context的用途是最广的。 这里说一下上图中Application和Service所不推荐的两种使用情况。 1.如果我们用ApplicationContext去启动一个LaunchMode为standard的Activity的时候会报错android.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?这是因为非Activity类型的Context并没有所谓的任务栈，所以待启动的Activity就找不到栈了。解决这个问题的方法就是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就为它创建一个新的任务栈，而此时Activity是以singleTask模式启动的。所有这种用Application启动Activity的方式不推荐使用，Service同Application。 2.在Application和Service中去layout inflate也是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。所以这种方式也不推荐使用。 一句话总结：凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。 如何获取Context主要有以下4种方法： View.getContext。返回当前View的Context对象，通常是正在显示的Activity对象。 Activity.getApplicationContext，即获取ApplicationContext。通常我们在使用Context对象，特别是要持有Context对象时，都要优先考虑这个全局的进程Context，可以避免很多内存泄漏问题。 ContextWrapper.getBaseContext()。返回ContextWrapper所包装的那个原始Context，在实际开发中用得很少，不建议使用。 Activity.this，返回当前的Activity实例。UI控件需要使用Activity作为Context对象，但其实默认的Toast实际上也可以用ApplicationContext。getApplication()和getApplicationContext()其实这两个函数获取的都是同一个对象，那么既然结果都是相同的，Android为啥要提供两个功能重复的方法呢？实际上，这两个方法在作用域上有比较大的区别。getApplication()方法只有在Activity和Service才能调用，而另一个方法范围就要广一些，比如在BroadcastReceiver中就可以使用getApplicationContext()来获取。 Context的错误使用引起的内存泄漏这里举两个常见的例子： 1. 错误的单例模式123456789101112131415public class Singleton &#123; private static Singleton instance; private Context mContext; private Singleton(Context context) &#123; this.mContext = context; &#125; public static Singleton getInstance(Context context) &#123; if (instance == null) &#123; instance = new Singleton(context); &#125; return instance; &#125;&#125; instance作为静态对象，位于GC ROOT节点上，生命周期要长于普通的对象。常驻内存的Singleton保存了传入的Activity对象并一直持有，即使Activity被销毁掉，但因为它的引用还存在于一个Singleton中，就不会被GC掉，这就导致了内存泄漏。解决方法是使用弱引用WeakReference；或者传入ApplicationContext。 2. View持有Activity引用123456789101112public class MainActivity extends Activity &#123; private static Drawable mDrawable; @Override protected void onCreate(Bundle saveInstanceState) &#123; super.onCreate(saveInstanceState); setContentView(R.layout.activity_main); ImageView iv = new ImageView(this); mDrawable = getResources().getDrawable(R.drawable.ic_launcher); iv.setImageDrawable(mDrawable); &#125;&#125; 代码中一个静态Drawable对象被设置在ImageView中。而ImageView传入的this是MainActivity的mContext，因为被static修饰的mDrawable是常驻内存的，MainActivity是它的间接引用，所以当MainActivity被销毁时，也不会被GC掉，造成内存泄漏。 使用Context的注意事项一般Context造成的内存泄漏几乎都是当Context被销毁时，由于还存在引用而导致销毁失败。不过Application是伴随进程而存在的唯一的Context，所以： 在Application适用的场景中优先考虑使用它。 不要让生命周期长于Activity的对象持有Activity的引用。 尽量不要在Activity中使用非静态内部类和匿名类，因为它们会持有外部实例的引用。而静态内部类会将外部引用作用为弱引用持有。]]></content>
    </entry>

    
  
  
</search>
